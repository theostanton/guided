# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"An object with a globally unique `ID`."
interface Node {
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
}

"The output of our create `Guide` mutation."
type CreateGuidePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Guide` that was created by this mutation."
    guide: Guide
    "An edge for our `Guide`. May be used by Relay 1."
    guideEdge(
        #The method to use when ordering `Guide`.
        orderBy: [GuidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): GuidesEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "Reads a single `User` that is related to this `Guide`."
    userByOwner: User
}

"The output of our create `Ride` mutation."
type CreateRidePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `Guide` that is related to this `Ride`."
    guideByGuide: Guide
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Ride` that was created by this mutation."
    ride: Ride
    "An edge for our `Ride`. May be used by Relay 1."
    rideEdge(
        #The method to use when ordering `Ride`.
        orderBy: [RidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RidesEdge
    "Reads a single `Spot` that is related to this `Ride`."
    spotByFromSpot: Spot
    "Reads a single `Spot` that is related to this `Ride`."
    spotByToSpot: Spot
}

"The output of our create `Spot` mutation."
type CreateSpotPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `Guide` that is related to this `Spot`."
    guideByGuide: Guide
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Spot` that was created by this mutation."
    spot: Spot
    "An edge for our `Spot`. May be used by Relay 1."
    spotEdge(
        #The method to use when ordering `Spot`.
        orderBy: [SpotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SpotsEdge
}

"The output of our create `User` mutation."
type CreateUserPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `User` that was created by this mutation."
    user: User
    "An edge for our `User`. May be used by Relay 1."
    userEdge(
        #The method to use when ordering `User`.
        orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsersEdge
}

"The output of our delete `Guide` mutation."
type DeleteGuidePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedGuideId: ID
    "The `Guide` that was deleted by this mutation."
    guide: Guide
    "An edge for our `Guide`. May be used by Relay 1."
    guideEdge(
        #The method to use when ordering `Guide`.
        orderBy: [GuidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): GuidesEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "Reads a single `User` that is related to this `Guide`."
    userByOwner: User
}

"The output of our delete `Ride` mutation."
type DeleteRidePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedRideId: ID
    "Reads a single `Guide` that is related to this `Ride`."
    guideByGuide: Guide
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Ride` that was deleted by this mutation."
    ride: Ride
    "An edge for our `Ride`. May be used by Relay 1."
    rideEdge(
        #The method to use when ordering `Ride`.
        orderBy: [RidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RidesEdge
    "Reads a single `Spot` that is related to this `Ride`."
    spotByFromSpot: Spot
    "Reads a single `Spot` that is related to this `Ride`."
    spotByToSpot: Spot
}

"The output of our delete `Spot` mutation."
type DeleteSpotPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedSpotId: ID
    "Reads a single `Guide` that is related to this `Spot`."
    guideByGuide: Guide
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Spot` that was deleted by this mutation."
    spot: Spot
    "An edge for our `Spot`. May be used by Relay 1."
    spotEdge(
        #The method to use when ordering `Spot`.
        orderBy: [SpotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SpotsEdge
}

"The output of our delete `User` mutation."
type DeleteUserPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedUserId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `User` that was deleted by this mutation."
    user: User
    "An edge for our `User`. May be used by Relay 1."
    userEdge(
        #The method to use when ordering `User`.
        orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsersEdge
}

type Guide implements Node {
    id: String!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    owner: String
    "Reads and enables pagination through a set of `Ride`."
    ridesByGuide(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: RideCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Ride`.
        orderBy: [RidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RidesConnection!
    slug: String!
    "Reads and enables pagination through a set of `Spot`."
    spotsByGuide(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: SpotCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Spot`.
        orderBy: [SpotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SpotsConnection!
    title: String!
    "Reads a single `User` that is related to this `Guide`."
    userByOwner: User
}

"A connection to a list of `Guide` values."
type GuidesConnection {
    "A list of edges which contains the `Guide` and cursor to aid in pagination."
    edges: [GuidesEdge!]!
    "A list of `Guide` objects."
    nodes: [Guide]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Guide` you could get from the connection."
    totalCount: Int!
}

"A `Guide` edge in the connection."
type GuidesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Guide` at the end of the edge."
    node: Guide
}

"The root mutation type which contains root level fields which mutate data."
type Mutation {
    "Creates a single `Guide`."
    createGuide(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: CreateGuideInput!
    ): CreateGuidePayload
    "Creates a single `Ride`."
    createRide(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: CreateRideInput!
    ): CreateRidePayload
    "Creates a single `Spot`."
    createSpot(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: CreateSpotInput!
    ): CreateSpotPayload
    "Creates a single `User`."
    createUser(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: CreateUserInput!
    ): CreateUserPayload
    "Deletes a single `Guide` using its globally unique id."
    deleteGuide(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: DeleteGuideInput!
    ): DeleteGuidePayload
    "Deletes a single `Guide` using a unique key."
    deleteGuideById(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: DeleteGuideByIdInput!
    ): DeleteGuidePayload
    "Deletes a single `Ride` using its globally unique id."
    deleteRide(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: DeleteRideInput!
    ): DeleteRidePayload
    "Deletes a single `Ride` using a unique key."
    deleteRideById(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: DeleteRideByIdInput!
    ): DeleteRidePayload
    "Deletes a single `Spot` using its globally unique id."
    deleteSpot(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: DeleteSpotInput!
    ): DeleteSpotPayload
    "Deletes a single `Spot` using a unique key."
    deleteSpotById(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: DeleteSpotByIdInput!
    ): DeleteSpotPayload
    "Deletes a single `User` using its globally unique id."
    deleteUser(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: DeleteUserInput!
    ): DeleteUserPayload
    "Deletes a single `User` using a unique key."
    deleteUserByUsername(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: DeleteUserByUsernameInput!
    ): DeleteUserPayload
    "Updates a single `Guide` using its globally unique id and a patch."
    updateGuide(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: UpdateGuideInput!
    ): UpdateGuidePayload
    "Updates a single `Guide` using a unique key and a patch."
    updateGuideById(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: UpdateGuideByIdInput!
    ): UpdateGuidePayload
    "Updates a single `Ride` using its globally unique id and a patch."
    updateRide(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: UpdateRideInput!
    ): UpdateRidePayload
    "Updates a single `Ride` using a unique key and a patch."
    updateRideById(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: UpdateRideByIdInput!
    ): UpdateRidePayload
    "Updates a single `Spot` using its globally unique id and a patch."
    updateSpot(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: UpdateSpotInput!
    ): UpdateSpotPayload
    "Updates a single `Spot` using a unique key and a patch."
    updateSpotById(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: UpdateSpotByIdInput!
    ): UpdateSpotPayload
    "Updates a single `User` using its globally unique id and a patch."
    updateUser(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: UpdateUserInput!
    ): UpdateUserPayload
    "Updates a single `User` using a unique key and a patch."
    updateUserByUsername(
        #The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
        input: UpdateUserByUsernameInput!
    ): UpdateUserPayload
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: Cursor
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: Cursor
}

"The root query type which gives access points into the data universe."
type Query implements Node {
    "Reads and enables pagination through a set of `Guide`."
    allGuides(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: GuideCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Guide`.
        orderBy: [GuidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): GuidesConnection
    "Reads and enables pagination through a set of `Ride`."
    allRides(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: RideCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Ride`.
        orderBy: [RidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RidesConnection
    "Reads and enables pagination through a set of `Spot`."
    allSpots(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: SpotCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Spot`.
        orderBy: [SpotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SpotsConnection
    "Reads and enables pagination through a set of `User`."
    allUsers(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: UserCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `User`.
        orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsersConnection
    "Reads a single `Guide` using its globally unique `ID`."
    guide(
        #The globally unique `ID` to be used in selecting a single `Guide`.
        nodeId: ID!
    ): Guide
    guideById(id: String!): Guide
    "Fetches an object given its globally unique `ID`."
    node(
        #The globally unique `ID`.
        nodeId: ID!
    ): Node
    "The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`."
    nodeId: ID!
    "Exposes the root query type nested one level down. This is helpful for Relay 1 which can only query top level fields if they are in a particular form."
    query: Query!
    "Reads a single `Ride` using its globally unique `ID`."
    ride(
        #The globally unique `ID` to be used in selecting a single `Ride`.
        nodeId: ID!
    ): Ride
    rideById(id: String!): Ride
    "Reads a single `Spot` using its globally unique `ID`."
    spot(
        #The globally unique `ID` to be used in selecting a single `Spot`.
        nodeId: ID!
    ): Spot
    spotById(id: String!): Spot
    "Reads a single `User` using its globally unique `ID`."
    user(
        #The globally unique `ID` to be used in selecting a single `User`.
        nodeId: ID!
    ): User
    userByUsername(username: String!): User
}

type Ride implements Node {
    fromSpot: String!
    guide: String!
    "Reads a single `Guide` that is related to this `Ride`."
    guideByGuide: Guide
    id: String!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    "Reads a single `Spot` that is related to this `Ride`."
    spotByFromSpot: Spot
    "Reads a single `Spot` that is related to this `Ride`."
    spotByToSpot: Spot
    toSpot: String!
}

"A connection to a list of `Ride` values."
type RidesConnection {
    "A list of edges which contains the `Ride` and cursor to aid in pagination."
    edges: [RidesEdge!]!
    "A list of `Ride` objects."
    nodes: [Ride]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Ride` you could get from the connection."
    totalCount: Int!
}

"A `Ride` edge in the connection."
type RidesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Ride` at the end of the edge."
    node: Ride
}

type Spot implements Node {
    guide: String!
    "Reads a single `Guide` that is related to this `Spot`."
    guideByGuide: Guide
    id: String!
    label: String
    locked: Boolean!
    nights: Int!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    "Reads and enables pagination through a set of `Ride`."
    ridesByFromSpot(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: RideCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Ride`.
        orderBy: [RidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RidesConnection!
    "Reads and enables pagination through a set of `Ride`."
    ridesByToSpot(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: RideCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Ride`.
        orderBy: [RidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RidesConnection!
}

"A connection to a list of `Spot` values."
type SpotsConnection {
    "A list of edges which contains the `Spot` and cursor to aid in pagination."
    edges: [SpotsEdge!]!
    "A list of `Spot` objects."
    nodes: [Spot]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Spot` you could get from the connection."
    totalCount: Int!
}

"A `Spot` edge in the connection."
type SpotsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Spot` at the end of the edge."
    node: Spot
}

"The output of our update `Guide` mutation."
type UpdateGuidePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `Guide` that was updated by this mutation."
    guide: Guide
    "An edge for our `Guide`. May be used by Relay 1."
    guideEdge(
        #The method to use when ordering `Guide`.
        orderBy: [GuidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): GuidesEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "Reads a single `User` that is related to this `Guide`."
    userByOwner: User
}

"The output of our update `Ride` mutation."
type UpdateRidePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `Guide` that is related to this `Ride`."
    guideByGuide: Guide
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Ride` that was updated by this mutation."
    ride: Ride
    "An edge for our `Ride`. May be used by Relay 1."
    rideEdge(
        #The method to use when ordering `Ride`.
        orderBy: [RidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RidesEdge
    "Reads a single `Spot` that is related to this `Ride`."
    spotByFromSpot: Spot
    "Reads a single `Spot` that is related to this `Ride`."
    spotByToSpot: Spot
}

"The output of our update `Spot` mutation."
type UpdateSpotPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `Guide` that is related to this `Spot`."
    guideByGuide: Guide
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `Spot` that was updated by this mutation."
    spot: Spot
    "An edge for our `Spot`. May be used by Relay 1."
    spotEdge(
        #The method to use when ordering `Spot`.
        orderBy: [SpotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SpotsEdge
}

"The output of our update `User` mutation."
type UpdateUserPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `User` that was updated by this mutation."
    user: User
    "An edge for our `User`. May be used by Relay 1."
    userEdge(
        #The method to use when ordering `User`.
        orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsersEdge
}

type User implements Node {
    email: String!
    "Reads and enables pagination through a set of `Guide`."
    guidesByOwner(
        #Read all values in the set after (below) this cursor.
        after: Cursor,
        #Read all values in the set before (above) this cursor.
        before: Cursor,
        #A condition to be used in determining which values should be returned by the collection.
        condition: GuideCondition,
        #Only read the first `n` values of the set.
        first: Int,
        #Only read the last `n` values of the set.
        last: Int,
        #Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.
        offset: Int,
        #The method to use when ordering `Guide`.
        orderBy: [GuidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): GuidesConnection!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    password: String!
    username: String!
}

"A connection to a list of `User` values."
type UsersConnection {
    "A list of edges which contains the `User` and cursor to aid in pagination."
    edges: [UsersEdge!]!
    "A list of `User` objects."
    nodes: [User]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `User` you could get from the connection."
    totalCount: Int!
}

"A `User` edge in the connection."
type UsersEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `User` at the end of the edge."
    node: User
}

"Methods to use when ordering `Guide`."
enum GuidesOrderBy {
    ID_ASC
    ID_DESC
    NATURAL
    OWNER_ASC
    OWNER_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    SLUG_ASC
    SLUG_DESC
    TITLE_ASC
    TITLE_DESC
}

"Methods to use when ordering `Ride`."
enum RidesOrderBy {
    FROM_SPOT_ASC
    FROM_SPOT_DESC
    GUIDE_ASC
    GUIDE_DESC
    ID_ASC
    ID_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    TO_SPOT_ASC
    TO_SPOT_DESC
}

"Methods to use when ordering `Spot`."
enum SpotsOrderBy {
    GUIDE_ASC
    GUIDE_DESC
    ID_ASC
    ID_DESC
    LABEL_ASC
    LABEL_DESC
    LOCKED_ASC
    LOCKED_DESC
    NATURAL
    NIGHTS_ASC
    NIGHTS_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
}

"Methods to use when ordering `User`."
enum UsersOrderBy {
    EMAIL_ASC
    EMAIL_DESC
    NATURAL
    PASSWORD_ASC
    PASSWORD_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    USERNAME_ASC
    USERNAME_DESC
}

"All input for the create `Guide` mutation."
input CreateGuideInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Guide` to be created by this mutation."
    guide: GuideInput!
}

"All input for the create `Ride` mutation."
input CreateRideInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Ride` to be created by this mutation."
    ride: RideInput!
}

"All input for the create `Spot` mutation."
input CreateSpotInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `Spot` to be created by this mutation."
    spot: SpotInput!
}

"All input for the create `User` mutation."
input CreateUserInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `User` to be created by this mutation."
    user: UserInput!
}

"All input for the `deleteGuideById` mutation."
input DeleteGuideByIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteGuide` mutation."
input DeleteGuideInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Guide` to be deleted."
    nodeId: ID!
}

"All input for the `deleteRideById` mutation."
input DeleteRideByIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteRide` mutation."
input DeleteRideInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Ride` to be deleted."
    nodeId: ID!
}

"All input for the `deleteSpotById` mutation."
input DeleteSpotByIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
}

"All input for the `deleteSpot` mutation."
input DeleteSpotInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Spot` to be deleted."
    nodeId: ID!
}

"All input for the `deleteUserByUsername` mutation."
input DeleteUserByUsernameInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    username: String!
}

"All input for the `deleteUser` mutation."
input DeleteUserInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `User` to be deleted."
    nodeId: ID!
}

"A condition to be used against `Guide` object types. All fields are tested for equality and combined with a logical ‘and.’"
input GuideCondition {
    "Checks for equality with the object’s `id` field."
    id: String
    "Checks for equality with the object’s `owner` field."
    owner: String
    "Checks for equality with the object’s `slug` field."
    slug: String
    "Checks for equality with the object’s `title` field."
    title: String
}

"An input for mutations affecting `Guide`"
input GuideInput {
    id: String!
    owner: String
    slug: String!
    title: String!
}

"Represents an update to a `Guide`. Fields that are set will be updated."
input GuidePatch {
    id: String
    owner: String
    slug: String
    title: String
}

"A condition to be used against `Ride` object types. All fields are tested for equality and combined with a logical ‘and.’"
input RideCondition {
    "Checks for equality with the object’s `fromSpot` field."
    fromSpot: String
    "Checks for equality with the object’s `guide` field."
    guide: String
    "Checks for equality with the object’s `id` field."
    id: String
    "Checks for equality with the object’s `toSpot` field."
    toSpot: String
}

"An input for mutations affecting `Ride`"
input RideInput {
    fromSpot: String!
    guide: String!
    id: String!
    toSpot: String!
}

"Represents an update to a `Ride`. Fields that are set will be updated."
input RidePatch {
    fromSpot: String
    guide: String
    id: String
    toSpot: String
}

"A condition to be used against `Spot` object types. All fields are tested for equality and combined with a logical ‘and.’"
input SpotCondition {
    "Checks for equality with the object’s `guide` field."
    guide: String
    "Checks for equality with the object’s `id` field."
    id: String
    "Checks for equality with the object’s `label` field."
    label: String
    "Checks for equality with the object’s `locked` field."
    locked: Boolean
    "Checks for equality with the object’s `nights` field."
    nights: Int
}

"An input for mutations affecting `Spot`"
input SpotInput {
    guide: String!
    id: String!
    label: String
    locked: Boolean!
    nights: Int!
}

"Represents an update to a `Spot`. Fields that are set will be updated."
input SpotPatch {
    guide: String
    id: String
    label: String
    locked: Boolean
    nights: Int
}

"All input for the `updateGuideById` mutation."
input UpdateGuideByIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `Guide` being updated."
    guidePatch: GuidePatch!
    id: String!
}

"All input for the `updateGuide` mutation."
input UpdateGuideInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `Guide` being updated."
    guidePatch: GuidePatch!
    "The globally unique `ID` which will identify a single `Guide` to be updated."
    nodeId: ID!
}

"All input for the `updateRideById` mutation."
input UpdateRideByIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Ride` being updated."
    ridePatch: RidePatch!
}

"All input for the `updateRide` mutation."
input UpdateRideInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Ride` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Ride` being updated."
    ridePatch: RidePatch!
}

"All input for the `updateSpotById` mutation."
input UpdateSpotByIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    id: String!
    "An object where the defined keys will be set on the `Spot` being updated."
    spotPatch: SpotPatch!
}

"All input for the `updateSpot` mutation."
input UpdateSpotInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `Spot` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `Spot` being updated."
    spotPatch: SpotPatch!
}

"All input for the `updateUserByUsername` mutation."
input UpdateUserByUsernameInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `User` being updated."
    userPatch: UserPatch!
    username: String!
}

"All input for the `updateUser` mutation."
input UpdateUserInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `User` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `User` being updated."
    userPatch: UserPatch!
}

"A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’"
input UserCondition {
    "Checks for equality with the object’s `email` field."
    email: String
    "Checks for equality with the object’s `password` field."
    password: String
    "Checks for equality with the object’s `username` field."
    username: String
}

"An input for mutations affecting `User`"
input UserInput {
    email: String!
    password: String!
    username: String!
}

"Represents an update to a `User`. Fields that are set will be updated."
input UserPatch {
    email: String
    password: String
    username: String
}


"A location in a connection that can be used for resuming pagination."
scalar Cursor