# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

"An object with a globally unique `ID`."
interface Node {
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
}

type AddSpotResult {
    id: String
    messaage: String
    success: Boolean!
}

"The output of our `authenticate` mutation."
type AuthenticatePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    jwtToken: JwtToken
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

type Bound {
    east: Float
    north: Float
    south: Float
    west: Float
}

type Computation implements Node {
    created: Datetime!
    duration: Int
    ended: Datetime
    guide: String!
    "Reads a single `Guide` that is related to this `Computation`."
    guideByGuide: Guide
    id: String!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    stage: String
    "Reads a single `Stage` that is related to this `Computation`."
    stageByStage: Stage
    started: Datetime
    status: ComputationStatus!
}

"A connection to a list of `Computation` values."
type ComputationsConnection {
    "A list of edges which contains the `Computation` and cursor to aid in pagination."
    edges: [ComputationsEdge!]!
    "A list of `Computation` objects."
    nodes: [Computation]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Computation` you could get from the connection."
    totalCount: Int!
}

"A `Computation` edge in the connection."
type ComputationsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Computation` at the end of the edge."
    node: Computation
}

"The output of our create `FeedEvent` mutation."
type CreateFeedEventPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `FeedEvent` that was created by this mutation."
    feedEvent: FeedEvent
    "An edge for our `FeedEvent`. May be used by Relay 1."
    feedEventEdge(
        "The method to use when ordering `FeedEvent`."
        orderBy: [FeedEventsOrderBy!] = [PRIMARY_KEY_ASC]
    ): FeedEventsEdge
    "Reads a single `Guide` that is related to this `FeedEvent`."
    guideByGuide: Guide
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "Reads a single `Ride` that is related to this `FeedEvent`."
    rideByRide: Ride
    "Reads a single `User` that is related to this `FeedEvent`."
    userByUser: User
}

type CreateGuideResult {
    guideId: String
    message: String
    success: Boolean!
}

"The output of our create `User` mutation."
type CreateUserPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `User` that was created by this mutation."
    user: User
    "An edge for our `User`. May be used by Relay 1."
    userEdge(
        "The method to use when ordering `User`."
        orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsersEdge
}

"The output of our delete `FeedEvent` mutation."
type DeleteFeedEventPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    deletedFeedEventNodeId: ID
    "The `FeedEvent` that was deleted by this mutation."
    feedEvent: FeedEvent
    "An edge for our `FeedEvent`. May be used by Relay 1."
    feedEventEdge(
        "The method to use when ordering `FeedEvent`."
        orderBy: [FeedEventsOrderBy!] = [PRIMARY_KEY_ASC]
    ): FeedEventsEdge
    "Reads a single `Guide` that is related to this `FeedEvent`."
    guideByGuide: Guide
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "Reads a single `Ride` that is related to this `FeedEvent`."
    rideByRide: Ride
    "Reads a single `User` that is related to this `FeedEvent`."
    userByUser: User
}

type DeleteGuideResult {
    message: String
    success: Boolean!
}

type FeedEvent implements Node {
    guide: String
    "Reads a single `Guide` that is related to this `FeedEvent`."
    guideByGuide: Guide
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    ride: String
    "Reads a single `Ride` that is related to this `FeedEvent`."
    rideByRide: Ride
    timestamp: Datetime!
    type: FeedEventType!
    user: String
    "Reads a single `User` that is related to this `FeedEvent`."
    userByUser: User
}

"A connection to a list of `FeedEvent` values."
type FeedEventsConnection {
    "A list of edges which contains the `FeedEvent` and cursor to aid in pagination."
    edges: [FeedEventsEdge!]!
    "A list of `FeedEvent` objects."
    nodes: [FeedEvent]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `FeedEvent` you could get from the connection."
    totalCount: Int!
}

"A `FeedEvent` edge in the connection."
type FeedEventsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `FeedEvent` at the end of the edge."
    node: FeedEvent
}

type Follow {
    followed: String!
    follower: String!
    timestamp: Datetime!
    "Reads a single `User` that is related to this `Follow`."
    userByFollowed: User
    "Reads a single `User` that is related to this `Follow`."
    userByFollower: User
}

"A connection to a list of `Follow` values."
type FollowsConnection {
    "A list of edges which contains the `Follow` and cursor to aid in pagination."
    edges: [FollowsEdge!]!
    "A list of `Follow` objects."
    nodes: [Follow]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Follow` you could get from the connection."
    totalCount: Int!
}

"A `Follow` edge in the connection."
type FollowsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Follow` at the end of the edge."
    node: Follow
}

type Geocode {
    countryCode: String!
    label: String!
    latitude: Float!
    longitude: Float!
}

type GeocodeResponse {
    geocodes: [Geocode]
    success: Boolean!
}

type Guide implements Node {
    bounds: Bound
    "Reads and enables pagination through a set of `Computation`."
    computationsByGuide(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: ComputationCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: ComputationFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Computation`."
        orderBy: [ComputationsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ComputationsConnection!
    countries: [String]
    created: Datetime!
    distanceMeters: BigInt
    durationSeconds: BigInt
    endDate: String
    "Reads and enables pagination through a set of `FeedEvent`."
    feedEventsByGuide(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: FeedEventCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: FeedEventFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `FeedEvent`."
        orderBy: [FeedEventsOrderBy!] = [PRIMARY_KEY_ASC]
    ): FeedEventsConnection!
    id: String!
    isCircular: Boolean!
    isMine: Boolean
    maxHoursPerRide: Int!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    owner: String!
    "Reads and enables pagination through a set of `Ride`."
    ridesByGuide(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RideCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RideFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Ride`."
        orderBy: [RidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RidesConnection!
    slug: String!
    "Reads and enables pagination through a set of `Spot`."
    spotsByGuide(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: SpotCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: SpotFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Spot`."
        orderBy: [SpotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SpotsConnection!
    "Reads and enables pagination through a set of `Stage`."
    stagesByGuide(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: StageCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: StageFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Stage`."
        orderBy: [StagesOrderBy!] = [PRIMARY_KEY_ASC]
    ): StagesConnection!
    startDate: String
    title: String!
    transportType: TransportType!
    updated: Datetime
    "Reads a single `User` that is related to this `Guide`."
    userByOwner: User
}

"A connection to a list of `Guide` values."
type GuidesConnection {
    "A list of edges which contains the `Guide` and cursor to aid in pagination."
    edges: [GuidesEdge!]!
    "A list of `Guide` objects."
    nodes: [Guide]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Guide` you could get from the connection."
    totalCount: Int!
}

"A `Guide` edge in the connection."
type GuidesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Guide` at the end of the edge."
    node: Guide
}

"The root mutation type which contains root level fields which mutate data."
type Mutation {
    addSpot(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: AddSpotInput!
    ): AddSpotResult!
    "Creates a JWT token that will securely identify a person and give them certain permissions. This token expires in 2 days."
    authenticate(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: AuthenticateInput!
    ): AuthenticatePayload
    "Creates a single `FeedEvent`."
    createFeedEvent(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: CreateFeedEventInput!
    ): CreateFeedEventPayload
    createGuide(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: CreateGuideInput
    ): CreateGuideResult!
    "Creates a single `User`."
    createUser(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: CreateUserInput!
    ): CreateUserPayload
    "Deletes a single `FeedEvent` using a unique key."
    deleteFeedEvent(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteFeedEventInput!
    ): DeleteFeedEventPayload
    "Deletes a single `FeedEvent` using its globally unique id."
    deleteFeedEventByNodeId(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteFeedEventByNodeIdInput!
    ): DeleteFeedEventPayload
    deleteGuide(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteGuideInput
    ): DeleteGuideResult!
    followUser(username: String!): Result!
    "Registers a single user"
    register(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: RegisterInput!
    ): RegisterPayload
    remvoeSpot(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: RemoveSpotInput!
    ): RemoveSpotResult!
    unfollowUser(username: String!): Result!
    "Updates a single `FeedEvent` using a unique key and a patch."
    updateFeedEvent(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateFeedEventInput!
    ): UpdateFeedEventPayload
    "Updates a single `FeedEvent` using its globally unique id and a patch."
    updateFeedEventByNodeId(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateFeedEventByNodeIdInput!
    ): UpdateFeedEventPayload
    updateGuide(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateGuidePatch
    ): UpdateGuideResult!
    updateSpot(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateSpotPatch!
    ): UpdateSpotResult!
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: Cursor
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: Cursor
}

"The root query type which gives access points into the data universe."
type Query implements Node {
    appVersion: String!
    computation(id: String!): Computation
    "Reads a single `Computation` using its globally unique `ID`."
    computationByNodeId(
        "The globally unique `ID` to be used in selecting a single `Computation`."
        nodeId: ID!
    ): Computation
    "Reads and enables pagination through a set of `Computation`."
    computations(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: ComputationCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: ComputationFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Computation`."
        orderBy: [ComputationsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ComputationsConnection
    countries: [String]
    "Reads and enables pagination through a set of `FeedEvent`."
    feed(
        _username: String,
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A filter to be used in determining which values should be returned by the collection."
        filter: FeedEventFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        pageOffset: Int,
        perPage: Int
    ): FeedEventsConnection!
    feedEvent(timestamp: Datetime!): FeedEvent
    "Reads a single `FeedEvent` using its globally unique `ID`."
    feedEventByNodeId(
        "The globally unique `ID` to be used in selecting a single `FeedEvent`."
        nodeId: ID!
    ): FeedEvent
    "Reads and enables pagination through a set of `FeedEvent`."
    feedEvents(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: FeedEventCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: FeedEventFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `FeedEvent`."
        orderBy: [FeedEventsOrderBy!] = [PRIMARY_KEY_ASC]
    ): FeedEventsConnection
    "Reads and enables pagination through a set of `Follow`."
    follows(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: FollowCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: FollowFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Follow`."
        orderBy: [FollowsOrderBy!] = [NATURAL]
    ): FollowsConnection
    geocode(query: String!): GeocodeResponse!
    getCurrentUser: JwtToken
    guide(id: String!): Guide
    "Reads a single `Guide` using its globally unique `ID`."
    guideByNodeId(
        "The globally unique `ID` to be used in selecting a single `Guide`."
        nodeId: ID!
    ): Guide
    "Reads and enables pagination through a set of `Guide`."
    guides(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: GuideCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: GuideFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Guide`."
        orderBy: [GuidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): GuidesConnection
    "Fetches an object given its globally unique `ID`."
    node(
        "The globally unique `ID`."
        nodeId: ID!
    ): Node
    "The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`."
    nodeId: ID!
    "Exposes the root query type nested one level down. This is helpful for Relay 1 which can only query top level fields if they are in a particular form."
    query: Query!
    ride(id: String!): Ride
    "Reads a single `Ride` using its globally unique `ID`."
    rideByNodeId(
        "The globally unique `ID` to be used in selecting a single `Ride`."
        nodeId: ID!
    ): Ride
    "Reads and enables pagination through a set of `Ride`."
    rides(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RideCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RideFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Ride`."
        orderBy: [RidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RidesConnection
    spot(id: String!): Spot
    "Reads a single `Spot` using its globally unique `ID`."
    spotByNodeId(
        "The globally unique `ID` to be used in selecting a single `Spot`."
        nodeId: ID!
    ): Spot
    "Reads and enables pagination through a set of `Spot`."
    spots(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: SpotCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: SpotFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Spot`."
        orderBy: [SpotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SpotsConnection
    stage(id: String!): Stage
    "Reads a single `Stage` using its globally unique `ID`."
    stageByNodeId(
        "The globally unique `ID` to be used in selecting a single `Stage`."
        nodeId: ID!
    ): Stage
    "Reads and enables pagination through a set of `Stage`."
    stages(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: StageCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: StageFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Stage`."
        orderBy: [StagesOrderBy!] = [PRIMARY_KEY_ASC]
    ): StagesConnection
    temperature(id: String!): Temperature
    "Reads a single `Temperature` using its globally unique `ID`."
    temperatureByNodeId(
        "The globally unique `ID` to be used in selecting a single `Temperature`."
        nodeId: ID!
    ): Temperature
    "Reads and enables pagination through a set of `Temperature`."
    temperatures(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: TemperatureCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: TemperatureFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Temperature`."
        orderBy: [TemperaturesOrderBy!] = [PRIMARY_KEY_ASC]
    ): TemperaturesConnection
    user(username: String!): User
    "Reads a single `User` using its globally unique `ID`."
    userByNodeId(
        "The globally unique `ID` to be used in selecting a single `User`."
        nodeId: ID!
    ): User
    "Reads and enables pagination through a set of `User`."
    users(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: UserCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: UserFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `User`."
        orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsersConnection
}

"The output of our `register` mutation."
type RegisterPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    user: User
    "An edge for our `User`. May be used by Relay 1."
    userEdge(
        "The method to use when ordering `User`."
        orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsersEdge
}

type RemoveSpotResult {
    message: String
    success: Boolean!
}

type Result {
    message: String
    success: Boolean!
}

type Ride implements Node {
    countries: [String]
    created: Datetime!
    date: String
    distanceMeters: Int
    durationSeconds: Int
    "Reads and enables pagination through a set of `FeedEvent`."
    feedEventsByRide(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: FeedEventCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: FeedEventFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `FeedEvent`."
        orderBy: [FeedEventsOrderBy!] = [PRIMARY_KEY_ASC]
    ): FeedEventsConnection!
    fromSpot: String!
    guide: String!
    "Reads a single `Guide` that is related to this `Ride`."
    guideByGuide: Guide
    hasBorder: Boolean
    id: String!
    isMine: Boolean
    name: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    owner: String!
    pathUrl: String
    position: String
    "Reads a single `Spot` that is related to this `Ride`."
    spotByFromSpot: Spot
    "Reads a single `Spot` that is related to this `Ride`."
    spotByToSpot: Spot
    stage: String!
    "Reads a single `Stage` that is related to this `Ride`."
    stageByStage: Stage
    status: RideStatus!
    toSpot: String!
    updated: Datetime
    "Reads a single `User` that is related to this `Ride`."
    userByOwner: User
}

"A connection to a list of `Ride` values."
type RidesConnection {
    "A list of edges which contains the `Ride` and cursor to aid in pagination."
    edges: [RidesEdge!]!
    "A list of `Ride` objects."
    nodes: [Ride]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Ride` you could get from the connection."
    totalCount: Int!
}

"A `Ride` edge in the connection."
type RidesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Ride` at the end of the edge."
    node: Ride
}

type Spot implements Node {
    country: String
    created: Datetime!
    date: String
    guide: String!
    "Reads a single `Guide` that is related to this `Spot`."
    guideByGuide: Guide
    id: String!
    isMine: Boolean
    label: String
    lat: Float!
    location: String
    locked: Boolean!
    long: Float!
    name: String
    nights: Int
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    owner: String!
    position: String
    "Reads and enables pagination through a set of `Ride`."
    ridesByFromSpot(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RideCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RideFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Ride`."
        orderBy: [RidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RidesConnection!
    "Reads and enables pagination through a set of `Ride`."
    ridesByToSpot(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RideCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RideFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Ride`."
        orderBy: [RidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RidesConnection!
    stage: String
    "Reads a single `Stage` that is related to this `Spot`."
    stageByStage: Stage
    "Reads and enables pagination through a set of `Stage`."
    stagesByFromSpot(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: StageCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: StageFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Stage`."
        orderBy: [StagesOrderBy!] = [PRIMARY_KEY_ASC]
    ): StagesConnection!
    "Reads and enables pagination through a set of `Stage`."
    stagesByToSpot(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: StageCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: StageFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Stage`."
        orderBy: [StagesOrderBy!] = [PRIMARY_KEY_ASC]
    ): StagesConnection!
    temperature: Float
    updated: Datetime
    "Reads a single `User` that is related to this `Spot`."
    userByOwner: User
}

"A connection to a list of `Spot` values."
type SpotsConnection {
    "A list of edges which contains the `Spot` and cursor to aid in pagination."
    edges: [SpotsEdge!]!
    "A list of `Spot` objects."
    nodes: [Spot]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Spot` you could get from the connection."
    totalCount: Int!
}

"A `Spot` edge in the connection."
type SpotsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Spot` at the end of the edge."
    node: Spot
}

type Stage implements Node {
    "Reads and enables pagination through a set of `Computation`."
    computationsByStage(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: ComputationCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: ComputationFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Computation`."
        orderBy: [ComputationsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ComputationsConnection!
    created: Datetime!
    fromSpot: String!
    guide: String!
    "Reads a single `Guide` that is related to this `Stage`."
    guideByGuide: Guide
    id: String!
    name: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    position: Int
    "Reads and enables pagination through a set of `Ride`."
    ridesByStage(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RideCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RideFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Ride`."
        orderBy: [RidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RidesConnection!
    "Reads a single `Spot` that is related to this `Stage`."
    spotByFromSpot: Spot
    "Reads a single `Spot` that is related to this `Stage`."
    spotByToSpot: Spot
    "Reads and enables pagination through a set of `Spot`."
    spotsByStage(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: SpotCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: SpotFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Spot`."
        orderBy: [SpotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SpotsConnection!
    status: StageStatus!
    toSpot: String!
    updated: Datetime
}

"A connection to a list of `Stage` values."
type StagesConnection {
    "A list of edges which contains the `Stage` and cursor to aid in pagination."
    edges: [StagesEdge!]!
    "A list of `Stage` objects."
    nodes: [Stage]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Stage` you could get from the connection."
    totalCount: Int!
}

"A `Stage` edge in the connection."
type StagesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Stage` at the end of the edge."
    node: Stage
}

"""

The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.

#### Live Queries

Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.

_(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_

Live queries can be very expensive, so try and keep them small and focussed.

#### Events

Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
"""
type Subscription {
    " (live)"
    appVersion: String!
    " (live)"
    computation(id: String!): Computation
    "Reads a single `Computation` using its globally unique `ID`. (live)"
    computationByNodeId(
        "The globally unique `ID` to be used in selecting a single `Computation`."
        nodeId: ID!
    ): Computation
    "Reads and enables pagination through a set of `Computation`. (live)"
    computations(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: ComputationCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: ComputationFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Computation`."
        orderBy: [ComputationsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ComputationsConnection
    " (live)"
    countries: [String]
    "Reads and enables pagination through a set of `FeedEvent`. (live)"
    feed(
        _username: String,
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A filter to be used in determining which values should be returned by the collection."
        filter: FeedEventFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        pageOffset: Int,
        perPage: Int
    ): FeedEventsConnection!
    " (live)"
    feedEvent(timestamp: Datetime!): FeedEvent
    "Reads a single `FeedEvent` using its globally unique `ID`. (live)"
    feedEventByNodeId(
        "The globally unique `ID` to be used in selecting a single `FeedEvent`."
        nodeId: ID!
    ): FeedEvent
    "Reads and enables pagination through a set of `FeedEvent`. (live)"
    feedEvents(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: FeedEventCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: FeedEventFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `FeedEvent`."
        orderBy: [FeedEventsOrderBy!] = [PRIMARY_KEY_ASC]
    ): FeedEventsConnection
    "Reads and enables pagination through a set of `Follow`. (live)"
    follows(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: FollowCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: FollowFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Follow`."
        orderBy: [FollowsOrderBy!] = [NATURAL]
    ): FollowsConnection
    " (live)"
    geocode(query: String!): GeocodeResponse!
    " (live)"
    getCurrentUser: JwtToken
    " (live)"
    guide(id: String!): Guide
    "Reads a single `Guide` using its globally unique `ID`. (live)"
    guideByNodeId(
        "The globally unique `ID` to be used in selecting a single `Guide`."
        nodeId: ID!
    ): Guide
    "Reads and enables pagination through a set of `Guide`. (live)"
    guides(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: GuideCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: GuideFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Guide`."
        orderBy: [GuidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): GuidesConnection
    "Fetches an object given its globally unique `ID`. (live)"
    node(
        "The globally unique `ID`."
        nodeId: ID!
    ): Node
    "The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. (live)"
    nodeId: ID!
    "Exposes the root query type nested one level down. This is helpful for Relay 1 which can only query top level fields if they are in a particular form. (live)"
    query: Query!
    " (live)"
    ride(id: String!): Ride
    "Reads a single `Ride` using its globally unique `ID`. (live)"
    rideByNodeId(
        "The globally unique `ID` to be used in selecting a single `Ride`."
        nodeId: ID!
    ): Ride
    "Reads and enables pagination through a set of `Ride`. (live)"
    rides(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RideCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RideFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Ride`."
        orderBy: [RidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RidesConnection
    " (live)"
    spot(id: String!): Spot
    "Reads a single `Spot` using its globally unique `ID`. (live)"
    spotByNodeId(
        "The globally unique `ID` to be used in selecting a single `Spot`."
        nodeId: ID!
    ): Spot
    "Reads and enables pagination through a set of `Spot`. (live)"
    spots(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: SpotCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: SpotFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Spot`."
        orderBy: [SpotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SpotsConnection
    " (live)"
    stage(id: String!): Stage
    "Reads a single `Stage` using its globally unique `ID`. (live)"
    stageByNodeId(
        "The globally unique `ID` to be used in selecting a single `Stage`."
        nodeId: ID!
    ): Stage
    "Reads and enables pagination through a set of `Stage`. (live)"
    stages(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: StageCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: StageFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Stage`."
        orderBy: [StagesOrderBy!] = [PRIMARY_KEY_ASC]
    ): StagesConnection
    " (live)"
    temperature(id: String!): Temperature
    "Reads a single `Temperature` using its globally unique `ID`. (live)"
    temperatureByNodeId(
        "The globally unique `ID` to be used in selecting a single `Temperature`."
        nodeId: ID!
    ): Temperature
    "Reads and enables pagination through a set of `Temperature`. (live)"
    temperatures(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: TemperatureCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: TemperatureFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Temperature`."
        orderBy: [TemperaturesOrderBy!] = [PRIMARY_KEY_ASC]
    ): TemperaturesConnection
    " (live)"
    user(username: String!): User
    "Reads a single `User` using its globally unique `ID`. (live)"
    userByNodeId(
        "The globally unique `ID` to be used in selecting a single `User`."
        nodeId: ID!
    ): User
    "Reads and enables pagination through a set of `User`. (live)"
    users(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: UserCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: UserFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `User`."
        orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): UsersConnection
}

type Temperature implements Node {
    country: String!
    created: Datetime!
    id: String!
    month: Int!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    temperature: Float!
    updated: Datetime
}

"A connection to a list of `Temperature` values."
type TemperaturesConnection {
    "A list of edges which contains the `Temperature` and cursor to aid in pagination."
    edges: [TemperaturesEdge!]!
    "A list of `Temperature` objects."
    nodes: [Temperature]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Temperature` you could get from the connection."
    totalCount: Int!
}

"A `Temperature` edge in the connection."
type TemperaturesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Temperature` at the end of the edge."
    node: Temperature
}

"The output of our update `FeedEvent` mutation."
type UpdateFeedEventPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `FeedEvent` that was updated by this mutation."
    feedEvent: FeedEvent
    "An edge for our `FeedEvent`. May be used by Relay 1."
    feedEventEdge(
        "The method to use when ordering `FeedEvent`."
        orderBy: [FeedEventsOrderBy!] = [PRIMARY_KEY_ASC]
    ): FeedEventsEdge
    "Reads a single `Guide` that is related to this `FeedEvent`."
    guideByGuide: Guide
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "Reads a single `Ride` that is related to this `FeedEvent`."
    rideByRide: Ride
    "Reads a single `User` that is related to this `FeedEvent`."
    userByUser: User
}

type UpdateGuideResult {
    id: String
    message: String
    success: Boolean!
    triggeredComputations: Boolean
    triggeredDates: Boolean
}

type UpdateSpotResult {
    ammendedDates: Boolean
    id: String
    message: String
    success: Boolean!
    triggeredComputations: Boolean
}

type User implements Node {
    colour: Colour
    countries: [String]
    created: Datetime!
    distanceMeters: BigInt
    durationSeconds: BigInt
    email: String!
    "Reads and enables pagination through a set of `FeedEvent`."
    feedEventsByUser(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: FeedEventCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: FeedEventFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `FeedEvent`."
        orderBy: [FeedEventsOrderBy!] = [PRIMARY_KEY_ASC]
    ): FeedEventsConnection!
    followingStatus: FollowingStatus
    "Reads and enables pagination through a set of `Follow`."
    followsByFollowed(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: FollowCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: FollowFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Follow`."
        orderBy: [FollowsOrderBy!] = [NATURAL]
    ): FollowsConnection!
    "Reads and enables pagination through a set of `Follow`."
    followsByFollower(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: FollowCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: FollowFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Follow`."
        orderBy: [FollowsOrderBy!] = [NATURAL]
    ): FollowsConnection!
    "Reads and enables pagination through a set of `Guide`."
    guidesByOwner(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: GuideCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: GuideFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Guide`."
        orderBy: [GuidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): GuidesConnection!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    passwordHash: String!
    "Reads and enables pagination through a set of `Ride`."
    ridesByOwner(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RideCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RideFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Ride`."
        orderBy: [RidesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RidesConnection!
    "Reads and enables pagination through a set of `Spot`."
    spotsByOwner(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: SpotCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: SpotFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Spot`."
        orderBy: [SpotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): SpotsConnection!
    updated: Datetime
    username: String!
}

"A connection to a list of `User` values."
type UsersConnection {
    "A list of edges which contains the `User` and cursor to aid in pagination."
    edges: [UsersEdge!]!
    "A list of `User` objects."
    nodes: [User]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `User` you could get from the connection."
    totalCount: Int!
}

"A `User` edge in the connection."
type UsersEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `User` at the end of the edge."
    node: User
}

enum Colour {
    BLACK
    BLUE
    BROWN
    GREEN
    GREY
    OLIVE
    ORANGE
    PINK
    PURPLE
    RED
    TEAL
    VIOLET
    YELLOW
}

enum ComputationStatus {
    COMPUTING
    FAILED
    SCHEDULED
    SUCCESS
}

"Methods to use when ordering `Computation`."
enum ComputationsOrderBy {
    CREATED_ASC
    CREATED_DESC
    DURATION_ASC
    DURATION_DESC
    ENDED_ASC
    ENDED_DESC
    GUIDE_ASC
    GUIDE_DESC
    ID_ASC
    ID_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    STAGE_ASC
    STAGE_DESC
    STARTED_ASC
    STARTED_DESC
    STATUS_ASC
    STATUS_DESC
}

enum FeedEventType {
    NEW_FOLLOWS
    NEW_GUIDE
    SELF_CREATED
}

"Methods to use when ordering `FeedEvent`."
enum FeedEventsOrderBy {
    GUIDE_ASC
    GUIDE_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    RIDE_ASC
    RIDE_DESC
    TIMESTAMP_ASC
    TIMESTAMP_DESC
    TYPE_ASC
    TYPE_DESC
    USER_ASC
    USER_DESC
}

enum FollowingStatus {
    ANONYMOUS
    FOLLOWING
    IS_SELF
    NOT_FOLLOWING
}

"Methods to use when ordering `Follow`."
enum FollowsOrderBy {
    FOLLOWED_ASC
    FOLLOWED_DESC
    FOLLOWER_ASC
    FOLLOWER_DESC
    NATURAL
    TIMESTAMP_ASC
    TIMESTAMP_DESC
}

"Methods to use when ordering `Guide`."
enum GuidesOrderBy {
    CREATED_ASC
    CREATED_DESC
    ID_ASC
    ID_DESC
    IS_CIRCULAR_ASC
    IS_CIRCULAR_DESC
    MAX_HOURS_PER_RIDE_ASC
    MAX_HOURS_PER_RIDE_DESC
    NATURAL
    OWNER_ASC
    OWNER_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    SLUG_ASC
    SLUG_DESC
    START_DATE_ASC
    START_DATE_DESC
    TITLE_ASC
    TITLE_DESC
    TRANSPORT_TYPE_ASC
    TRANSPORT_TYPE_DESC
    UPDATED_ASC
    UPDATED_DESC
}

enum RideStatus {
    COMPLETE
    READY
    STALE
}

"Methods to use when ordering `Ride`."
enum RidesOrderBy {
    CREATED_ASC
    CREATED_DESC
    DATE_ASC
    DATE_DESC
    DISTANCE_METERS_ASC
    DISTANCE_METERS_DESC
    DURATION_SECONDS_ASC
    DURATION_SECONDS_DESC
    FROM_SPOT_ASC
    FROM_SPOT_DESC
    GUIDE_ASC
    GUIDE_DESC
    ID_ASC
    ID_DESC
    NATURAL
    OWNER_ASC
    OWNER_DESC
    PATH_URL_ASC
    PATH_URL_DESC
    POSITION_ASC
    POSITION_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    STAGE_ASC
    STAGE_DESC
    STATUS_ASC
    STATUS_DESC
    TO_SPOT_ASC
    TO_SPOT_DESC
    UPDATED_ASC
    UPDATED_DESC
}

"Methods to use when ordering `Spot`."
enum SpotsOrderBy {
    COUNTRY_ASC
    COUNTRY_DESC
    CREATED_ASC
    CREATED_DESC
    DATE_ASC
    DATE_DESC
    GUIDE_ASC
    GUIDE_DESC
    ID_ASC
    ID_DESC
    LABEL_ASC
    LABEL_DESC
    LAT_ASC
    LAT_DESC
    LOCATION_ASC
    LOCATION_DESC
    LOCKED_ASC
    LOCKED_DESC
    LONG_ASC
    LONG_DESC
    NATURAL
    NIGHTS_ASC
    NIGHTS_DESC
    OWNER_ASC
    OWNER_DESC
    POSITION_ASC
    POSITION_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    STAGE_ASC
    STAGE_DESC
    UPDATED_ASC
    UPDATED_DESC
}

enum StageStatus {
    COMPLETE
    COMPUTING
    READY
    STALE
}

"Methods to use when ordering `Stage`."
enum StagesOrderBy {
    CREATED_ASC
    CREATED_DESC
    FROM_SPOT_ASC
    FROM_SPOT_DESC
    GUIDE_ASC
    GUIDE_DESC
    ID_ASC
    ID_DESC
    NATURAL
    POSITION_ASC
    POSITION_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    STATUS_ASC
    STATUS_DESC
    TO_SPOT_ASC
    TO_SPOT_DESC
    UPDATED_ASC
    UPDATED_DESC
}

"Methods to use when ordering `Temperature`."
enum TemperaturesOrderBy {
    COUNTRY_ASC
    COUNTRY_DESC
    CREATED_ASC
    CREATED_DESC
    ID_ASC
    ID_DESC
    MONTH_ASC
    MONTH_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    TEMPERATURE_ASC
    TEMPERATURE_DESC
    UPDATED_ASC
    UPDATED_DESC
}

enum TransportType {
    BICYCLE
    CAR
    MOTORCYCLE
}

"Methods to use when ordering `User`."
enum UsersOrderBy {
    COLOUR_ASC
    COLOUR_DESC
    CREATED_ASC
    CREATED_DESC
    EMAIL_ASC
    EMAIL_DESC
    NATURAL
    PASSWORD_HASH_ASC
    PASSWORD_HASH_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    UPDATED_ASC
    UPDATED_DESC
    USERNAME_ASC
    USERNAME_DESC
}

input AddSpotInput {
    country: String
    guideId: String!
    label: String
    lat: Float!
    location: String
    long: Float!
    nights: Int!
}

"All input for the `authenticate` mutation."
input AuthenticateInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    email: String!
    password: String!
}

"A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’"
input BigIntFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: BigInt
    "Equal to the specified value."
    equalTo: BigInt
    "Greater than the specified value."
    greaterThan: BigInt
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: BigInt
    "Included in the specified list."
    in: [BigInt!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: BigInt
    "Less than or equal to the specified value."
    lessThanOrEqualTo: BigInt
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: BigInt
    "Not equal to the specified value."
    notEqualTo: BigInt
    "Not included in the specified list."
    notIn: [BigInt!]
}

"A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’"
input BooleanFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: Boolean
    "Equal to the specified value."
    equalTo: Boolean
    "Greater than the specified value."
    greaterThan: Boolean
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: Boolean
    "Included in the specified list."
    in: [Boolean!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: Boolean
    "Less than or equal to the specified value."
    lessThanOrEqualTo: Boolean
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: Boolean
    "Not equal to the specified value."
    notEqualTo: Boolean
    "Not included in the specified list."
    notIn: [Boolean!]
}

"A filter to be used against Colour fields. All fields are combined with a logical ‘and.’"
input ColourFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: Colour
    "Equal to the specified value."
    equalTo: Colour
    "Greater than the specified value."
    greaterThan: Colour
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: Colour
    "Included in the specified list."
    in: [Colour!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: Colour
    "Less than or equal to the specified value."
    lessThanOrEqualTo: Colour
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: Colour
    "Not equal to the specified value."
    notEqualTo: Colour
    "Not included in the specified list."
    notIn: [Colour!]
}

"A condition to be used against `Computation` object types. All fields are tested for equality and combined with a logical ‘and.’"
input ComputationCondition {
    "Checks for equality with the object’s `created` field."
    created: Datetime
    "Checks for equality with the object’s `duration` field."
    duration: Int
    "Checks for equality with the object’s `ended` field."
    ended: Datetime
    "Checks for equality with the object’s `guide` field."
    guide: String
    "Checks for equality with the object’s `id` field."
    id: String
    "Checks for equality with the object’s `stage` field."
    stage: String
    "Checks for equality with the object’s `started` field."
    started: Datetime
    "Checks for equality with the object’s `status` field."
    status: ComputationStatus
}

"A filter to be used against `Computation` object types. All fields are combined with a logical ‘and.’"
input ComputationFilter {
    "Checks for all expressions in this list."
    and: [ComputationFilter!]
    "Filter by the object’s `created` field."
    created: DatetimeFilter
    "Filter by the object’s `duration` field."
    duration: IntFilter
    "Filter by the object’s `ended` field."
    ended: DatetimeFilter
    "Filter by the object’s `guide` field."
    guide: StringFilter
    "Filter by the object’s `id` field."
    id: StringFilter
    "Negates the expression."
    not: ComputationFilter
    "Checks for any expressions in this list."
    or: [ComputationFilter!]
    "Filter by the object’s `stage` field."
    stage: StringFilter
    "Filter by the object’s `started` field."
    started: DatetimeFilter
    "Filter by the object’s `status` field."
    status: ComputationStatusFilter
}

"A filter to be used against ComputationStatus fields. All fields are combined with a logical ‘and.’"
input ComputationStatusFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: ComputationStatus
    "Equal to the specified value."
    equalTo: ComputationStatus
    "Greater than the specified value."
    greaterThan: ComputationStatus
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: ComputationStatus
    "Included in the specified list."
    in: [ComputationStatus!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: ComputationStatus
    "Less than or equal to the specified value."
    lessThanOrEqualTo: ComputationStatus
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: ComputationStatus
    "Not equal to the specified value."
    notEqualTo: ComputationStatus
    "Not included in the specified list."
    notIn: [ComputationStatus!]
}

"All input for the create `FeedEvent` mutation."
input CreateFeedEventInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `FeedEvent` to be created by this mutation."
    feedEvent: FeedEventInput!
}

input CreateGuideInput {
    isCircular: Boolean
    maxHoursPerRide: Int!
    startDate: String
    title: String!
    type: TransportType!
}

"All input for the create `User` mutation."
input CreateUserInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `User` to be created by this mutation."
    user: UserInput!
}

"A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’"
input DatetimeFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: Datetime
    "Equal to the specified value."
    equalTo: Datetime
    "Greater than the specified value."
    greaterThan: Datetime
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: Datetime
    "Included in the specified list."
    in: [Datetime!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: Datetime
    "Less than or equal to the specified value."
    lessThanOrEqualTo: Datetime
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: Datetime
    "Not equal to the specified value."
    notEqualTo: Datetime
    "Not included in the specified list."
    notIn: [Datetime!]
}

"All input for the `deleteFeedEventByNodeId` mutation."
input DeleteFeedEventByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `FeedEvent` to be deleted."
    nodeId: ID!
}

"All input for the `deleteFeedEvent` mutation."
input DeleteFeedEventInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    timestamp: Datetime!
}

input DeleteGuideInput {
    id: String!
}

"A condition to be used against `FeedEvent` object types. All fields are tested for equality and combined with a logical ‘and.’"
input FeedEventCondition {
    "Checks for equality with the object’s `guide` field."
    guide: String
    "Checks for equality with the object’s `ride` field."
    ride: String
    "Checks for equality with the object’s `timestamp` field."
    timestamp: Datetime
    "Checks for equality with the object’s `type` field."
    type: FeedEventType
    "Checks for equality with the object’s `user` field."
    user: String
}

"A filter to be used against `FeedEvent` object types. All fields are combined with a logical ‘and.’"
input FeedEventFilter {
    "Checks for all expressions in this list."
    and: [FeedEventFilter!]
    "Filter by the object’s `guide` field."
    guide: StringFilter
    "Negates the expression."
    not: FeedEventFilter
    "Checks for any expressions in this list."
    or: [FeedEventFilter!]
    "Filter by the object’s `ride` field."
    ride: StringFilter
    "Filter by the object’s `timestamp` field."
    timestamp: DatetimeFilter
    "Filter by the object’s `type` field."
    type: FeedEventTypeFilter
    "Filter by the object’s `user` field."
    user: StringFilter
}

"An input for mutations affecting `FeedEvent`"
input FeedEventInput {
    guide: String
    ride: String
    timestamp: Datetime!
    type: FeedEventType!
    user: String
}

"Represents an update to a `FeedEvent`. Fields that are set will be updated."
input FeedEventPatch {
    guide: String
    ride: String
    timestamp: Datetime
    type: FeedEventType
    user: String
}

"A filter to be used against FeedEventType fields. All fields are combined with a logical ‘and.’"
input FeedEventTypeFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: FeedEventType
    "Equal to the specified value."
    equalTo: FeedEventType
    "Greater than the specified value."
    greaterThan: FeedEventType
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: FeedEventType
    "Included in the specified list."
    in: [FeedEventType!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: FeedEventType
    "Less than or equal to the specified value."
    lessThanOrEqualTo: FeedEventType
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: FeedEventType
    "Not equal to the specified value."
    notEqualTo: FeedEventType
    "Not included in the specified list."
    notIn: [FeedEventType!]
}

"A filter to be used against Float fields. All fields are combined with a logical ‘and.’"
input FloatFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: Float
    "Equal to the specified value."
    equalTo: Float
    "Greater than the specified value."
    greaterThan: Float
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: Float
    "Included in the specified list."
    in: [Float!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: Float
    "Less than or equal to the specified value."
    lessThanOrEqualTo: Float
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: Float
    "Not equal to the specified value."
    notEqualTo: Float
    "Not included in the specified list."
    notIn: [Float!]
}

"A condition to be used against `Follow` object types. All fields are tested for equality and combined with a logical ‘and.’"
input FollowCondition {
    "Checks for equality with the object’s `followed` field."
    followed: String
    "Checks for equality with the object’s `follower` field."
    follower: String
    "Checks for equality with the object’s `timestamp` field."
    timestamp: Datetime
}

"A filter to be used against `Follow` object types. All fields are combined with a logical ‘and.’"
input FollowFilter {
    "Checks for all expressions in this list."
    and: [FollowFilter!]
    "Filter by the object’s `followed` field."
    followed: StringFilter
    "Filter by the object’s `follower` field."
    follower: StringFilter
    "Negates the expression."
    not: FollowFilter
    "Checks for any expressions in this list."
    or: [FollowFilter!]
    "Filter by the object’s `timestamp` field."
    timestamp: DatetimeFilter
}

"A filter to be used against FollowingStatus fields. All fields are combined with a logical ‘and.’"
input FollowingStatusFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: FollowingStatus
    "Equal to the specified value."
    equalTo: FollowingStatus
    "Greater than the specified value."
    greaterThan: FollowingStatus
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: FollowingStatus
    "Included in the specified list."
    in: [FollowingStatus!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: FollowingStatus
    "Less than or equal to the specified value."
    lessThanOrEqualTo: FollowingStatus
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: FollowingStatus
    "Not equal to the specified value."
    notEqualTo: FollowingStatus
    "Not included in the specified list."
    notIn: [FollowingStatus!]
}

"A condition to be used against `Guide` object types. All fields are tested for equality and combined with a logical ‘and.’"
input GuideCondition {
    "Checks for equality with the object’s `created` field."
    created: Datetime
    "Checks for equality with the object’s `id` field."
    id: String
    "Checks for equality with the object’s `isCircular` field."
    isCircular: Boolean
    "Checks for equality with the object’s `maxHoursPerRide` field."
    maxHoursPerRide: Int
    "Checks for equality with the object’s `owner` field."
    owner: String
    "Checks for equality with the object’s `slug` field."
    slug: String
    "Checks for equality with the object’s `startDate` field."
    startDate: String
    "Checks for equality with the object’s `title` field."
    title: String
    "Checks for equality with the object’s `transportType` field."
    transportType: TransportType
    "Checks for equality with the object’s `updated` field."
    updated: Datetime
}

"A filter to be used against `Guide` object types. All fields are combined with a logical ‘and.’"
input GuideFilter {
    "Checks for all expressions in this list."
    and: [GuideFilter!]
    "Filter by the object’s `countries` field."
    countries: StringListFilter
    "Filter by the object’s `created` field."
    created: DatetimeFilter
    "Filter by the object’s `distanceMeters` field."
    distanceMeters: BigIntFilter
    "Filter by the object’s `durationSeconds` field."
    durationSeconds: BigIntFilter
    "Filter by the object’s `endDate` field."
    endDate: StringFilter
    "Filter by the object’s `id` field."
    id: StringFilter
    "Filter by the object’s `isCircular` field."
    isCircular: BooleanFilter
    "Filter by the object’s `isMine` field."
    isMine: BooleanFilter
    "Filter by the object’s `maxHoursPerRide` field."
    maxHoursPerRide: IntFilter
    "Negates the expression."
    not: GuideFilter
    "Checks for any expressions in this list."
    or: [GuideFilter!]
    "Filter by the object’s `owner` field."
    owner: StringFilter
    "Filter by the object’s `slug` field."
    slug: StringFilter
    "Filter by the object’s `startDate` field."
    startDate: StringFilter
    "Filter by the object’s `title` field."
    title: StringFilter
    "Filter by the object’s `transportType` field."
    transportType: TransportTypeFilter
    "Filter by the object’s `updated` field."
    updated: DatetimeFilter
}

"A filter to be used against Int fields. All fields are combined with a logical ‘and.’"
input IntFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: Int
    "Equal to the specified value."
    equalTo: Int
    "Greater than the specified value."
    greaterThan: Int
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: Int
    "Included in the specified list."
    in: [Int!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: Int
    "Less than or equal to the specified value."
    lessThanOrEqualTo: Int
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: Int
    "Not equal to the specified value."
    notEqualTo: Int
    "Not included in the specified list."
    notIn: [Int!]
}

"All input for the `register` mutation."
input RegisterInput {
    _email: String!
    _password: String!
    _username: String!
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
}

input RemoveSpotInput {
    id: String!
}

"A condition to be used against `Ride` object types. All fields are tested for equality and combined with a logical ‘and.’"
input RideCondition {
    "Checks for equality with the object’s `created` field."
    created: Datetime
    "Checks for equality with the object’s `date` field."
    date: String
    "Checks for equality with the object’s `distanceMeters` field."
    distanceMeters: Int
    "Checks for equality with the object’s `durationSeconds` field."
    durationSeconds: Int
    "Checks for equality with the object’s `fromSpot` field."
    fromSpot: String
    "Checks for equality with the object’s `guide` field."
    guide: String
    "Checks for equality with the object’s `id` field."
    id: String
    "Checks for equality with the object’s `owner` field."
    owner: String
    "Checks for equality with the object’s `pathUrl` field."
    pathUrl: String
    "Checks for equality with the object’s `position` field."
    position: String
    "Checks for equality with the object’s `stage` field."
    stage: String
    "Checks for equality with the object’s `status` field."
    status: RideStatus
    "Checks for equality with the object’s `toSpot` field."
    toSpot: String
    "Checks for equality with the object’s `updated` field."
    updated: Datetime
}

"A filter to be used against `Ride` object types. All fields are combined with a logical ‘and.’"
input RideFilter {
    "Checks for all expressions in this list."
    and: [RideFilter!]
    "Filter by the object’s `countries` field."
    countries: StringListFilter
    "Filter by the object’s `created` field."
    created: DatetimeFilter
    "Filter by the object’s `date` field."
    date: StringFilter
    "Filter by the object’s `distanceMeters` field."
    distanceMeters: IntFilter
    "Filter by the object’s `durationSeconds` field."
    durationSeconds: IntFilter
    "Filter by the object’s `fromSpot` field."
    fromSpot: StringFilter
    "Filter by the object’s `guide` field."
    guide: StringFilter
    "Filter by the object’s `hasBorder` field."
    hasBorder: BooleanFilter
    "Filter by the object’s `id` field."
    id: StringFilter
    "Filter by the object’s `isMine` field."
    isMine: BooleanFilter
    "Filter by the object’s `name` field."
    name: StringFilter
    "Negates the expression."
    not: RideFilter
    "Checks for any expressions in this list."
    or: [RideFilter!]
    "Filter by the object’s `owner` field."
    owner: StringFilter
    "Filter by the object’s `pathUrl` field."
    pathUrl: StringFilter
    "Filter by the object’s `position` field."
    position: StringFilter
    "Filter by the object’s `stage` field."
    stage: StringFilter
    "Filter by the object’s `status` field."
    status: RideStatusFilter
    "Filter by the object’s `toSpot` field."
    toSpot: StringFilter
    "Filter by the object’s `updated` field."
    updated: DatetimeFilter
}

"A filter to be used against RideStatus fields. All fields are combined with a logical ‘and.’"
input RideStatusFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: RideStatus
    "Equal to the specified value."
    equalTo: RideStatus
    "Greater than the specified value."
    greaterThan: RideStatus
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: RideStatus
    "Included in the specified list."
    in: [RideStatus!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: RideStatus
    "Less than or equal to the specified value."
    lessThanOrEqualTo: RideStatus
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: RideStatus
    "Not equal to the specified value."
    notEqualTo: RideStatus
    "Not included in the specified list."
    notIn: [RideStatus!]
}

"A condition to be used against `Spot` object types. All fields are tested for equality and combined with a logical ‘and.’"
input SpotCondition {
    "Checks for equality with the object’s `country` field."
    country: String
    "Checks for equality with the object’s `created` field."
    created: Datetime
    "Checks for equality with the object’s `date` field."
    date: String
    "Checks for equality with the object’s `guide` field."
    guide: String
    "Checks for equality with the object’s `id` field."
    id: String
    "Checks for equality with the object’s `label` field."
    label: String
    "Checks for equality with the object’s `lat` field."
    lat: Float
    "Checks for equality with the object’s `location` field."
    location: String
    "Checks for equality with the object’s `locked` field."
    locked: Boolean
    "Checks for equality with the object’s `long` field."
    long: Float
    "Checks for equality with the object’s `nights` field."
    nights: Int
    "Checks for equality with the object’s `owner` field."
    owner: String
    "Checks for equality with the object’s `position` field."
    position: String
    "Checks for equality with the object’s `stage` field."
    stage: String
    "Checks for equality with the object’s `updated` field."
    updated: Datetime
}

"A filter to be used against `Spot` object types. All fields are combined with a logical ‘and.’"
input SpotFilter {
    "Checks for all expressions in this list."
    and: [SpotFilter!]
    "Filter by the object’s `country` field."
    country: StringFilter
    "Filter by the object’s `created` field."
    created: DatetimeFilter
    "Filter by the object’s `date` field."
    date: StringFilter
    "Filter by the object’s `guide` field."
    guide: StringFilter
    "Filter by the object’s `id` field."
    id: StringFilter
    "Filter by the object’s `isMine` field."
    isMine: BooleanFilter
    "Filter by the object’s `label` field."
    label: StringFilter
    "Filter by the object’s `lat` field."
    lat: FloatFilter
    "Filter by the object’s `location` field."
    location: StringFilter
    "Filter by the object’s `locked` field."
    locked: BooleanFilter
    "Filter by the object’s `long` field."
    long: FloatFilter
    "Filter by the object’s `name` field."
    name: StringFilter
    "Filter by the object’s `nights` field."
    nights: IntFilter
    "Negates the expression."
    not: SpotFilter
    "Checks for any expressions in this list."
    or: [SpotFilter!]
    "Filter by the object’s `owner` field."
    owner: StringFilter
    "Filter by the object’s `position` field."
    position: StringFilter
    "Filter by the object’s `stage` field."
    stage: StringFilter
    "Filter by the object’s `temperature` field."
    temperature: FloatFilter
    "Filter by the object’s `updated` field."
    updated: DatetimeFilter
}

"A condition to be used against `Stage` object types. All fields are tested for equality and combined with a logical ‘and.’"
input StageCondition {
    "Checks for equality with the object’s `created` field."
    created: Datetime
    "Checks for equality with the object’s `fromSpot` field."
    fromSpot: String
    "Checks for equality with the object’s `guide` field."
    guide: String
    "Checks for equality with the object’s `id` field."
    id: String
    "Checks for equality with the object’s `position` field."
    position: Int
    "Checks for equality with the object’s `status` field."
    status: StageStatus
    "Checks for equality with the object’s `toSpot` field."
    toSpot: String
    "Checks for equality with the object’s `updated` field."
    updated: Datetime
}

"A filter to be used against `Stage` object types. All fields are combined with a logical ‘and.’"
input StageFilter {
    "Checks for all expressions in this list."
    and: [StageFilter!]
    "Filter by the object’s `created` field."
    created: DatetimeFilter
    "Filter by the object’s `fromSpot` field."
    fromSpot: StringFilter
    "Filter by the object’s `guide` field."
    guide: StringFilter
    "Filter by the object’s `id` field."
    id: StringFilter
    "Filter by the object’s `name` field."
    name: StringFilter
    "Negates the expression."
    not: StageFilter
    "Checks for any expressions in this list."
    or: [StageFilter!]
    "Filter by the object’s `position` field."
    position: IntFilter
    "Filter by the object’s `status` field."
    status: StageStatusFilter
    "Filter by the object’s `toSpot` field."
    toSpot: StringFilter
    "Filter by the object’s `updated` field."
    updated: DatetimeFilter
}

"A filter to be used against StageStatus fields. All fields are combined with a logical ‘and.’"
input StageStatusFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: StageStatus
    "Equal to the specified value."
    equalTo: StageStatus
    "Greater than the specified value."
    greaterThan: StageStatus
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: StageStatus
    "Included in the specified list."
    in: [StageStatus!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: StageStatus
    "Less than or equal to the specified value."
    lessThanOrEqualTo: StageStatus
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: StageStatus
    "Not equal to the specified value."
    notEqualTo: StageStatus
    "Not included in the specified list."
    notIn: [StageStatus!]
}

"A filter to be used against String fields. All fields are combined with a logical ‘and.’"
input StringFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: String
    "Ends with the specified string (case-sensitive)."
    endsWith: String
    "Ends with the specified string (case-insensitive)."
    endsWithInsensitive: String
    "Equal to the specified value."
    equalTo: String
    "Greater than the specified value."
    greaterThan: String
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: String
    "Included in the specified list."
    in: [String!]
    "Contains the specified string (case-sensitive)."
    includes: String
    "Contains the specified string (case-insensitive)."
    includesInsensitive: String
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: String
    "Less than or equal to the specified value."
    lessThanOrEqualTo: String
    "Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters."
    like: String
    "Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters."
    likeInsensitive: String
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: String
    "Does not end with the specified string (case-sensitive)."
    notEndsWith: String
    "Does not end with the specified string (case-insensitive)."
    notEndsWithInsensitive: String
    "Not equal to the specified value."
    notEqualTo: String
    "Not included in the specified list."
    notIn: [String!]
    "Does not contain the specified string (case-sensitive)."
    notIncludes: String
    "Does not contain the specified string (case-insensitive)."
    notIncludesInsensitive: String
    "Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters."
    notLike: String
    "Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters."
    notLikeInsensitive: String
    "Does not match the specified pattern using the SQL standard's definition of a regular expression."
    notSimilarTo: String
    "Does not start with the specified string (case-sensitive)."
    notStartsWith: String
    "Does not start with the specified string (case-insensitive)."
    notStartsWithInsensitive: String
    "Matches the specified pattern using the SQL standard's definition of a regular expression."
    similarTo: String
    "Starts with the specified string (case-sensitive)."
    startsWith: String
    "Starts with the specified string (case-insensitive)."
    startsWithInsensitive: String
}

"A filter to be used against String List fields. All fields are combined with a logical ‘and.’"
input StringListFilter {
    "Any array item is equal to the specified value."
    anyEqualTo: String
    "Any array item is greater than the specified value."
    anyGreaterThan: String
    "Any array item is greater than or equal to the specified value."
    anyGreaterThanOrEqualTo: String
    "Any array item is less than the specified value."
    anyLessThan: String
    "Any array item is less than or equal to the specified value."
    anyLessThanOrEqualTo: String
    "Any array item is not equal to the specified value."
    anyNotEqualTo: String
    "Contained by the specified list of values."
    containedBy: [String]
    "Contains the specified list of values."
    contains: [String]
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: [String]
    "Equal to the specified value."
    equalTo: [String]
    "Greater than the specified value."
    greaterThan: [String]
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: [String]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: [String]
    "Less than or equal to the specified value."
    lessThanOrEqualTo: [String]
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: [String]
    "Not equal to the specified value."
    notEqualTo: [String]
    "Overlaps the specified list of values."
    overlaps: [String]
}

"A condition to be used against `Temperature` object types. All fields are tested for equality and combined with a logical ‘and.’"
input TemperatureCondition {
    "Checks for equality with the object’s `country` field."
    country: String
    "Checks for equality with the object’s `created` field."
    created: Datetime
    "Checks for equality with the object’s `id` field."
    id: String
    "Checks for equality with the object’s `month` field."
    month: Int
    "Checks for equality with the object’s `temperature` field."
    temperature: Float
    "Checks for equality with the object’s `updated` field."
    updated: Datetime
}

"A filter to be used against `Temperature` object types. All fields are combined with a logical ‘and.’"
input TemperatureFilter {
    "Checks for all expressions in this list."
    and: [TemperatureFilter!]
    "Filter by the object’s `country` field."
    country: StringFilter
    "Filter by the object’s `created` field."
    created: DatetimeFilter
    "Filter by the object’s `id` field."
    id: StringFilter
    "Filter by the object’s `month` field."
    month: IntFilter
    "Negates the expression."
    not: TemperatureFilter
    "Checks for any expressions in this list."
    or: [TemperatureFilter!]
    "Filter by the object’s `temperature` field."
    temperature: FloatFilter
    "Filter by the object’s `updated` field."
    updated: DatetimeFilter
}

"A filter to be used against TransportType fields. All fields are combined with a logical ‘and.’"
input TransportTypeFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: TransportType
    "Equal to the specified value."
    equalTo: TransportType
    "Greater than the specified value."
    greaterThan: TransportType
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: TransportType
    "Included in the specified list."
    in: [TransportType!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: TransportType
    "Less than or equal to the specified value."
    lessThanOrEqualTo: TransportType
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: TransportType
    "Not equal to the specified value."
    notEqualTo: TransportType
    "Not included in the specified list."
    notIn: [TransportType!]
}

"All input for the `updateFeedEventByNodeId` mutation."
input UpdateFeedEventByNodeIdInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `FeedEvent` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `FeedEvent` being updated."
    patch: FeedEventPatch!
}

"All input for the `updateFeedEvent` mutation."
input UpdateFeedEventInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `FeedEvent` being updated."
    patch: FeedEventPatch!
    timestamp: Datetime!
}

input UpdateGuidePatch {
    id: String!
    isCircular: Boolean
    maxHoursPerRide: Int
    startDate: String
    title: String
    type: TransportType
}

input UpdateSpotLocationPatch {
    country: String
    lat: Float!
    location: String
    long: Float!
}

input UpdateSpotPatch {
    id: String!
    label: String
    location: UpdateSpotLocationPatch
    nights: Int
}

"A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’"
input UserCondition {
    "Checks for equality with the object’s `colour` field."
    colour: Colour
    "Checks for equality with the object’s `created` field."
    created: Datetime
    "Checks for equality with the object’s `email` field."
    email: String
    "Checks for equality with the object’s `passwordHash` field."
    passwordHash: String
    "Checks for equality with the object’s `updated` field."
    updated: Datetime
    "Checks for equality with the object’s `username` field."
    username: String
}

"A filter to be used against `User` object types. All fields are combined with a logical ‘and.’"
input UserFilter {
    "Checks for all expressions in this list."
    and: [UserFilter!]
    "Filter by the object’s `colour` field."
    colour: ColourFilter
    "Filter by the object’s `countries` field."
    countries: StringListFilter
    "Filter by the object’s `created` field."
    created: DatetimeFilter
    "Filter by the object’s `distanceMeters` field."
    distanceMeters: BigIntFilter
    "Filter by the object’s `durationSeconds` field."
    durationSeconds: BigIntFilter
    "Filter by the object’s `email` field."
    email: StringFilter
    "Filter by the object’s `followingStatus` field."
    followingStatus: FollowingStatusFilter
    "Negates the expression."
    not: UserFilter
    "Checks for any expressions in this list."
    or: [UserFilter!]
    "Filter by the object’s `passwordHash` field."
    passwordHash: StringFilter
    "Filter by the object’s `updated` field."
    updated: DatetimeFilter
    "Filter by the object’s `username` field."
    username: StringFilter
}

"An input for mutations affecting `User`"
input UserInput {
    colour: Colour
    created: Datetime!
    email: String!
    passwordHash: String!
    updated: Datetime
    username: String!
}


"A location in a connection that can be used for resuming pagination."
scalar Cursor

"A point in time as described by the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone."
scalar Datetime

"A signed eight-byte integer. The upper big integer values are greater than the max value for a JavaScript number. Therefore all big integers will be output as strings and not numbers."
scalar BigInt

"A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519) which securely represents claims between two parties."
scalar JwtToken