{"ast":null,"code":"\"use strict\";var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");exports.__esModule=true;exports.closePing=closePing;exports.setupPing=setupPing;exports.currentPage=void 0;var _unfetch=_interopRequireDefault(require(\"next/dist/build/polyfills/unfetch\"));var _eventsource=require(\"./error-overlay/eventsource\");var evtSource;var currentPage;exports.currentPage=currentPage;function closePing(){if(evtSource)evtSource.close();evtSource=null;}function setupPing(assetPrefix,pathnameFn,retry){var pathname=pathnameFn();if(pathname===currentPage&&!retry)return;exports.currentPage=currentPage=pathname;closePing();var url=assetPrefix+\"/_next/webpack-hmr?page=\"+currentPage;evtSource=(0,_eventsource.getEventSourceWrapper)({path:url,timeout:5000,ondemand:1});evtSource.addMessageListener(function(event){if(event.data.indexOf('{')===-1)return;try{var payload=JSON.parse(event.data);if(payload.invalid){(0,_unfetch.default)(location.href,{credentials:'same-origin'}).then(function(pageRes){if(pageRes.status===200){location.reload();}});}}catch(err){console.error('on-demand-entries failed to parse response',err);}});}","map":{"version":3,"sources":["../../../client/dev/on-demand-entries-utils.js"],"names":["evtSource","pathname","pathnameFn","closePing","url","assetPrefix","path","timeout","ondemand","event","payload","JSON","location","credentials","pageRes","console"],"mappings":"2MAEA,GAAA,CAAA,QAAA,CAAA,sBAAA,CAAA,OAAA,CAAA,mCAAA,CAAA,CAAA,CACA,GAAA,CAAA,YAAA,CAAA,OAAA,CAHA,6BAGA,CAAA,CAEA,GAAA,CAAA,SAAA,CACO,GAAA,CAAA,WAAA,C,gCAEA,QAAA,CAAA,SAAA,EAAqB,CAC1B,GAAA,SAAA,CAAeA,SAAS,CAATA,KAAAA,GACfA,SAAS,CAATA,IAAAA,CAGK,SAAA,CAAA,SAAA,CAAA,WAAA,CAAA,UAAA,CAAA,KAAA,CAAmD,CACxD,GAAMC,CAAAA,QAAQ,CAAGC,UAAjB,EAAA,CAGA,GAAID,QAAQ,GAARA,WAAAA,EAA4B,CAAhC,KAAA,CAAwC,OACxC,OAAA,CAAA,WAAA,CAAA,WAAW,CAAX,QAAA,CAEAE,SAAS,GAET,GAAMC,CAAAA,GAAG,CAAMC,WAAN,4BAAT,WAAA,CACAL,SAAS,CAAG,CAAA,EAAA,YAAA,CAAA,qBAAA,EAAsB,CAAEM,IAAI,CAAN,GAAA,CAAaC,OAAO,CAApB,IAAA,CAA4BC,QAAQ,CAAtER,CAAkC,CAAtB,CAAZA,CAEAA,SAAS,CAATA,kBAAAA,CAA8BS,SAAAA,KAAD,CAAW,CACtC,GAAIA,KAAK,CAALA,IAAAA,CAAAA,OAAAA,CAAAA,GAAAA,IAA4B,CAAhC,CAAA,CAAoC,OACpC,GAAI,CACF,GAAMC,CAAAA,OAAO,CAAGC,IAAI,CAAJA,KAAAA,CAAWF,KAAK,CAAhC,IAAgBE,CAAhB,CACA,GAAID,OAAO,CAAX,OAAA,CAAqB,CAGnB,CAAA,EAAA,QAAA,CAAA,OAAA,EAAME,QAAQ,CAAd,IAAA,CAAqB,CACnBC,WAAW,CADb,aAAqB,CAArB,EAAA,IAAA,CAESC,SAAAA,OAAD,CAAa,CACnB,GAAIA,OAAO,CAAPA,MAAAA,GAAJ,GAAA,CAA4B,CAC1BF,QAAQ,CAARA,MAAAA,GAEH,CAND,CAAA,EAQH,CAAC,OAAA,GAAA,CAAY,CACZG,OAAO,CAAPA,KAAAA,CAAAA,4CAAAA,CAAAA,GAAAA,EAEH,CAlBDf,CAAAA,EAmBD","sourcesContent":["/* global location */\n\nimport fetch from 'next/dist/build/polyfills/unfetch'\nimport { getEventSourceWrapper } from './error-overlay/eventsource'\n\nlet evtSource\nexport let currentPage\n\nexport function closePing() {\n  if (evtSource) evtSource.close()\n  evtSource = null\n}\n\nexport function setupPing(assetPrefix, pathnameFn, retry) {\n  const pathname = pathnameFn()\n\n  // Make sure to only create new EventSource request if page has changed\n  if (pathname === currentPage && !retry) return\n  currentPage = pathname\n  // close current EventSource connection\n  closePing()\n\n  const url = `${assetPrefix}/_next/webpack-hmr?page=${currentPage}`\n  evtSource = getEventSourceWrapper({ path: url, timeout: 5000, ondemand: 1 })\n\n  evtSource.addMessageListener((event) => {\n    if (event.data.indexOf('{') === -1) return\n    try {\n      const payload = JSON.parse(event.data)\n      if (payload.invalid) {\n        // Payload can be invalid even if the page does not exist.\n        // So, we need to make sure it exists before reloading.\n        fetch(location.href, {\n          credentials: 'same-origin',\n        }).then((pageRes) => {\n          if (pageRes.status === 200) {\n            location.reload()\n          }\n        })\n      }\n    } catch (err) {\n      console.error('on-demand-entries failed to parse response', err)\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}