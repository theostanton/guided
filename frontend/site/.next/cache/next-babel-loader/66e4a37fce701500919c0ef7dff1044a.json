{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/esm/initializerWarningHelper\";\n\nvar _class, _descriptor, _temp;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { action, computed, observable, runInAction } from 'mobx';\nimport { store } from 'store';\nimport client, { USER_KEY } from 'api/client';\nimport { GetUsernameDocument, LoginDocument, SignUpDocument } from 'api/generated';\nimport { Store } from '../Store';\nimport { parseCookies } from 'nookies';\nvar AuthStore = (_class = (_temp = /*#__PURE__*/function (_Store) {\n  _inherits(AuthStore, _Store);\n\n  var _super = _createSuper(AuthStore);\n\n  function AuthStore() {\n    var _this;\n\n    _classCallCheck(this, AuthStore);\n\n    _this = _super.call(this);\n\n    _initializerDefineProperty(_this, \"user\", _descriptor, _assertThisInitialized(_this));\n\n    var cookies = parseCookies();\n    var value = cookies[USER_KEY];\n\n    if (value) {\n      _this.user = JSON.parse(value);\n    }\n\n    return _this;\n  }\n\n  _createClass(AuthStore, [{\n    key: \"hydrate\",\n    value: function hydrate(initialData) {}\n  }, {\n    key: \"setUser\",\n    value: function setUser(user) {\n      var _this2 = this;\n\n      if (user) {\n        store.set(USER_KEY, JSON.stringify(user, null, 4));\n      } else {\n        store.set(USER_KEY, undefined);\n      }\n\n      runInAction(function () {\n        _this2.user = user;\n      });\n    }\n  }, {\n    key: \"login\",\n    value: function () {\n      var _login = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(email, password) {\n        var _result$data$authenti;\n\n        var variables, result, bearerToken, usernameResult, _ref, colour, username;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                variables = {\n                  email: email,\n                  password: password\n                };\n                _context.next = 3;\n                return client.mutate({\n                  mutation: LoginDocument,\n                  variables: variables\n                });\n\n              case 3:\n                result = _context.sent;\n\n                if (!(result.errors && result.errors.length > 0)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                // logError('LoginMutation error');\n                result.errors.forEach(function (error) {// logError(error.message);\n                });\n                return _context.abrupt(\"return\", {\n                  success: false,\n                  message: result.errors.map(function (error) {\n                    return error.message;\n                  }).join('\\n')\n                });\n\n              case 7:\n                if ((_result$data$authenti = result.data.authenticate) === null || _result$data$authenti === void 0 ? void 0 : _result$data$authenti.jwtToken) {\n                  _context.next = 9;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  success: false,\n                  message: 'Failed to login'\n                });\n\n              case 9:\n                bearerToken = result.data.authenticate.jwtToken;\n                this.setUser({\n                  email: email,\n                  bearerToken: bearerToken\n                });\n                _context.next = 13;\n                return client.query({\n                  query: GetUsernameDocument,\n                  variables: {\n                    email: email\n                  }\n                });\n\n              case 13:\n                usernameResult = _context.sent;\n\n                if (!(usernameResult.errors && usernameResult.errors.length > 0)) {\n                  _context.next = 18;\n                  break;\n                }\n\n                // logError('GetUsername error');\n                usernameResult.errors.forEach(function (error) {// logError(error.message);\n                });\n                this.setUser(undefined);\n                return _context.abrupt(\"return\", {\n                  success: false,\n                  message: result.errors.map(function (error) {\n                    return error.message;\n                  }).join('\\n')\n                });\n\n              case 18:\n                _ref = usernameResult.data.users.nodes[0], colour = _ref.colour, username = _ref.username;\n                this.setUser({\n                  username: username,\n                  email: email,\n                  bearerToken: bearerToken,\n                  colour: colour\n                });\n                return _context.abrupt(\"return\", {\n                  success: true\n                });\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function login(_x, _x2) {\n        return _login.apply(this, arguments);\n      }\n\n      return login;\n    }()\n  }, {\n    key: \"signUp\",\n    value: function () {\n      var _signUp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(username, email, password) {\n        var variables, result;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                variables = {\n                  username: username,\n                  email: email,\n                  password: password\n                };\n                _context2.next = 3;\n                return client.mutate({\n                  mutation: SignUpDocument,\n                  variables: variables\n                });\n\n              case 3:\n                result = _context2.sent;\n\n                if (!(result.errors && result.errors.length > 0)) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  success: false,\n                  message: result.errors.map(function (error) {\n                    return error.message;\n                  }).join('\\n')\n                });\n\n              case 6:\n                return _context2.abrupt(\"return\", this.login(email, password));\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function signUp(_x3, _x4, _x5) {\n        return _signUp.apply(this, arguments);\n      }\n\n      return signUp;\n    }()\n  }, {\n    key: \"logOut\",\n    value: function logOut() {\n      this.setUser(undefined);\n    }\n  }, {\n    key: \"isLoggedIn\",\n    get: function get() {\n      return this.user !== undefined;\n    }\n  }]);\n\n  return AuthStore;\n}(Store), _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"user\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _applyDecoratedDescriptor(_class.prototype, \"isLoggedIn\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"isLoggedIn\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"logOut\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"logOut\"), _class.prototype)), _class);\nexport { AuthStore as default };\n\nfunction initialise() {}\n\nvar authStore = new AuthStore();\nexport { authStore };","map":{"version":3,"sources":["/Users/theo/Code/guided/frontend/site/src/stores/AuthStore/index.ts"],"names":["action","computed","observable","runInAction","store","client","USER_KEY","GetUsernameDocument","LoginDocument","SignUpDocument","Store","parseCookies","AuthStore","cookies","value","user","JSON","parse","initialData","set","stringify","undefined","email","password","variables","mutate","mutation","result","errors","length","forEach","error","success","message","map","join","data","authenticate","jwtToken","bearerToken","setUser","query","usernameResult","users","nodes","colour","username","login","initialise","authStore"],"mappings":"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","sourcesContent":["import {action, computed, observable, runInAction} from 'mobx';\nimport {store} from 'store';\nimport client, {USER_KEY} from 'api/client';\nimport {\n  GetUsernameDocument,\n  GetUsernameQuery,\n  GetUsernameQueryVariables,\n  LoginDocument,\n  LoginMutation,\n  LoginMutationVariables,\n  SignUpDocument,\n  SignUpMutation,\n  SignUpMutationVariables,\n} from 'api/generated';\nimport {Store} from '../Store';\nimport {parseCookies} from 'nookies';\n\nexport type User = {\n  bearerToken: string;\n  username?: string;\n  email: string;\n};\n\nexport default class AuthStore extends Store<User> {\n  @observable\n  user: User | undefined;\n\n  constructor() {\n    super();\n    const cookies = parseCookies();\n    const value = cookies[USER_KEY];\n    if (value) {\n      this.user = JSON.parse(value) as User;\n    }\n  }\n\n  hydrate(initialData: User | undefined) {}\n\n  @computed\n  get isLoggedIn(): boolean {\n    return this.user !== undefined;\n  }\n\n  setUser(user: User | undefined) {\n    if (user) {\n      store.set(USER_KEY, JSON.stringify(user, null, 4));\n    } else {\n      store.set(USER_KEY, undefined);\n    }\n    runInAction(() => {\n      this.user = user;\n    });\n  }\n\n  async login(\n    email: string,\n    password: string,\n  ): Promise<{\n    success: boolean;\n    message?: string;\n  }> {\n    const variables: LoginMutationVariables = {\n      email,\n      password,\n    };\n    const result = await client.mutate<LoginMutation>({\n      mutation: LoginDocument,\n      variables,\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      // logError('LoginMutation error');\n      result.errors.forEach((error) => {\n        // logError(error.message);\n      });\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    if (!result.data.authenticate?.jwtToken) {\n      return {\n        success: false,\n        message: 'Failed to login',\n      };\n    }\n\n    const bearerToken = result.data!.authenticate!.jwtToken;\n\n    this.setUser({\n      email,\n      bearerToken,\n    });\n\n    const usernameResult = await client.query<GetUsernameQuery>({\n      query: GetUsernameDocument,\n      variables: {\n        email,\n      } as GetUsernameQueryVariables,\n    });\n\n    if (usernameResult.errors && usernameResult.errors.length > 0) {\n      // logError('GetUsername error');\n      usernameResult.errors.forEach((error) => {\n        // logError(error.message);\n      });\n\n      this.setUser(undefined);\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    const {colour, username} = usernameResult.data!.users!.nodes[0]!;\n\n    this.setUser({\n      username,\n      email,\n      bearerToken,\n      colour,\n    });\n\n    return {\n      success: true,\n    };\n  }\n\n  async signUp(\n    username: string,\n    email: string,\n    password: string,\n  ): Promise<{success: boolean; message?: string}> {\n    const variables: SignUpMutationVariables = {\n      username,\n      email,\n      password,\n    };\n    const result = await client.mutate<SignUpMutation>({\n      mutation: SignUpDocument,\n      variables,\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    return this.login(email, password);\n  }\n\n  @action\n  logOut() {\n    this.setUser(undefined);\n  }\n}\n\nfunction initialise() {}\n\nconst authStore = new AuthStore();\n\nexport {authStore};\n"]},"metadata":{},"sourceType":"module"}