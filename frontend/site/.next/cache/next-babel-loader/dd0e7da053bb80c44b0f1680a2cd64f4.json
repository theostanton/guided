{"ast":null,"code":"var _class, _descriptor, _temp;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\nimport { action, computed, observable } from 'mobx';\nimport client, { USER_KEY } from 'api/client';\nimport * as cookies from 'utils/cookies';\nimport { GetUsernameDocument, LoginDocument, SignUpDocument } from 'api/generated';\nimport { Store } from 'stores/Store';\nlet AuthStore = (_class = (_temp = class AuthStore extends Store {\n  constructor() {\n    super();\n\n    _initializerDefineProperty(this, \"user\", _descriptor, this);\n\n    const exists = cookies.exists(USER_KEY);\n    console.log('exists', exists);\n\n    if (exists) {\n      this.user = JSON.parse(cookies.get(USER_KEY));\n      console.log('this.user', this.user);\n    }\n  }\n\n  hydrate(initialData) {}\n\n  get isLoggedIn() {\n    return this.user !== undefined;\n  }\n\n  setUser(user) {\n    if (user) {\n      cookies.set(USER_KEY, JSON.stringify(user, null, 4));\n    } else {\n      cookies.destroy(USER_KEY);\n    }\n\n    this.user = user;\n  }\n\n  async login(email, password) {\n    var _result$data$authenti;\n\n    const variables = {\n      email,\n      password\n    };\n    const result = await client.mutate({\n      mutation: LoginDocument,\n      variables\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      // logError('LoginMutation error');\n      result.errors.forEach(error => {// logError(error.message);\n      });\n      return {\n        success: false,\n        message: result.errors.map(error => {\n          return error.message;\n        }).join('\\n')\n      };\n    }\n\n    if (!((_result$data$authenti = result.data.authenticate) === null || _result$data$authenti === void 0 ? void 0 : _result$data$authenti.jwtToken)) {\n      return {\n        success: false,\n        message: 'Failed to login'\n      };\n    }\n\n    const bearerToken = result.data.authenticate.jwtToken;\n    this.setUser({\n      email,\n      bearerToken\n    });\n    const usernameResult = await client.query({\n      query: GetUsernameDocument,\n      variables: {\n        email\n      }\n    });\n\n    if (usernameResult.errors && usernameResult.errors.length > 0) {\n      // logError('GetUsername error');\n      usernameResult.errors.forEach(error => {// logError(error.message);\n      });\n      this.setUser(undefined);\n      return {\n        success: false,\n        message: result.errors.map(error => {\n          return error.message;\n        }).join('\\n')\n      };\n    }\n\n    const {\n      colour,\n      username\n    } = usernameResult.data.users.nodes[0];\n    this.setUser({\n      username,\n      email,\n      bearerToken\n    });\n    return {\n      success: true\n    };\n  }\n\n  async signUp(username, email, password) {\n    const variables = {\n      username,\n      email,\n      password\n    };\n    const result = await client.mutate({\n      mutation: SignUpDocument,\n      variables\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      return {\n        success: false,\n        message: result.errors.map(error => {\n          return error.message;\n        }).join('\\n')\n      };\n    }\n\n    return this.login(email, password);\n  }\n\n  logOut() {\n    this.setUser(undefined);\n  }\n\n}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"user\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _applyDecoratedDescriptor(_class.prototype, \"isLoggedIn\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"isLoggedIn\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"setUser\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"setUser\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"logOut\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"logOut\"), _class.prototype)), _class);\nexport { AuthStore as default };\nconst authStore = new AuthStore();\nexport { authStore };","map":{"version":3,"sources":["/Users/theo/Code/guided/frontend/site/src/stores/AuthStore/index.ts"],"names":["action","computed","observable","client","USER_KEY","cookies","GetUsernameDocument","LoginDocument","SignUpDocument","Store","AuthStore","constructor","exists","console","log","user","JSON","parse","get","hydrate","initialData","isLoggedIn","undefined","setUser","set","stringify","destroy","login","email","password","variables","result","mutate","mutation","errors","length","forEach","error","success","message","map","join","data","authenticate","jwtToken","bearerToken","usernameResult","query","colour","username","users","nodes","signUp","logOut","authStore"],"mappings":"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","sourcesContent":["import {action, computed, observable, runInAction} from 'mobx';\nimport client, {USER_KEY} from 'api/client';\nimport * as cookies from 'utils/cookies';\nimport {\n  GetUsernameDocument,\n  GetUsernameQuery,\n  GetUsernameQueryVariables,\n  LoginDocument,\n  LoginMutation,\n  LoginMutationVariables,\n  SignUpDocument,\n  SignUpMutation,\n  SignUpMutationVariables,\n} from 'api/generated';\nimport {Store} from 'stores/Store';\n\nexport type User = {\n  bearerToken: string;\n  username?: string;\n  email: string;\n};\n\nexport default class AuthStore extends Store<User> {\n  @observable\n  user: User | undefined;\n\n  constructor() {\n    super();\n    const exists = cookies.exists(USER_KEY);\n    console.log('exists', exists);\n    if (exists) {\n      this.user = JSON.parse(cookies.get(USER_KEY)) as User;\n      console.log('this.user', this.user);\n    }\n  }\n\n  hydrate(initialData: User | undefined) {}\n\n  @computed\n  get isLoggedIn(): boolean {\n    return this.user !== undefined;\n  }\n\n  @action\n  setUser(user: User | undefined) {\n    if (user) {\n      cookies.set(USER_KEY, JSON.stringify(user, null, 4));\n    } else {\n      cookies.destroy(USER_KEY);\n    }\n    this.user = user;\n  }\n\n  async login(\n    email: string,\n    password: string,\n  ): Promise<{\n    success: boolean;\n    message?: string;\n  }> {\n    const variables: LoginMutationVariables = {\n      email,\n      password,\n    };\n    const result = await client.mutate<LoginMutation>({\n      mutation: LoginDocument,\n      variables,\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      // logError('LoginMutation error');\n      result.errors.forEach((error) => {\n        // logError(error.message);\n      });\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    if (!result.data.authenticate?.jwtToken) {\n      return {\n        success: false,\n        message: 'Failed to login',\n      };\n    }\n\n    const bearerToken = result.data!.authenticate!.jwtToken;\n\n    this.setUser({\n      email,\n      bearerToken,\n    });\n\n    const usernameResult = await client.query<GetUsernameQuery>({\n      query: GetUsernameDocument,\n      variables: {\n        email,\n      } as GetUsernameQueryVariables,\n    });\n\n    if (usernameResult.errors && usernameResult.errors.length > 0) {\n      // logError('GetUsername error');\n      usernameResult.errors.forEach((error) => {\n        // logError(error.message);\n      });\n\n      this.setUser(undefined);\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    const {colour, username} = usernameResult.data!.users!.nodes[0]!;\n\n    this.setUser({\n      username,\n      email,\n      bearerToken,\n    });\n\n    return {\n      success: true,\n    };\n  }\n\n  async signUp(\n    username: string,\n    email: string,\n    password: string,\n  ): Promise<{success: boolean; message?: string}> {\n    const variables: SignUpMutationVariables = {\n      username,\n      email,\n      password,\n    };\n    const result = await client.mutate<SignUpMutation>({\n      mutation: SignUpDocument,\n      variables,\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    return this.login(email, password);\n  }\n\n  @action\n  logOut() {\n    this.setUser(undefined);\n  }\n}\n\nconst authStore = new AuthStore();\n\nexport {authStore};\n"]},"metadata":{},"sourceType":"module"}