{"ast":null,"code":"import _initializerDefineProperty from \"@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/esm/initializerWarningHelper\";\n\nvar _class, _descriptor, _temp;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { action, computed, observable } from 'mobx';\nimport client, { USER_KEY } from 'api/client';\nimport * as storage from 'utils/storage';\nimport { GetUsernameDocument, LoginDocument, SignUpDocument } from 'api/generated';\nimport { Store } from 'stores/Store';\nvar AuthStore = (_class = (_temp = /*#__PURE__*/function (_Store) {\n  _inherits(AuthStore, _Store);\n\n  var _super = _createSuper(AuthStore);\n\n  _createClass(AuthStore, null, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var exists, user;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return storage.exists(USER_KEY);\n\n              case 3:\n                exists = _context.sent;\n\n                if (!(exists === true)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.next = 7;\n                return storage.getObject(USER_KEY);\n\n              case 7:\n                user = _context.sent;\n                return _context.abrupt(\"return\", new AuthStore(user));\n\n              case 9:\n                _context.next = 14;\n                break;\n\n              case 11:\n                _context.prev = 11;\n                _context.t0 = _context[\"catch\"](0);\n                console.error(_context.t0);\n\n              case 14:\n                return _context.abrupt(\"return\", new AuthStore(undefined));\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[0, 11]]);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }]);\n\n  function AuthStore(user) {\n    var _this;\n\n    _classCallCheck(this, AuthStore);\n\n    _this = _super.call(this);\n\n    _initializerDefineProperty(_this, \"user\", _descriptor, _assertThisInitialized(_this));\n\n    _this.user = user;\n    return _this;\n  }\n\n  _createClass(AuthStore, [{\n    key: \"hydrate\",\n    value: function hydrate(initialData) {}\n  }, {\n    key: \"setUser\",\n    value: function setUser(user) {\n      if (user) {\n        storage.setObject(USER_KEY, user);\n      } else {\n        storage.remove(USER_KEY);\n      }\n\n      this.user = user;\n    }\n  }, {\n    key: \"login\",\n    value: function () {\n      var _login = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(email, password) {\n        var _result$data$authenti;\n\n        var variables, result, bearerToken, usernameResult, _ref, colour, username;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                variables = {\n                  email: email,\n                  password: password\n                };\n                _context2.next = 3;\n                return client.mutate({\n                  mutation: LoginDocument,\n                  variables: variables\n                });\n\n              case 3:\n                result = _context2.sent;\n\n                if (!(result.errors && result.errors.length > 0)) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                // logError('LoginMutation error');\n                result.errors.forEach(function (error) {// logError(error.message);\n                });\n                return _context2.abrupt(\"return\", {\n                  success: false,\n                  message: result.errors.map(function (error) {\n                    return error.message;\n                  }).join('\\n')\n                });\n\n              case 7:\n                if ((_result$data$authenti = result.data.authenticate) === null || _result$data$authenti === void 0 ? void 0 : _result$data$authenti.jwtToken) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  success: false,\n                  message: 'Failed to login'\n                });\n\n              case 9:\n                bearerToken = result.data.authenticate.jwtToken;\n                this.setUser({\n                  email: email,\n                  bearerToken: bearerToken\n                });\n                _context2.next = 13;\n                return client.query({\n                  query: GetUsernameDocument,\n                  variables: {\n                    email: email\n                  }\n                });\n\n              case 13:\n                usernameResult = _context2.sent;\n\n                if (!(usernameResult.errors && usernameResult.errors.length > 0)) {\n                  _context2.next = 18;\n                  break;\n                }\n\n                usernameResult.errors.forEach(function (error) {});\n                this.setUser(undefined);\n                return _context2.abrupt(\"return\", {\n                  success: false,\n                  message: result.errors.map(function (error) {\n                    return error.message;\n                  }).join('\\n')\n                });\n\n              case 18:\n                _ref = usernameResult.data.users.nodes[0], colour = _ref.colour, username = _ref.username;\n                this.setUser({\n                  username: username,\n                  email: email,\n                  bearerToken: bearerToken\n                });\n                return _context2.abrupt(\"return\", {\n                  success: true\n                });\n\n              case 21:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function login(_x, _x2) {\n        return _login.apply(this, arguments);\n      }\n\n      return login;\n    }()\n  }, {\n    key: \"signUp\",\n    value: function () {\n      var _signUp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(username, email, password) {\n        var variables, result;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                variables = {\n                  username: username,\n                  email: email,\n                  password: password\n                };\n                _context3.next = 3;\n                return client.mutate({\n                  mutation: SignUpDocument,\n                  variables: variables\n                });\n\n              case 3:\n                result = _context3.sent;\n\n                if (!(result.errors && result.errors.length > 0)) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", {\n                  success: false,\n                  message: result.errors.map(function (error) {\n                    return error.message;\n                  }).join('\\n')\n                });\n\n              case 6:\n                return _context3.abrupt(\"return\", this.login(email, password));\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function signUp(_x3, _x4, _x5) {\n        return _signUp.apply(this, arguments);\n      }\n\n      return signUp;\n    }()\n  }, {\n    key: \"logOut\",\n    value: function logOut() {\n      this.setUser(undefined);\n      console.log('logOUt this.user=', this.user);\n    }\n  }, {\n    key: \"isLoggedIn\",\n    get: function get() {\n      return this.user !== undefined;\n    }\n  }]);\n\n  return AuthStore;\n}(Store), _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"user\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _applyDecoratedDescriptor(_class.prototype, \"isLoggedIn\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"isLoggedIn\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"setUser\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"setUser\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"logOut\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"logOut\"), _class.prototype)), _class);\nexport { AuthStore as default };","map":{"version":3,"sources":["/Users/theo/Code/guided/frontend/site/src/stores/AuthStore/index.ts"],"names":["action","computed","observable","client","USER_KEY","storage","GetUsernameDocument","LoginDocument","SignUpDocument","Store","AuthStore","exists","getObject","user","console","error","undefined","initialData","setObject","remove","email","password","variables","mutate","mutation","result","errors","length","forEach","success","message","map","join","data","authenticate","jwtToken","bearerToken","setUser","query","usernameResult","users","nodes","colour","username","login","log"],"mappings":"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","sourcesContent":["import {action, computed, observable} from 'mobx';\nimport client, {USER_KEY} from 'api/client';\nimport * as storage from 'utils/storage';\nimport {\n  GetUsernameDocument,\n  GetUsernameQuery,\n  GetUsernameQueryVariables,\n  LoginDocument,\n  LoginMutation,\n  LoginMutationVariables,\n  SignUpDocument,\n  SignUpMutation,\n  SignUpMutationVariables,\n} from 'api/generated';\nimport {Store} from 'stores/Store';\n\nexport type User = {\n  bearerToken: string;\n  username?: string;\n  email: string;\n};\n\nexport default class AuthStore extends Store<User> {\n  static async init(): Promise<AuthStore> {\n    try {\n      const exists = await storage.exists(USER_KEY);\n      if (exists === true) {\n        const user = await storage.getObject<User>(USER_KEY);\n        return new AuthStore(user);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    return new AuthStore(undefined);\n  }\n\n  @observable\n  user: User | undefined;\n\n  constructor(user: User | undefined) {\n    super();\n    this.user = user;\n  }\n\n  hydrate(initialData: User | undefined) {}\n\n  @computed\n  get isLoggedIn(): boolean {\n    return this.user !== undefined;\n  }\n\n  @action\n  setUser(user: User | undefined) {\n    if (user) {\n      storage.setObject(USER_KEY, user);\n    } else {\n      storage.remove(USER_KEY);\n    }\n    this.user = user;\n  }\n\n  async login(\n    email: string,\n    password: string,\n  ): Promise<{\n    success: boolean;\n    message?: string;\n  }> {\n    const variables: LoginMutationVariables = {\n      email,\n      password,\n    };\n    const result = await client.mutate<LoginMutation>({\n      mutation: LoginDocument,\n      variables,\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      // logError('LoginMutation error');\n      result.errors.forEach((error) => {\n        // logError(error.message);\n      });\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    if (!result.data.authenticate?.jwtToken) {\n      return {\n        success: false,\n        message: 'Failed to login',\n      };\n    }\n\n    const bearerToken = result.data!.authenticate!.jwtToken;\n\n    this.setUser({\n      email,\n      bearerToken,\n    });\n\n    const usernameResult = await client.query<GetUsernameQuery>({\n      query: GetUsernameDocument,\n      variables: {\n        email,\n      } as GetUsernameQueryVariables,\n    });\n\n    if (usernameResult.errors && usernameResult.errors.length > 0) {\n      usernameResult.errors.forEach((error) => {});\n\n      this.setUser(undefined);\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    const {colour, username} = usernameResult.data!.users!.nodes[0]!;\n\n    this.setUser({\n      username,\n      email,\n      bearerToken,\n    });\n\n    return {\n      success: true,\n    };\n  }\n\n  async signUp(\n    username: string,\n    email: string,\n    password: string,\n  ): Promise<{success: boolean; message?: string}> {\n    const variables: SignUpMutationVariables = {\n      username,\n      email,\n      password,\n    };\n    const result = await client.mutate<SignUpMutation>({\n      mutation: SignUpDocument,\n      variables,\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    return this.login(email, password);\n  }\n\n  @action\n  logOut() {\n    this.setUser(undefined);\n    console.log('logOUt this.user=', this.user);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}