{"ast":null,"code":"\"use strict\";exports.__esModule=true;exports.getRouteRegex=getRouteRegex;function escapeRegex(str){return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g,'\\\\$&');}function getRouteRegex(normalizedRoute){var escapedRoute=escapeRegex(normalizedRoute.replace(/\\/$/,'')||'/');var groups={};var groupIndex=1;var parameterizedRoute=escapedRoute.replace(/\\/\\\\\\[([^/]+?)\\\\\\](?=\\/|$)/g,function(_,$1){var isOptional=/^\\\\\\[.*\\\\\\]$/.test($1);if(isOptional){$1=$1.slice(2,-2);}var isCatchAll=/^(\\\\\\.){3}/.test($1);if(isCatchAll){$1=$1.slice(6);}groups[$1.replace(/\\\\([|\\\\{}()[\\]^$+*?.-])/g,'$1')]={pos:groupIndex++,repeat:isCatchAll};return isCatchAll?isOptional?'(?:/(.+?))?':'/(.+?)':'/([^/]+?)';});var namedParameterizedRoute;if(false){namedParameterizedRoute=escapedRoute.replace(/\\/\\\\\\[([^/]+?)\\\\\\](?=\\/|$)/g,function(_,$1){var isCatchAll=/^(\\\\\\.){3}/.test($1);var key=$1.replace(/\\\\([|\\\\{}()[\\]^$+*?.-])/g,'$1').replace(/^\\.{3}/,'');return isCatchAll?\"/(?<\"+escapeRegex(key)+\">.+?)\":\"/(?<\"+escapeRegex(key)+\">[^/]+?)\";});}return{re:new RegExp('^'+parameterizedRoute+'(?:/)?$','i'),groups:groups,namedRegex:namedParameterizedRoute?\"^\"+namedParameterizedRoute+\"(?:/)?$\":undefined};}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/route-regex.ts"],"names":["str","escapedRoute","escapeRegex","normalizedRoute","groups","groupIndex","parameterizedRoute","isOptional","$1","isCatchAll","pos","repeat","namedParameterizedRoute","key","re","namedRegex"],"mappings":"2DAAA,a,CAEA,QAAA,CAAA,WAAA,CAAA,GAAA,CAAkC,CAChC,MAAOA,CAAAA,GAAG,CAAHA,OAAAA,CAAAA,sBAAAA,CAAP,MAAOA,CAAP,CAGK,SAAA,CAAA,aAAA,CAAA,eAAA,CAML,CAEA,GAAMC,CAAAA,YAAY,CAAGC,WAAW,CAACC,eAAe,CAAfA,OAAAA,CAAAA,KAAAA,CAAAA,EAAAA,GAAjC,GAAgC,CAAhC,CAEA,GAAMC,CAAAA,MAAiE,CAAvE,EAAA,CACA,GAAIC,CAAAA,UAAU,CAAd,CAAA,CAEA,GAAMC,CAAAA,kBAAkB,CAAG,YAAY,CAAZ,OAAA,CAAA,6BAAA,CAEzB,SAAA,CAAA,CAAA,EAAA,CAAW,CACT,GAAMC,CAAAA,UAAU,CAAG,eAAA,IAAA,CAAnB,EAAmB,CAAnB,CACA,GAAA,UAAA,CAAgB,CACdC,EAAE,CAAGA,EAAE,CAAFA,KAAAA,CAAAA,CAAAA,CAAY,CAAjBA,CAAKA,CAALA,CAEF,IAAMC,CAAAA,UAAU,CAAG,aAAA,IAAA,CAAnB,EAAmB,CAAnB,CACA,GAAA,UAAA,CAAgB,CACdD,EAAE,CAAGA,EAAE,CAAFA,KAAAA,CAALA,CAAKA,CAALA,CAEF,CAAA,MAAM,CACJ,EACE,CADF,OAAA,CAAA,0BAAA,CAAA,IAAA,CADI,CAAN,CAKI,CAAEE,GAAG,CAAEL,UAAP,EAAA,CAAqBM,MAAM,CAL/B,UAKI,CALJ,CAMA,MAAOF,CAAAA,UAAU,CAAIF,UAAU,CAAA,aAAA,CAAd,QAAA,CAAjB,WAAA,CAjBJ,CAA2B,CAA3B,CAqBA,GAAA,CAAA,uBAAA,CAIA,SAAmC,CACjCK,uBAAuB,CAAGX,YAAY,CAAZA,OAAAA,CAAAA,6BAAAA,CAExB,SAAA,CAAA,CAAA,EAAA,CAAW,CACT,GAAMQ,CAAAA,UAAU,CAAG,aAAA,IAAA,CAAnB,EAAmB,CAAnB,CACA,GAAMI,CAAAA,GAAG,CAAG,EACV,CADU,OAAA,CAAA,0BAAA,CAAA,IAAA,EAAA,OAAA,CAAA,QAAA,CAAZ,EAAY,CAAZ,CAKA,MAAOJ,CAAAA,UAAU,QACNP,WAAW,CADL,GACK,CADL,gBAENA,WAAW,CAFtB,GAEsB,CAFL,WAAjB,CATJU,CAA0BX,CAA1BW,CAgBF,OAAO,CACLE,EAAE,CAAE,GAAA,CAAA,MAAA,CAAW,IAAA,kBAAA,CAAX,SAAA,CADC,GACD,CADC,CAELV,MAFK,CAELA,MAFK,CAGLW,UAAU,CAAEH,uBAAuB,KAAA,uBAAA,WAHrC,SAAO,CAAP,CAOD","sourcesContent":["// this isn't importing the escape-string-regex module\n// to reduce bytes\nfunction escapeRegex(str: string) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&')\n}\n\nexport function getRouteRegex(\n  normalizedRoute: string\n): {\n  re: RegExp\n  namedRegex?: string\n  groups: { [groupName: string]: { pos: number; repeat: boolean } }\n} {\n  // Escape all characters that could be considered RegEx\n  const escapedRoute = escapeRegex(normalizedRoute.replace(/\\/$/, '') || '/')\n\n  const groups: { [groupName: string]: { pos: number; repeat: boolean } } = {}\n  let groupIndex = 1\n\n  const parameterizedRoute = escapedRoute.replace(\n    /\\/\\\\\\[([^/]+?)\\\\\\](?=\\/|$)/g,\n    (_, $1) => {\n      const isOptional = /^\\\\\\[.*\\\\\\]$/.test($1)\n      if (isOptional) {\n        $1 = $1.slice(2, -2)\n      }\n      const isCatchAll = /^(\\\\\\.){3}/.test($1)\n      if (isCatchAll) {\n        $1 = $1.slice(6)\n      }\n      groups[\n        $1\n          // Un-escape key\n          .replace(/\\\\([|\\\\{}()[\\]^$+*?.-])/g, '$1')\n        // eslint-disable-next-line no-sequences\n      ] = { pos: groupIndex++, repeat: isCatchAll }\n      return isCatchAll ? (isOptional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'\n    }\n  )\n\n  let namedParameterizedRoute: string | undefined\n\n  // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n  if (typeof window === 'undefined') {\n    namedParameterizedRoute = escapedRoute.replace(\n      /\\/\\\\\\[([^/]+?)\\\\\\](?=\\/|$)/g,\n      (_, $1) => {\n        const isCatchAll = /^(\\\\\\.){3}/.test($1)\n        const key = $1\n          // Un-escape key\n          .replace(/\\\\([|\\\\{}()[\\]^$+*?.-])/g, '$1')\n          .replace(/^\\.{3}/, '')\n\n        return isCatchAll\n          ? `/(?<${escapeRegex(key)}>.+?)`\n          : `/(?<${escapeRegex(key)}>[^/]+?)`\n      }\n    )\n  }\n\n  return {\n    re: new RegExp('^' + parameterizedRoute + '(?:/)?$', 'i'),\n    groups,\n    namedRegex: namedParameterizedRoute\n      ? `^${namedParameterizedRoute}(?:/)?$`\n      : undefined,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}