{"ast":null,"code":"var _class, _descriptor, _temp;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\nimport { action, computed, observable, runInAction } from 'mobx';\nimport client, { USER_KEY } from 'api/client';\nimport { GetUsernameDocument, LoginDocument, SignUpDocument } from 'api/generated';\nimport { Store } from 'stores/Store';\nimport { destroyCookie, parseCookies, setCookie } from 'nookies';\nlet AuthStore = (_class = (_temp = class AuthStore extends Store {\n  constructor() {\n    super();\n\n    _initializerDefineProperty(this, \"user\", _descriptor, this);\n\n    const cookies = parseCookies();\n    const value = cookies[USER_KEY];\n\n    if (value) {\n      this.user = JSON.parse(value);\n    }\n  }\n\n  hydrate(initialData) {}\n\n  get isLoggedIn() {\n    return this.user !== undefined;\n  }\n\n  setUser(user) {\n    if (user) {\n      setCookie(null, USER_KEY, JSON.stringify(user, null, 4), {\n        maxAge: 30 * 24 * 60 * 60,\n        path: '/'\n      });\n    } else {\n      destroyCookie(null, USER_KEY);\n    }\n\n    runInAction(() => {\n      this.user = user;\n    });\n  }\n\n  async login(email, password) {\n    var _result$data$authenti;\n\n    const variables = {\n      email,\n      password\n    };\n    const result = await client.mutate({\n      mutation: LoginDocument,\n      variables\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      // logError('LoginMutation error');\n      result.errors.forEach(error => {// logError(error.message);\n      });\n      return {\n        success: false,\n        message: result.errors.map(error => {\n          return error.message;\n        }).join('\\n')\n      };\n    }\n\n    if (!((_result$data$authenti = result.data.authenticate) === null || _result$data$authenti === void 0 ? void 0 : _result$data$authenti.jwtToken)) {\n      return {\n        success: false,\n        message: 'Failed to login'\n      };\n    }\n\n    const bearerToken = result.data.authenticate.jwtToken;\n    this.setUser({\n      email,\n      bearerToken\n    });\n    const usernameResult = await client.query({\n      query: GetUsernameDocument,\n      variables: {\n        email\n      }\n    });\n\n    if (usernameResult.errors && usernameResult.errors.length > 0) {\n      // logError('GetUsername error');\n      usernameResult.errors.forEach(error => {// logError(error.message);\n      });\n      this.setUser(undefined);\n      return {\n        success: false,\n        message: result.errors.map(error => {\n          return error.message;\n        }).join('\\n')\n      };\n    }\n\n    const {\n      colour,\n      username\n    } = usernameResult.data.users.nodes[0];\n    this.setUser({\n      username,\n      email,\n      bearerToken,\n      colour\n    });\n    return {\n      success: true\n    };\n  }\n\n  async signUp(username, email, password) {\n    const variables = {\n      username,\n      email,\n      password\n    };\n    const result = await client.mutate({\n      mutation: SignUpDocument,\n      variables\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      return {\n        success: false,\n        message: result.errors.map(error => {\n          return error.message;\n        }).join('\\n')\n      };\n    }\n\n    return this.login(email, password);\n  }\n\n  logOut() {\n    this.setUser(undefined);\n  }\n\n}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"user\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _applyDecoratedDescriptor(_class.prototype, \"isLoggedIn\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"isLoggedIn\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"logOut\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"logOut\"), _class.prototype)), _class);\nexport { AuthStore as default };\nconst authStore = new AuthStore();\nexport { authStore };","map":{"version":3,"sources":["/Users/theo/Code/guided/frontend/site/src/stores/AuthStore/index.ts"],"names":["action","computed","observable","runInAction","client","USER_KEY","GetUsernameDocument","LoginDocument","SignUpDocument","Store","destroyCookie","parseCookies","setCookie","AuthStore","constructor","cookies","value","user","JSON","parse","hydrate","initialData","isLoggedIn","undefined","setUser","stringify","maxAge","path","login","email","password","variables","result","mutate","mutation","errors","length","forEach","error","success","message","map","join","data","authenticate","jwtToken","bearerToken","usernameResult","query","colour","username","users","nodes","signUp","logOut","authStore"],"mappings":"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","sourcesContent":["import {action, computed, observable, runInAction} from 'mobx';\nimport client, {USER_KEY} from 'api/client';\nimport {\n  GetUsernameDocument,\n  GetUsernameQuery,\n  GetUsernameQueryVariables,\n  LoginDocument,\n  LoginMutation,\n  LoginMutationVariables,\n  SignUpDocument,\n  SignUpMutation,\n  SignUpMutationVariables,\n} from 'api/generated';\nimport {Store} from 'stores/Store';\nimport {destroyCookie, parseCookies, setCookie} from 'nookies';\n\nexport type User = {\n  bearerToken: string;\n  username?: string;\n  email: string;\n};\n\nexport default class AuthStore extends Store<User> {\n  @observable\n  user: User | undefined;\n\n  constructor() {\n    super();\n    const cookies = parseCookies();\n    const value = cookies[USER_KEY];\n    if (value) {\n      this.user = JSON.parse(value) as User;\n    }\n  }\n\n  hydrate(initialData: User | undefined) {}\n\n  @computed\n  get isLoggedIn(): boolean {\n    return this.user !== undefined;\n  }\n\n  setUser(user: User | undefined) {\n    if (user) {\n      setCookie(null, USER_KEY, JSON.stringify(user, null, 4), {\n        maxAge: 30 * 24 * 60 * 60,\n        path: '/',\n      });\n    } else {\n      destroyCookie(null, USER_KEY);\n    }\n    runInAction(() => {\n      this.user = user;\n    });\n  }\n\n  async login(\n    email: string,\n    password: string,\n  ): Promise<{\n    success: boolean;\n    message?: string;\n  }> {\n    const variables: LoginMutationVariables = {\n      email,\n      password,\n    };\n    const result = await client.mutate<LoginMutation>({\n      mutation: LoginDocument,\n      variables,\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      // logError('LoginMutation error');\n      result.errors.forEach((error) => {\n        // logError(error.message);\n      });\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    if (!result.data.authenticate?.jwtToken) {\n      return {\n        success: false,\n        message: 'Failed to login',\n      };\n    }\n\n    const bearerToken = result.data!.authenticate!.jwtToken;\n\n    this.setUser({\n      email,\n      bearerToken,\n    });\n\n    const usernameResult = await client.query<GetUsernameQuery>({\n      query: GetUsernameDocument,\n      variables: {\n        email,\n      } as GetUsernameQueryVariables,\n    });\n\n    if (usernameResult.errors && usernameResult.errors.length > 0) {\n      // logError('GetUsername error');\n      usernameResult.errors.forEach((error) => {\n        // logError(error.message);\n      });\n\n      this.setUser(undefined);\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    const {colour, username} = usernameResult.data!.users!.nodes[0]!;\n\n    this.setUser({\n      username,\n      email,\n      bearerToken,\n      colour,\n    });\n\n    return {\n      success: true,\n    };\n  }\n\n  async signUp(\n    username: string,\n    email: string,\n    password: string,\n  ): Promise<{success: boolean; message?: string}> {\n    const variables: SignUpMutationVariables = {\n      username,\n      email,\n      password,\n    };\n    const result = await client.mutate<SignUpMutation>({\n      mutation: SignUpDocument,\n      variables,\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    return this.login(email, password);\n  }\n\n  @action\n  logOut() {\n    this.setUser(undefined);\n  }\n}\n\nconst authStore = new AuthStore();\n\nexport {authStore};\n"]},"metadata":{},"sourceType":"module"}