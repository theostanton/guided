{"ast":null,"code":"var _class, _descriptor, _temp;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\nimport { action, computed, observable } from 'mobx';\nimport client, { USER_KEY } from 'api/client';\nimport * as storage from 'utils/storage';\nimport { GetUsernameDocument, LoginDocument, SignUpDocument } from 'api/generated';\nimport { Store } from 'stores/Store';\nlet AuthStore = (_class = (_temp = class AuthStore extends Store {\n  static async init() {\n    try {\n      const exists = await storage.exists(USER_KEY);\n\n      if (exists === true) {\n        const user = await storage.getObject(USER_KEY);\n        return new AuthStore(user);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n\n    return new AuthStore(undefined);\n  }\n\n  constructor(user) {\n    super();\n\n    _initializerDefineProperty(this, \"user\", _descriptor, this);\n\n    this.user = user;\n  }\n\n  hydrate(initialData) {}\n\n  get isLoggedIn() {\n    return this.user !== undefined;\n  }\n\n  setUser(user) {\n    if (user) {\n      storage.setObject(USER_KEY, user);\n    } else {\n      storage.remove(USER_KEY);\n    }\n\n    this.user = user;\n  }\n\n  async login(email, password) {\n    var _result$data$authenti;\n\n    const variables = {\n      email,\n      password\n    };\n    const result = await client.mutate({\n      mutation: LoginDocument,\n      variables\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      // logError('LoginMutation error');\n      result.errors.forEach(error => {// logError(error.message);\n      });\n      return {\n        success: false,\n        message: result.errors.map(error => {\n          return error.message;\n        }).join('\\n')\n      };\n    }\n\n    if (!((_result$data$authenti = result.data.authenticate) === null || _result$data$authenti === void 0 ? void 0 : _result$data$authenti.jwtToken)) {\n      return {\n        success: false,\n        message: 'Failed to login'\n      };\n    }\n\n    const bearerToken = result.data.authenticate.jwtToken;\n    this.setUser({\n      email,\n      bearerToken\n    });\n    const usernameResult = await client.query({\n      query: GetUsernameDocument,\n      variables: {\n        email\n      }\n    });\n\n    if (usernameResult.errors && usernameResult.errors.length > 0) {\n      usernameResult.errors.forEach(error => {});\n      this.setUser(undefined);\n      return {\n        success: false,\n        message: result.errors.map(error => {\n          return error.message;\n        }).join('\\n')\n      };\n    }\n\n    const {\n      colour,\n      username\n    } = usernameResult.data.users.nodes[0];\n    this.setUser({\n      username,\n      email,\n      bearerToken\n    });\n    return {\n      success: true\n    };\n  }\n\n  async signUp(username, email, password) {\n    const variables = {\n      username,\n      email,\n      password\n    };\n    const result = await client.mutate({\n      mutation: SignUpDocument,\n      variables\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      return {\n        success: false,\n        message: result.errors.map(error => {\n          return error.message;\n        }).join('\\n')\n      };\n    }\n\n    return this.login(email, password);\n  }\n\n  logOut() {\n    this.setUser(undefined);\n    console.log('logOUt this.user=', this.user);\n  }\n\n}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"user\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _applyDecoratedDescriptor(_class.prototype, \"isLoggedIn\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"isLoggedIn\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"setUser\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"setUser\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"logOut\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"logOut\"), _class.prototype)), _class);\nexport { AuthStore as default };","map":{"version":3,"sources":["/Users/theo/Code/guided/frontend/site/src/stores/AuthStore/index.ts"],"names":["action","computed","observable","client","USER_KEY","storage","GetUsernameDocument","LoginDocument","SignUpDocument","Store","AuthStore","init","exists","user","getObject","e","console","error","undefined","constructor","hydrate","initialData","isLoggedIn","setUser","setObject","remove","login","email","password","variables","result","mutate","mutation","errors","length","forEach","success","message","map","join","data","authenticate","jwtToken","bearerToken","usernameResult","query","colour","username","users","nodes","signUp","logOut","log"],"mappings":"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","sourcesContent":["import {action, computed, observable} from 'mobx';\nimport client, {USER_KEY} from 'api/client';\nimport * as storage from 'utils/storage';\nimport {\n  GetUsernameDocument,\n  GetUsernameQuery,\n  GetUsernameQueryVariables,\n  LoginDocument,\n  LoginMutation,\n  LoginMutationVariables,\n  SignUpDocument,\n  SignUpMutation,\n  SignUpMutationVariables,\n} from 'api/generated';\nimport {Store} from 'stores/Store';\n\nexport type User = {\n  bearerToken: string;\n  username?: string;\n  email: string;\n};\n\nexport default class AuthStore extends Store<User> {\n  static async init(): Promise<AuthStore> {\n    try {\n      const exists = await storage.exists(USER_KEY);\n      if (exists === true) {\n        const user = await storage.getObject<User>(USER_KEY);\n        return new AuthStore(user);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    return new AuthStore(undefined);\n  }\n\n  @observable\n  user: User | undefined;\n\n  constructor(user: User | undefined) {\n    super();\n    this.user = user;\n  }\n\n  hydrate(initialData: User | undefined) {}\n\n  @computed\n  get isLoggedIn(): boolean {\n    return this.user !== undefined;\n  }\n\n  @action\n  setUser(user: User | undefined) {\n    if (user) {\n      storage.setObject(USER_KEY, user);\n    } else {\n      storage.remove(USER_KEY);\n    }\n    this.user = user;\n  }\n\n  async login(\n    email: string,\n    password: string,\n  ): Promise<{\n    success: boolean;\n    message?: string;\n  }> {\n    const variables: LoginMutationVariables = {\n      email,\n      password,\n    };\n    const result = await client.mutate<LoginMutation>({\n      mutation: LoginDocument,\n      variables,\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      // logError('LoginMutation error');\n      result.errors.forEach((error) => {\n        // logError(error.message);\n      });\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    if (!result.data.authenticate?.jwtToken) {\n      return {\n        success: false,\n        message: 'Failed to login',\n      };\n    }\n\n    const bearerToken = result.data!.authenticate!.jwtToken;\n\n    this.setUser({\n      email,\n      bearerToken,\n    });\n\n    const usernameResult = await client.query<GetUsernameQuery>({\n      query: GetUsernameDocument,\n      variables: {\n        email,\n      } as GetUsernameQueryVariables,\n    });\n\n    if (usernameResult.errors && usernameResult.errors.length > 0) {\n      usernameResult.errors.forEach((error) => {});\n\n      this.setUser(undefined);\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    const {colour, username} = usernameResult.data!.users!.nodes[0]!;\n\n    this.setUser({\n      username,\n      email,\n      bearerToken,\n    });\n\n    return {\n      success: true,\n    };\n  }\n\n  async signUp(\n    username: string,\n    email: string,\n    password: string,\n  ): Promise<{success: boolean; message?: string}> {\n    const variables: SignUpMutationVariables = {\n      username,\n      email,\n      password,\n    };\n    const result = await client.mutate<SignUpMutation>({\n      mutation: SignUpDocument,\n      variables,\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    return this.login(email, password);\n  }\n\n  @action\n  logOut() {\n    this.setUser(undefined);\n    console.log('logOUt this.user=', this.user);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}