{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _taggedTemplateLiteral from \"@babel/runtime/helpers/esm/taggedTemplateLiteral\";\n\nvar _this = this,\n    _jsxFileName = \"/Users/theo/Code/guided/frontend/site/src/api/generated.tsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$();\n\nvar __jsx = React.createElement;\n\nfunction _templateObject3() {\n  var data = _taggedTemplateLiteral([\"\\n    query GetUsername($email: String!) {\\n  users(condition: {email: $email}) {\\n    nodes {\\n      username\\n      colour\\n    }\\n  }\\n}\\n    \"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"\\n    mutation SignUp($username: String!, $email: String!, $password: String!) {\\n  register(input: {_email: $email, _username: $username, _password: $password}) {\\n    user {\\n      username\\n    }\\n  }\\n}\\n    \"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    mutation Login($email: String!, $password: String!) {\\n  authenticate(input: {email: $email, password: $password}) {\\n    jwtToken\\n  }\\n}\\n    \"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nimport gql from 'graphql-tag';\nimport * as React from 'react';\nimport * as ApolloReactComponents from '@apollo/react-components';\nimport * as ApolloReactHooks from '@apollo/react-hooks';\nexport var Colour;\n/** A filter to be used against Colour fields. All fields are combined with a logical ‘and.’ */\n\n(function (Colour) {\n  Colour[\"Red\"] = \"RED\";\n  Colour[\"Orange\"] = \"ORANGE\";\n  Colour[\"Yellow\"] = \"YELLOW\";\n  Colour[\"Olive\"] = \"OLIVE\";\n  Colour[\"Green\"] = \"GREEN\";\n  Colour[\"Teal\"] = \"TEAL\";\n  Colour[\"Blue\"] = \"BLUE\";\n  Colour[\"Violet\"] = \"VIOLET\";\n  Colour[\"Purple\"] = \"PURPLE\";\n  Colour[\"Pink\"] = \"PINK\";\n  Colour[\"Brown\"] = \"BROWN\";\n  Colour[\"Grey\"] = \"GREY\";\n  Colour[\"Black\"] = \"BLACK\";\n})(Colour || (Colour = {}));\n\n/** Methods to use when ordering `Computation`. */\nexport var ComputationsOrderBy;\n\n(function (ComputationsOrderBy) {\n  ComputationsOrderBy[\"Natural\"] = \"NATURAL\";\n  ComputationsOrderBy[\"IdAsc\"] = \"ID_ASC\";\n  ComputationsOrderBy[\"IdDesc\"] = \"ID_DESC\";\n  ComputationsOrderBy[\"EndedAsc\"] = \"ENDED_ASC\";\n  ComputationsOrderBy[\"EndedDesc\"] = \"ENDED_DESC\";\n  ComputationsOrderBy[\"DurationAsc\"] = \"DURATION_ASC\";\n  ComputationsOrderBy[\"DurationDesc\"] = \"DURATION_DESC\";\n  ComputationsOrderBy[\"StatusAsc\"] = \"STATUS_ASC\";\n  ComputationsOrderBy[\"StatusDesc\"] = \"STATUS_DESC\";\n  ComputationsOrderBy[\"StageAsc\"] = \"STAGE_ASC\";\n  ComputationsOrderBy[\"StageDesc\"] = \"STAGE_DESC\";\n  ComputationsOrderBy[\"GuideAsc\"] = \"GUIDE_ASC\";\n  ComputationsOrderBy[\"GuideDesc\"] = \"GUIDE_DESC\";\n  ComputationsOrderBy[\"CreatedAsc\"] = \"CREATED_ASC\";\n  ComputationsOrderBy[\"CreatedDesc\"] = \"CREATED_DESC\";\n  ComputationsOrderBy[\"StartedAsc\"] = \"STARTED_ASC\";\n  ComputationsOrderBy[\"StartedDesc\"] = \"STARTED_DESC\";\n  ComputationsOrderBy[\"PrimaryKeyAsc\"] = \"PRIMARY_KEY_ASC\";\n  ComputationsOrderBy[\"PrimaryKeyDesc\"] = \"PRIMARY_KEY_DESC\";\n})(ComputationsOrderBy || (ComputationsOrderBy = {}));\n\nexport var ComputationStatus;\n/** A filter to be used against ComputationStatus fields. All fields are combined with a logical ‘and.’ */\n\n(function (ComputationStatus) {\n  ComputationStatus[\"Scheduled\"] = \"SCHEDULED\";\n  ComputationStatus[\"Failed\"] = \"FAILED\";\n  ComputationStatus[\"Computing\"] = \"COMPUTING\";\n  ComputationStatus[\"Success\"] = \"SUCCESS\";\n})(ComputationStatus || (ComputationStatus = {}));\n\n/** Methods to use when ordering `FeedEvent`. */\nexport var FeedEventsOrderBy;\n\n(function (FeedEventsOrderBy) {\n  FeedEventsOrderBy[\"Natural\"] = \"NATURAL\";\n  FeedEventsOrderBy[\"TimestampAsc\"] = \"TIMESTAMP_ASC\";\n  FeedEventsOrderBy[\"TimestampDesc\"] = \"TIMESTAMP_DESC\";\n  FeedEventsOrderBy[\"TypeAsc\"] = \"TYPE_ASC\";\n  FeedEventsOrderBy[\"TypeDesc\"] = \"TYPE_DESC\";\n  FeedEventsOrderBy[\"RideAsc\"] = \"RIDE_ASC\";\n  FeedEventsOrderBy[\"RideDesc\"] = \"RIDE_DESC\";\n  FeedEventsOrderBy[\"GuideAsc\"] = \"GUIDE_ASC\";\n  FeedEventsOrderBy[\"GuideDesc\"] = \"GUIDE_DESC\";\n  FeedEventsOrderBy[\"UserAsc\"] = \"USER_ASC\";\n  FeedEventsOrderBy[\"UserDesc\"] = \"USER_DESC\";\n  FeedEventsOrderBy[\"PrimaryKeyAsc\"] = \"PRIMARY_KEY_ASC\";\n  FeedEventsOrderBy[\"PrimaryKeyDesc\"] = \"PRIMARY_KEY_DESC\";\n})(FeedEventsOrderBy || (FeedEventsOrderBy = {}));\n\nexport var FeedEventType;\n/** A filter to be used against FeedEventType fields. All fields are combined with a logical ‘and.’ */\n\n(function (FeedEventType) {\n  FeedEventType[\"NewGuide\"] = \"NEW_GUIDE\";\n  FeedEventType[\"NewFollows\"] = \"NEW_FOLLOWS\";\n  FeedEventType[\"SelfCreated\"] = \"SELF_CREATED\";\n})(FeedEventType || (FeedEventType = {}));\n\nexport var FollowingStatus;\n/** A filter to be used against FollowingStatus fields. All fields are combined with a logical ‘and.’ */\n\n(function (FollowingStatus) {\n  FollowingStatus[\"Following\"] = \"FOLLOWING\";\n  FollowingStatus[\"IsSelf\"] = \"IS_SELF\";\n  FollowingStatus[\"NotFollowing\"] = \"NOT_FOLLOWING\";\n  FollowingStatus[\"Anonymous\"] = \"ANONYMOUS\";\n})(FollowingStatus || (FollowingStatus = {}));\n\n/** Methods to use when ordering `Follow`. */\nexport var FollowsOrderBy;\n\n(function (FollowsOrderBy) {\n  FollowsOrderBy[\"Natural\"] = \"NATURAL\";\n  FollowsOrderBy[\"FollowedAsc\"] = \"FOLLOWED_ASC\";\n  FollowsOrderBy[\"FollowedDesc\"] = \"FOLLOWED_DESC\";\n  FollowsOrderBy[\"FollowerAsc\"] = \"FOLLOWER_ASC\";\n  FollowsOrderBy[\"FollowerDesc\"] = \"FOLLOWER_DESC\";\n  FollowsOrderBy[\"TimestampAsc\"] = \"TIMESTAMP_ASC\";\n  FollowsOrderBy[\"TimestampDesc\"] = \"TIMESTAMP_DESC\";\n})(FollowsOrderBy || (FollowsOrderBy = {}));\n\n/** Methods to use when ordering `Guide`. */\nexport var GuidesOrderBy;\n/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */\n\n(function (GuidesOrderBy) {\n  GuidesOrderBy[\"Natural\"] = \"NATURAL\";\n  GuidesOrderBy[\"IdAsc\"] = \"ID_ASC\";\n  GuidesOrderBy[\"IdDesc\"] = \"ID_DESC\";\n  GuidesOrderBy[\"TitleAsc\"] = \"TITLE_ASC\";\n  GuidesOrderBy[\"TitleDesc\"] = \"TITLE_DESC\";\n  GuidesOrderBy[\"SlugAsc\"] = \"SLUG_ASC\";\n  GuidesOrderBy[\"SlugDesc\"] = \"SLUG_DESC\";\n  GuidesOrderBy[\"OwnerAsc\"] = \"OWNER_ASC\";\n  GuidesOrderBy[\"OwnerDesc\"] = \"OWNER_DESC\";\n  GuidesOrderBy[\"StartDateAsc\"] = \"START_DATE_ASC\";\n  GuidesOrderBy[\"StartDateDesc\"] = \"START_DATE_DESC\";\n  GuidesOrderBy[\"IsCircularAsc\"] = \"IS_CIRCULAR_ASC\";\n  GuidesOrderBy[\"IsCircularDesc\"] = \"IS_CIRCULAR_DESC\";\n  GuidesOrderBy[\"TransportTypeAsc\"] = \"TRANSPORT_TYPE_ASC\";\n  GuidesOrderBy[\"TransportTypeDesc\"] = \"TRANSPORT_TYPE_DESC\";\n  GuidesOrderBy[\"MaxHoursPerRideAsc\"] = \"MAX_HOURS_PER_RIDE_ASC\";\n  GuidesOrderBy[\"MaxHoursPerRideDesc\"] = \"MAX_HOURS_PER_RIDE_DESC\";\n  GuidesOrderBy[\"CreatedAsc\"] = \"CREATED_ASC\";\n  GuidesOrderBy[\"CreatedDesc\"] = \"CREATED_DESC\";\n  GuidesOrderBy[\"UpdatedAsc\"] = \"UPDATED_ASC\";\n  GuidesOrderBy[\"UpdatedDesc\"] = \"UPDATED_DESC\";\n  GuidesOrderBy[\"PrimaryKeyAsc\"] = \"PRIMARY_KEY_ASC\";\n  GuidesOrderBy[\"PrimaryKeyDesc\"] = \"PRIMARY_KEY_DESC\";\n})(GuidesOrderBy || (GuidesOrderBy = {}));\n\n/** Methods to use when ordering `Ride`. */\nexport var RidesOrderBy;\n\n(function (RidesOrderBy) {\n  RidesOrderBy[\"Natural\"] = \"NATURAL\";\n  RidesOrderBy[\"IdAsc\"] = \"ID_ASC\";\n  RidesOrderBy[\"IdDesc\"] = \"ID_DESC\";\n  RidesOrderBy[\"GuideAsc\"] = \"GUIDE_ASC\";\n  RidesOrderBy[\"GuideDesc\"] = \"GUIDE_DESC\";\n  RidesOrderBy[\"OwnerAsc\"] = \"OWNER_ASC\";\n  RidesOrderBy[\"OwnerDesc\"] = \"OWNER_DESC\";\n  RidesOrderBy[\"FromSpotAsc\"] = \"FROM_SPOT_ASC\";\n  RidesOrderBy[\"FromSpotDesc\"] = \"FROM_SPOT_DESC\";\n  RidesOrderBy[\"ToSpotAsc\"] = \"TO_SPOT_ASC\";\n  RidesOrderBy[\"ToSpotDesc\"] = \"TO_SPOT_DESC\";\n  RidesOrderBy[\"PathUrlAsc\"] = \"PATH_URL_ASC\";\n  RidesOrderBy[\"PathUrlDesc\"] = \"PATH_URL_DESC\";\n  RidesOrderBy[\"DurationSecondsAsc\"] = \"DURATION_SECONDS_ASC\";\n  RidesOrderBy[\"DurationSecondsDesc\"] = \"DURATION_SECONDS_DESC\";\n  RidesOrderBy[\"DistanceMetersAsc\"] = \"DISTANCE_METERS_ASC\";\n  RidesOrderBy[\"DistanceMetersDesc\"] = \"DISTANCE_METERS_DESC\";\n  RidesOrderBy[\"DateAsc\"] = \"DATE_ASC\";\n  RidesOrderBy[\"DateDesc\"] = \"DATE_DESC\";\n  RidesOrderBy[\"StageAsc\"] = \"STAGE_ASC\";\n  RidesOrderBy[\"StageDesc\"] = \"STAGE_DESC\";\n  RidesOrderBy[\"PositionAsc\"] = \"POSITION_ASC\";\n  RidesOrderBy[\"PositionDesc\"] = \"POSITION_DESC\";\n  RidesOrderBy[\"StatusAsc\"] = \"STATUS_ASC\";\n  RidesOrderBy[\"StatusDesc\"] = \"STATUS_DESC\";\n  RidesOrderBy[\"CreatedAsc\"] = \"CREATED_ASC\";\n  RidesOrderBy[\"CreatedDesc\"] = \"CREATED_DESC\";\n  RidesOrderBy[\"UpdatedAsc\"] = \"UPDATED_ASC\";\n  RidesOrderBy[\"UpdatedDesc\"] = \"UPDATED_DESC\";\n  RidesOrderBy[\"PrimaryKeyAsc\"] = \"PRIMARY_KEY_ASC\";\n  RidesOrderBy[\"PrimaryKeyDesc\"] = \"PRIMARY_KEY_DESC\";\n})(RidesOrderBy || (RidesOrderBy = {}));\n\nexport var RideStatus;\n/** A filter to be used against RideStatus fields. All fields are combined with a logical ‘and.’ */\n\n(function (RideStatus) {\n  RideStatus[\"Complete\"] = \"COMPLETE\";\n  RideStatus[\"Ready\"] = \"READY\";\n  RideStatus[\"Stale\"] = \"STALE\";\n})(RideStatus || (RideStatus = {}));\n\n/** Methods to use when ordering `Spot`. */\nexport var SpotsOrderBy;\n\n(function (SpotsOrderBy) {\n  SpotsOrderBy[\"Natural\"] = \"NATURAL\";\n  SpotsOrderBy[\"IdAsc\"] = \"ID_ASC\";\n  SpotsOrderBy[\"IdDesc\"] = \"ID_DESC\";\n  SpotsOrderBy[\"LabelAsc\"] = \"LABEL_ASC\";\n  SpotsOrderBy[\"LabelDesc\"] = \"LABEL_DESC\";\n  SpotsOrderBy[\"GuideAsc\"] = \"GUIDE_ASC\";\n  SpotsOrderBy[\"GuideDesc\"] = \"GUIDE_DESC\";\n  SpotsOrderBy[\"OwnerAsc\"] = \"OWNER_ASC\";\n  SpotsOrderBy[\"OwnerDesc\"] = \"OWNER_DESC\";\n  SpotsOrderBy[\"NightsAsc\"] = \"NIGHTS_ASC\";\n  SpotsOrderBy[\"NightsDesc\"] = \"NIGHTS_DESC\";\n  SpotsOrderBy[\"LockedAsc\"] = \"LOCKED_ASC\";\n  SpotsOrderBy[\"LockedDesc\"] = \"LOCKED_DESC\";\n  SpotsOrderBy[\"LatAsc\"] = \"LAT_ASC\";\n  SpotsOrderBy[\"LatDesc\"] = \"LAT_DESC\";\n  SpotsOrderBy[\"LongAsc\"] = \"LONG_ASC\";\n  SpotsOrderBy[\"LongDesc\"] = \"LONG_DESC\";\n  SpotsOrderBy[\"PositionAsc\"] = \"POSITION_ASC\";\n  SpotsOrderBy[\"PositionDesc\"] = \"POSITION_DESC\";\n  SpotsOrderBy[\"LocationAsc\"] = \"LOCATION_ASC\";\n  SpotsOrderBy[\"LocationDesc\"] = \"LOCATION_DESC\";\n  SpotsOrderBy[\"CountryAsc\"] = \"COUNTRY_ASC\";\n  SpotsOrderBy[\"CountryDesc\"] = \"COUNTRY_DESC\";\n  SpotsOrderBy[\"DateAsc\"] = \"DATE_ASC\";\n  SpotsOrderBy[\"DateDesc\"] = \"DATE_DESC\";\n  SpotsOrderBy[\"CreatedAsc\"] = \"CREATED_ASC\";\n  SpotsOrderBy[\"CreatedDesc\"] = \"CREATED_DESC\";\n  SpotsOrderBy[\"UpdatedAsc\"] = \"UPDATED_ASC\";\n  SpotsOrderBy[\"UpdatedDesc\"] = \"UPDATED_DESC\";\n  SpotsOrderBy[\"StageAsc\"] = \"STAGE_ASC\";\n  SpotsOrderBy[\"StageDesc\"] = \"STAGE_DESC\";\n  SpotsOrderBy[\"PrimaryKeyAsc\"] = \"PRIMARY_KEY_ASC\";\n  SpotsOrderBy[\"PrimaryKeyDesc\"] = \"PRIMARY_KEY_DESC\";\n})(SpotsOrderBy || (SpotsOrderBy = {}));\n\n/** Methods to use when ordering `Stage`. */\nexport var StagesOrderBy;\n\n(function (StagesOrderBy) {\n  StagesOrderBy[\"Natural\"] = \"NATURAL\";\n  StagesOrderBy[\"IdAsc\"] = \"ID_ASC\";\n  StagesOrderBy[\"IdDesc\"] = \"ID_DESC\";\n  StagesOrderBy[\"GuideAsc\"] = \"GUIDE_ASC\";\n  StagesOrderBy[\"GuideDesc\"] = \"GUIDE_DESC\";\n  StagesOrderBy[\"FromSpotAsc\"] = \"FROM_SPOT_ASC\";\n  StagesOrderBy[\"FromSpotDesc\"] = \"FROM_SPOT_DESC\";\n  StagesOrderBy[\"ToSpotAsc\"] = \"TO_SPOT_ASC\";\n  StagesOrderBy[\"ToSpotDesc\"] = \"TO_SPOT_DESC\";\n  StagesOrderBy[\"CreatedAsc\"] = \"CREATED_ASC\";\n  StagesOrderBy[\"CreatedDesc\"] = \"CREATED_DESC\";\n  StagesOrderBy[\"UpdatedAsc\"] = \"UPDATED_ASC\";\n  StagesOrderBy[\"UpdatedDesc\"] = \"UPDATED_DESC\";\n  StagesOrderBy[\"StatusAsc\"] = \"STATUS_ASC\";\n  StagesOrderBy[\"StatusDesc\"] = \"STATUS_DESC\";\n  StagesOrderBy[\"PositionAsc\"] = \"POSITION_ASC\";\n  StagesOrderBy[\"PositionDesc\"] = \"POSITION_DESC\";\n  StagesOrderBy[\"PrimaryKeyAsc\"] = \"PRIMARY_KEY_ASC\";\n  StagesOrderBy[\"PrimaryKeyDesc\"] = \"PRIMARY_KEY_DESC\";\n})(StagesOrderBy || (StagesOrderBy = {}));\n\nexport var StageStatus;\n/** A filter to be used against StageStatus fields. All fields are combined with a logical ‘and.’ */\n\n(function (StageStatus) {\n  StageStatus[\"Complete\"] = \"COMPLETE\";\n  StageStatus[\"Ready\"] = \"READY\";\n  StageStatus[\"Computing\"] = \"COMPUTING\";\n  StageStatus[\"Stale\"] = \"STALE\";\n})(StageStatus || (StageStatus = {}));\n\n/** Methods to use when ordering `Temperature`. */\nexport var TemperaturesOrderBy;\n\n(function (TemperaturesOrderBy) {\n  TemperaturesOrderBy[\"Natural\"] = \"NATURAL\";\n  TemperaturesOrderBy[\"IdAsc\"] = \"ID_ASC\";\n  TemperaturesOrderBy[\"IdDesc\"] = \"ID_DESC\";\n  TemperaturesOrderBy[\"CountryAsc\"] = \"COUNTRY_ASC\";\n  TemperaturesOrderBy[\"CountryDesc\"] = \"COUNTRY_DESC\";\n  TemperaturesOrderBy[\"MonthAsc\"] = \"MONTH_ASC\";\n  TemperaturesOrderBy[\"MonthDesc\"] = \"MONTH_DESC\";\n  TemperaturesOrderBy[\"TemperatureAsc\"] = \"TEMPERATURE_ASC\";\n  TemperaturesOrderBy[\"TemperatureDesc\"] = \"TEMPERATURE_DESC\";\n  TemperaturesOrderBy[\"CreatedAsc\"] = \"CREATED_ASC\";\n  TemperaturesOrderBy[\"CreatedDesc\"] = \"CREATED_DESC\";\n  TemperaturesOrderBy[\"UpdatedAsc\"] = \"UPDATED_ASC\";\n  TemperaturesOrderBy[\"UpdatedDesc\"] = \"UPDATED_DESC\";\n  TemperaturesOrderBy[\"PrimaryKeyAsc\"] = \"PRIMARY_KEY_ASC\";\n  TemperaturesOrderBy[\"PrimaryKeyDesc\"] = \"PRIMARY_KEY_DESC\";\n})(TemperaturesOrderBy || (TemperaturesOrderBy = {}));\n\nexport var TransportType;\n/** A filter to be used against TransportType fields. All fields are combined with a logical ‘and.’ */\n\n(function (TransportType) {\n  TransportType[\"Motorcycle\"] = \"MOTORCYCLE\";\n  TransportType[\"Bicycle\"] = \"BICYCLE\";\n  TransportType[\"Car\"] = \"CAR\";\n})(TransportType || (TransportType = {}));\n\n/** Methods to use when ordering `User`. */\nexport var UsersOrderBy;\n\n(function (UsersOrderBy) {\n  UsersOrderBy[\"Natural\"] = \"NATURAL\";\n  UsersOrderBy[\"UsernameAsc\"] = \"USERNAME_ASC\";\n  UsersOrderBy[\"UsernameDesc\"] = \"USERNAME_DESC\";\n  UsersOrderBy[\"EmailAsc\"] = \"EMAIL_ASC\";\n  UsersOrderBy[\"EmailDesc\"] = \"EMAIL_DESC\";\n  UsersOrderBy[\"PasswordHashAsc\"] = \"PASSWORD_HASH_ASC\";\n  UsersOrderBy[\"PasswordHashDesc\"] = \"PASSWORD_HASH_DESC\";\n  UsersOrderBy[\"ColourAsc\"] = \"COLOUR_ASC\";\n  UsersOrderBy[\"ColourDesc\"] = \"COLOUR_DESC\";\n  UsersOrderBy[\"CreatedAsc\"] = \"CREATED_ASC\";\n  UsersOrderBy[\"CreatedDesc\"] = \"CREATED_DESC\";\n  UsersOrderBy[\"UpdatedAsc\"] = \"UPDATED_ASC\";\n  UsersOrderBy[\"UpdatedDesc\"] = \"UPDATED_DESC\";\n  UsersOrderBy[\"PrimaryKeyAsc\"] = \"PRIMARY_KEY_ASC\";\n  UsersOrderBy[\"PrimaryKeyDesc\"] = \"PRIMARY_KEY_DESC\";\n})(UsersOrderBy || (UsersOrderBy = {}));\n\nexport var LoginDocument = gql(_templateObject());\nexport var LoginComponent = function LoginComponent(props) {\n  return __jsx(ApolloReactComponents.Mutation, _extends({\n    mutation: LoginDocument\n  }, props, {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 4525,\n      columnNumber: 7\n    }\n  }));\n};\n/**\n * __useLoginMutation__\n *\n * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useLoginMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [loginMutation, { data, loading, error }] = useLoginMutation({\n *   variables: {\n *      email: // value for 'email'\n *      password: // value for 'password'\n *   },\n * });\n */\n\n_c = LoginComponent;\nexport function useLoginMutation(baseOptions) {\n  _s();\n\n  return ApolloReactHooks.useMutation(LoginDocument, baseOptions);\n}\n\n_s(useLoginMutation, \"wwwtpB20p0aLiHIvSy5P98MwIUg=\", false, function () {\n  return [ApolloReactHooks.useMutation];\n});\n\nexport var SignUpDocument = gql(_templateObject2());\nexport var SignUpComponent = function SignUpComponent(props) {\n  return __jsx(ApolloReactComponents.Mutation, _extends({\n    mutation: SignUpDocument\n  }, props, {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 4566,\n      columnNumber: 7\n    }\n  }));\n};\n/**\n * __useSignUpMutation__\n *\n * To run a mutation, you first call `useSignUpMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useSignUpMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [signUpMutation, { data, loading, error }] = useSignUpMutation({\n *   variables: {\n *      username: // value for 'username'\n *      email: // value for 'email'\n *      password: // value for 'password'\n *   },\n * });\n */\n\n_c2 = SignUpComponent;\nexport function useSignUpMutation(baseOptions) {\n  _s2();\n\n  return ApolloReactHooks.useMutation(SignUpDocument, baseOptions);\n}\n\n_s2(useSignUpMutation, \"wwwtpB20p0aLiHIvSy5P98MwIUg=\", false, function () {\n  return [ApolloReactHooks.useMutation];\n});\n\nexport var GetUsernameDocument = gql(_templateObject3());\nexport var GetUsernameComponent = function GetUsernameComponent(props) {\n  return __jsx(ApolloReactComponents.Query, _extends({\n    query: GetUsernameDocument\n  }, props, {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 4608,\n      columnNumber: 7\n    }\n  }));\n};\n/**\n * __useGetUsernameQuery__\n *\n * To run a query within a React component, call `useGetUsernameQuery` and pass it any options that fit your needs.\n * When your component renders, `useGetUsernameQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useGetUsernameQuery({\n *   variables: {\n *      email: // value for 'email'\n *   },\n * });\n */\n\n_c3 = GetUsernameComponent;\nexport function useGetUsernameQuery(baseOptions) {\n  _s3();\n\n  return ApolloReactHooks.useQuery(GetUsernameDocument, baseOptions);\n}\n\n_s3(useGetUsernameQuery, \"4ZpngI1uv+Uo3WQHEZmTQ5FNM+k=\", false, function () {\n  return [ApolloReactHooks.useQuery];\n});\n\nexport function useGetUsernameLazyQuery(baseOptions) {\n  _s4();\n\n  return ApolloReactHooks.useLazyQuery(GetUsernameDocument, baseOptions);\n}\n\n_s4(useGetUsernameLazyQuery, \"On+3mFuZjiEOS3MQLgFXtHkppJ4=\", false, function () {\n  return [ApolloReactHooks.useLazyQuery];\n});\n\nvar _c, _c2, _c3;\n\n$RefreshReg$(_c, \"LoginComponent\");\n$RefreshReg$(_c2, \"SignUpComponent\");\n$RefreshReg$(_c3, \"GetUsernameComponent\");","map":{"version":3,"sources":["/Users/theo/Code/guided/frontend/site/src/api/generated.tsx"],"names":["gql","React","ApolloReactComponents","ApolloReactHooks","Colour","ComputationsOrderBy","ComputationStatus","FeedEventsOrderBy","FeedEventType","FollowingStatus","FollowsOrderBy","GuidesOrderBy","RidesOrderBy","RideStatus","SpotsOrderBy","StagesOrderBy","StageStatus","TemperaturesOrderBy","TransportType","UsersOrderBy","LoginDocument","LoginComponent","props","useLoginMutation","baseOptions","useMutation","SignUpDocument","SignUpComponent","useSignUpMutation","GetUsernameDocument","GetUsernameComponent","useGetUsernameQuery","useQuery","useGetUsernameLazyQuery","useLazyQuery"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,OAAOA,GAAP,MAAgB,aAAhB;AAEA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,OAAO,KAAKC,qBAAZ,MAAuC,0BAAvC;AACA,OAAO,KAAKC,gBAAZ,MAAkC,qBAAlC;AAkIA,WAAYC,MAAZ;AAgBA;;WAhBYA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;AAAAA,EAAAA,M;GAAAA,M,KAAAA,M;;AAgIZ;AACA,WAAYC,mBAAZ;;WAAYA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;GAAAA,mB,KAAAA,mB;;AAsBZ,WAAYC,iBAAZ;AAOA;;WAPYA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;GAAAA,iB,KAAAA,iB;;AAsSZ;AACA,WAAYC,iBAAZ;;WAAYA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;GAAAA,iB,KAAAA,iB;;AAgBZ,WAAYC,aAAZ;AAMA;;WANYA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;GAAAA,a,KAAAA,a;;AA8FZ,WAAYC,eAAZ;AAOA;;WAPYA,e;AAAAA,EAAAA,e;AAAAA,EAAAA,e;AAAAA,EAAAA,e;AAAAA,EAAAA,e;GAAAA,e,KAAAA,e;;AAqDZ;AACA,WAAYC,cAAZ;;WAAYA,c;AAAAA,EAAAA,c;AAAAA,EAAAA,c;AAAAA,EAAAA,c;AAAAA,EAAAA,c;AAAAA,EAAAA,c;AAAAA,EAAAA,c;AAAAA,EAAAA,c;GAAAA,c,KAAAA,c;;AAuMZ;AACA,WAAYC,aAAZ;AA0BA;;WA1BYA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;GAAAA,a,KAAAA,a;;AA8qBZ;AACA,WAAYC,YAAZ;;WAAYA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;GAAAA,Y,KAAAA,Y;;AAkCZ,WAAYC,UAAZ;AAMA;;WANYA,U;AAAAA,EAAAA,U;AAAAA,EAAAA,U;AAAAA,EAAAA,U;GAAAA,U,KAAAA,U;;AAyNZ;AACA,WAAYC,YAAZ;;WAAYA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;GAAAA,Y,KAAAA,Y;;AAsKZ;AACA,WAAYC,aAAZ;;WAAYA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;GAAAA,a,KAAAA,a;;AAsBZ,WAAYC,WAAZ;AAOA;;WAPYA,W;AAAAA,EAAAA,W;AAAAA,EAAAA,W;AAAAA,EAAAA,W;AAAAA,EAAAA,W;GAAAA,W,KAAAA,W;;AAsnCZ;AACA,WAAYC,mBAAZ;;WAAYA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;GAAAA,mB,KAAAA,mB;;AAkBZ,WAAYC,aAAZ;AAMA;;WANYA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;AAAAA,EAAAA,a;GAAAA,a,KAAAA,a;;AA0SZ;AACA,WAAYC,YAAZ;;WAAYA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;AAAAA,EAAAA,Y;GAAAA,Y,KAAAA,Y;;AAo9BZ,OAAO,IAAMC,aAAa,GAAGpB,GAAH,mBAAnB;AAUH,OAAO,IAAMqB,cAAc,GAAG,SAAjBA,cAAiB,CAACC,KAAD;AAAA,SAC5B,MAAC,qBAAD,CAAuB,QAAvB;AAAuE,IAAA,QAAQ,EAAEF;AAAjF,KAAoGE,KAApG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAD4B;AAAA,CAAvB;AAKX;;;;;;;;;;;;;;;;;;;KALiBD,c;AAuBjB,OAAO,SAASE,gBAAT,CAA0BC,WAA1B,EAAqH;AAAA;;AACpH,SAAOrB,gBAAgB,CAACsB,WAAjB,CAAoEL,aAApE,EAAmFI,WAAnF,CAAP;AACD;;GAFSD,gB;UACDpB,gBAAgB,CAACsB,W;;;AAKhC,OAAO,IAAMC,cAAc,GAAG1B,GAAH,oBAApB;AAYH,OAAO,IAAM2B,eAAe,GAAG,SAAlBA,eAAkB,CAACL,KAAD;AAAA,SAC7B,MAAC,qBAAD,CAAuB,QAAvB;AAAyE,IAAA,QAAQ,EAAEI;AAAnF,KAAuGJ,KAAvG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAD6B;AAAA,CAAxB;AAKX;;;;;;;;;;;;;;;;;;;;MALiBK,e;AAwBjB,OAAO,SAASC,iBAAT,CAA2BJ,WAA3B,EAAwH;AAAA;;AACvH,SAAOrB,gBAAgB,CAACsB,WAAjB,CAAsEC,cAAtE,EAAsFF,WAAtF,CAAP;AACD;;IAFSI,iB;UACDzB,gBAAgB,CAACsB,W;;;AAKhC,OAAO,IAAMI,mBAAmB,GAAG7B,GAAH,oBAAzB;AAYH,OAAO,IAAM8B,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACR,KAAD;AAAA,SAClC,MAAC,qBAAD,CAAuB,KAAvB;AAA0E,IAAA,KAAK,EAAEO;AAAjF,KAA0GP,KAA1G;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KADkC;AAAA,CAA7B;AAKX;;;;;;;;;;;;;;;;;MALiBQ,oB;AAqBjB,OAAO,SAASC,mBAAT,CAA6BP,WAA7B,EAA2H;AAAA;;AAC1H,SAAOrB,gBAAgB,CAAC6B,QAAjB,CAAuEH,mBAAvE,EAA4FL,WAA5F,CAAP;AACD;;IAFSO,mB;UACD5B,gBAAgB,CAAC6B,Q;;;AAEhC,OAAO,SAASC,uBAAT,CAAiCT,WAAjC,EAAmI;AAAA;;AAChI,SAAOrB,gBAAgB,CAAC+B,YAAjB,CAA2EL,mBAA3E,EAAgGL,WAAhG,CAAP;AACD;;IAFOS,uB;UACC9B,gBAAgB,CAAC+B,Y","sourcesContent":["import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';\nimport gql from 'graphql-tag';\nimport * as ApolloReactCommon from '@apollo/react-common';\nimport * as React from 'react';\nimport * as ApolloReactComponents from '@apollo/react-components';\nimport * as ApolloReactHooks from '@apollo/react-hooks';\nexport type Maybe<T> = T | null;\nexport type RequireFields<T, K extends keyof T> = { [X in Exclude<keyof T, K>]?: T[X] } & { [P in K]-?: NonNullable<T[P]> };\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  /** A location in a connection that can be used for resuming pagination. */\n  Cursor: any;\n  /**\n   * A point in time as described by the [ISO\n   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.\n   */\n  Datetime: string;\n  /**\n   * A signed eight-byte integer. The upper big integer values are greater than the\n   * max value for a JavaScript number. Therefore all big integers will be output as\n   * strings and not numbers.\n   */\n  BigInt: any;\n  /**\n   * A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519)\n   * which securely represents claims between two parties.\n   */\n  JwtToken: any;\n};\n\nexport type AddSpotInput = {\n  readonly guideId: Scalars['String'];\n  readonly lat: Scalars['Float'];\n  readonly long: Scalars['Float'];\n  readonly label?: Maybe<Scalars['String']>;\n  readonly location?: Maybe<Scalars['String']>;\n  readonly country?: Maybe<Scalars['String']>;\n  readonly nights: Scalars['Int'];\n};\n\nexport type AddSpotResult = {\n  readonly success: Scalars['Boolean'];\n  readonly messaage?: Maybe<Scalars['String']>;\n  readonly id?: Maybe<Scalars['String']>;\n};\n\n/** All input for the `authenticate` mutation. */\nexport type AuthenticateInput = {\n  /**\n   * An arbitrary string value with no semantic meaning. Will be included in the\n   * payload verbatim. May be used to track mutations by the client.\n   */\n  readonly clientMutationId?: Maybe<Scalars['String']>;\n  readonly email: Scalars['String'];\n  readonly password: Scalars['String'];\n};\n\n/** The output of our `authenticate` mutation. */\nexport type AuthenticatePayload = {\n  /**\n   * The exact same `clientMutationId` that was provided in the mutation input,\n   * unchanged and unused. May be used by a client to track mutations.\n   */\n  readonly clientMutationId?: Maybe<Scalars['String']>;\n  readonly jwtToken?: Maybe<Scalars['JwtToken']>;\n  /** Our root query field type. Allows us to run any query from our mutation payload. */\n  readonly query?: Maybe<Query>;\n};\n\n\n/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */\nexport type BigIntFilter = {\n  /** Is null (if `true` is specified) or is not null (if `false` is specified). */\n  readonly isNull?: Maybe<Scalars['Boolean']>;\n  /** Equal to the specified value. */\n  readonly equalTo?: Maybe<Scalars['BigInt']>;\n  /** Not equal to the specified value. */\n  readonly notEqualTo?: Maybe<Scalars['BigInt']>;\n  /** Not equal to the specified value, treating null like an ordinary value. */\n  readonly distinctFrom?: Maybe<Scalars['BigInt']>;\n  /** Equal to the specified value, treating null like an ordinary value. */\n  readonly notDistinctFrom?: Maybe<Scalars['BigInt']>;\n  /** Included in the specified list. */\n  readonly in?: Maybe<ReadonlyArray<Scalars['BigInt']>>;\n  /** Not included in the specified list. */\n  readonly notIn?: Maybe<ReadonlyArray<Scalars['BigInt']>>;\n  /** Less than the specified value. */\n  readonly lessThan?: Maybe<Scalars['BigInt']>;\n  /** Less than or equal to the specified value. */\n  readonly lessThanOrEqualTo?: Maybe<Scalars['BigInt']>;\n  /** Greater than the specified value. */\n  readonly greaterThan?: Maybe<Scalars['BigInt']>;\n  /** Greater than or equal to the specified value. */\n  readonly greaterThanOrEqualTo?: Maybe<Scalars['BigInt']>;\n};\n\n/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */\nexport type BooleanFilter = {\n  /** Is null (if `true` is specified) or is not null (if `false` is specified). */\n  readonly isNull?: Maybe<Scalars['Boolean']>;\n  /** Equal to the specified value. */\n  readonly equalTo?: Maybe<Scalars['Boolean']>;\n  /** Not equal to the specified value. */\n  readonly notEqualTo?: Maybe<Scalars['Boolean']>;\n  /** Not equal to the specified value, treating null like an ordinary value. */\n  readonly distinctFrom?: Maybe<Scalars['Boolean']>;\n  /** Equal to the specified value, treating null like an ordinary value. */\n  readonly notDistinctFrom?: Maybe<Scalars['Boolean']>;\n  /** Included in the specified list. */\n  readonly in?: Maybe<ReadonlyArray<Scalars['Boolean']>>;\n  /** Not included in the specified list. */\n  readonly notIn?: Maybe<ReadonlyArray<Scalars['Boolean']>>;\n  /** Less than the specified value. */\n  readonly lessThan?: Maybe<Scalars['Boolean']>;\n  /** Less than or equal to the specified value. */\n  readonly lessThanOrEqualTo?: Maybe<Scalars['Boolean']>;\n  /** Greater than the specified value. */\n  readonly greaterThan?: Maybe<Scalars['Boolean']>;\n  /** Greater than or equal to the specified value. */\n  readonly greaterThanOrEqualTo?: Maybe<Scalars['Boolean']>;\n};\n\nexport type Bound = {\n  readonly north?: Maybe<Scalars['Float']>;\n  readonly east?: Maybe<Scalars['Float']>;\n  readonly south?: Maybe<Scalars['Float']>;\n  readonly west?: Maybe<Scalars['Float']>;\n};\n\nexport enum Colour {\n  Red = 'RED',\n  Orange = 'ORANGE',\n  Yellow = 'YELLOW',\n  Olive = 'OLIVE',\n  Green = 'GREEN',\n  Teal = 'TEAL',\n  Blue = 'BLUE',\n  Violet = 'VIOLET',\n  Purple = 'PURPLE',\n  Pink = 'PINK',\n  Brown = 'BROWN',\n  Grey = 'GREY',\n  Black = 'BLACK'\n}\n\n/** A filter to be used against Colour fields. All fields are combined with a logical ‘and.’ */\nexport type ColourFilter = {\n  /** Is null (if `true` is specified) or is not null (if `false` is specified). */\n  readonly isNull?: Maybe<Scalars['Boolean']>;\n  /** Equal to the specified value. */\n  readonly equalTo?: Maybe<Colour>;\n  /** Not equal to the specified value. */\n  readonly notEqualTo?: Maybe<Colour>;\n  /** Not equal to the specified value, treating null like an ordinary value. */\n  readonly distinctFrom?: Maybe<Colour>;\n  /** Equal to the specified value, treating null like an ordinary value. */\n  readonly notDistinctFrom?: Maybe<Colour>;\n  /** Included in the specified list. */\n  readonly in?: Maybe<ReadonlyArray<Colour>>;\n  /** Not included in the specified list. */\n  readonly notIn?: Maybe<ReadonlyArray<Colour>>;\n  /** Less than the specified value. */\n  readonly lessThan?: Maybe<Colour>;\n  /** Less than or equal to the specified value. */\n  readonly lessThanOrEqualTo?: Maybe<Colour>;\n  /** Greater than the specified value. */\n  readonly greaterThan?: Maybe<Colour>;\n  /** Greater than or equal to the specified value. */\n  readonly greaterThanOrEqualTo?: Maybe<Colour>;\n};\n\nexport type Computation = Node & {\n  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */\n  readonly nodeId: Scalars['ID'];\n  readonly id: Scalars['String'];\n  readonly ended?: Maybe<Scalars['Datetime']>;\n  readonly duration?: Maybe<Scalars['Int']>;\n  readonly status: ComputationStatus;\n  readonly stage?: Maybe<Scalars['String']>;\n  readonly guide: Scalars['String'];\n  readonly created: Scalars['Datetime'];\n  readonly started?: Maybe<Scalars['Datetime']>;\n  /** Reads a single `Stage` that is related to this `Computation`. */\n  readonly stageByStage?: Maybe<Stage>;\n  /** Reads a single `Guide` that is related to this `Computation`. */\n  readonly guideByGuide?: Maybe<Guide>;\n};\n\n/**\n * A condition to be used against `Computation` object types. All fields are tested\n * for equality and combined with a logical ‘and.’\n */\nexport type ComputationCondition = {\n  /** Checks for equality with the object’s `id` field. */\n  readonly id?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `ended` field. */\n  readonly ended?: Maybe<Scalars['Datetime']>;\n  /** Checks for equality with the object’s `duration` field. */\n  readonly duration?: Maybe<Scalars['Int']>;\n  /** Checks for equality with the object’s `status` field. */\n  readonly status?: Maybe<ComputationStatus>;\n  /** Checks for equality with the object’s `stage` field. */\n  readonly stage?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `guide` field. */\n  readonly guide?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `created` field. */\n  readonly created?: Maybe<Scalars['Datetime']>;\n  /** Checks for equality with the object’s `started` field. */\n  readonly started?: Maybe<Scalars['Datetime']>;\n};\n\n/** A filter to be used against `Computation` object types. All fields are combined with a logical ‘and.’ */\nexport type ComputationFilter = {\n  /** Filter by the object’s `id` field. */\n  readonly id?: Maybe<StringFilter>;\n  /** Filter by the object’s `ended` field. */\n  readonly ended?: Maybe<DatetimeFilter>;\n  /** Filter by the object’s `duration` field. */\n  readonly duration?: Maybe<IntFilter>;\n  /** Filter by the object’s `status` field. */\n  readonly status?: Maybe<ComputationStatusFilter>;\n  /** Filter by the object’s `stage` field. */\n  readonly stage?: Maybe<StringFilter>;\n  /** Filter by the object’s `guide` field. */\n  readonly guide?: Maybe<StringFilter>;\n  /** Filter by the object’s `created` field. */\n  readonly created?: Maybe<DatetimeFilter>;\n  /** Filter by the object’s `started` field. */\n  readonly started?: Maybe<DatetimeFilter>;\n  /** Checks for all expressions in this list. */\n  readonly and?: Maybe<ReadonlyArray<ComputationFilter>>;\n  /** Checks for any expressions in this list. */\n  readonly or?: Maybe<ReadonlyArray<ComputationFilter>>;\n  /** Negates the expression. */\n  readonly not?: Maybe<ComputationFilter>;\n};\n\n/** A connection to a list of `Computation` values. */\nexport type ComputationsConnection = {\n  /** A list of `Computation` objects. */\n  readonly nodes: ReadonlyArray<Maybe<Computation>>;\n  /** A list of edges which contains the `Computation` and cursor to aid in pagination. */\n  readonly edges: ReadonlyArray<ComputationsEdge>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The count of *all* `Computation` you could get from the connection. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** A `Computation` edge in the connection. */\nexport type ComputationsEdge = {\n  /** A cursor for use in pagination. */\n  readonly cursor?: Maybe<Scalars['Cursor']>;\n  /** The `Computation` at the end of the edge. */\n  readonly node?: Maybe<Computation>;\n};\n\n/** Methods to use when ordering `Computation`. */\nexport enum ComputationsOrderBy {\n  Natural = 'NATURAL',\n  IdAsc = 'ID_ASC',\n  IdDesc = 'ID_DESC',\n  EndedAsc = 'ENDED_ASC',\n  EndedDesc = 'ENDED_DESC',\n  DurationAsc = 'DURATION_ASC',\n  DurationDesc = 'DURATION_DESC',\n  StatusAsc = 'STATUS_ASC',\n  StatusDesc = 'STATUS_DESC',\n  StageAsc = 'STAGE_ASC',\n  StageDesc = 'STAGE_DESC',\n  GuideAsc = 'GUIDE_ASC',\n  GuideDesc = 'GUIDE_DESC',\n  CreatedAsc = 'CREATED_ASC',\n  CreatedDesc = 'CREATED_DESC',\n  StartedAsc = 'STARTED_ASC',\n  StartedDesc = 'STARTED_DESC',\n  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',\n  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'\n}\n\nexport enum ComputationStatus {\n  Scheduled = 'SCHEDULED',\n  Failed = 'FAILED',\n  Computing = 'COMPUTING',\n  Success = 'SUCCESS'\n}\n\n/** A filter to be used against ComputationStatus fields. All fields are combined with a logical ‘and.’ */\nexport type ComputationStatusFilter = {\n  /** Is null (if `true` is specified) or is not null (if `false` is specified). */\n  readonly isNull?: Maybe<Scalars['Boolean']>;\n  /** Equal to the specified value. */\n  readonly equalTo?: Maybe<ComputationStatus>;\n  /** Not equal to the specified value. */\n  readonly notEqualTo?: Maybe<ComputationStatus>;\n  /** Not equal to the specified value, treating null like an ordinary value. */\n  readonly distinctFrom?: Maybe<ComputationStatus>;\n  /** Equal to the specified value, treating null like an ordinary value. */\n  readonly notDistinctFrom?: Maybe<ComputationStatus>;\n  /** Included in the specified list. */\n  readonly in?: Maybe<ReadonlyArray<ComputationStatus>>;\n  /** Not included in the specified list. */\n  readonly notIn?: Maybe<ReadonlyArray<ComputationStatus>>;\n  /** Less than the specified value. */\n  readonly lessThan?: Maybe<ComputationStatus>;\n  /** Less than or equal to the specified value. */\n  readonly lessThanOrEqualTo?: Maybe<ComputationStatus>;\n  /** Greater than the specified value. */\n  readonly greaterThan?: Maybe<ComputationStatus>;\n  /** Greater than or equal to the specified value. */\n  readonly greaterThanOrEqualTo?: Maybe<ComputationStatus>;\n};\n\n/** All input for the create `FeedEvent` mutation. */\nexport type CreateFeedEventInput = {\n  /**\n   * An arbitrary string value with no semantic meaning. Will be included in the\n   * payload verbatim. May be used to track mutations by the client.\n   */\n  readonly clientMutationId?: Maybe<Scalars['String']>;\n  /** The `FeedEvent` to be created by this mutation. */\n  readonly feedEvent: FeedEventInput;\n};\n\n/** The output of our create `FeedEvent` mutation. */\nexport type CreateFeedEventPayload = {\n  /**\n   * The exact same `clientMutationId` that was provided in the mutation input,\n   * unchanged and unused. May be used by a client to track mutations.\n   */\n  readonly clientMutationId?: Maybe<Scalars['String']>;\n  /** The `FeedEvent` that was created by this mutation. */\n  readonly feedEvent?: Maybe<FeedEvent>;\n  /** Our root query field type. Allows us to run any query from our mutation payload. */\n  readonly query?: Maybe<Query>;\n  /** Reads a single `Ride` that is related to this `FeedEvent`. */\n  readonly rideByRide?: Maybe<Ride>;\n  /** Reads a single `Guide` that is related to this `FeedEvent`. */\n  readonly guideByGuide?: Maybe<Guide>;\n  /** Reads a single `User` that is related to this `FeedEvent`. */\n  readonly userByUser?: Maybe<User>;\n  /** An edge for our `FeedEvent`. May be used by Relay 1. */\n  readonly feedEventEdge?: Maybe<FeedEventsEdge>;\n};\n\n\n/** The output of our create `FeedEvent` mutation. */\nexport type CreateFeedEventPayloadFeedEventEdgeArgs = {\n  orderBy?: Maybe<ReadonlyArray<FeedEventsOrderBy>>;\n};\n\nexport type CreateGuideInput = {\n  readonly title: Scalars['String'];\n  readonly isCircular?: Maybe<Scalars['Boolean']>;\n  readonly maxHoursPerRide: Scalars['Int'];\n  readonly type: TransportType;\n  readonly startDate?: Maybe<Scalars['String']>;\n};\n\nexport type CreateGuideResult = {\n  readonly success: Scalars['Boolean'];\n  readonly message?: Maybe<Scalars['String']>;\n  readonly guideId?: Maybe<Scalars['String']>;\n};\n\n/** All input for the create `User` mutation. */\nexport type CreateUserInput = {\n  /**\n   * An arbitrary string value with no semantic meaning. Will be included in the\n   * payload verbatim. May be used to track mutations by the client.\n   */\n  readonly clientMutationId?: Maybe<Scalars['String']>;\n  /** The `User` to be created by this mutation. */\n  readonly user: UserInput;\n};\n\n/** The output of our create `User` mutation. */\nexport type CreateUserPayload = {\n  /**\n   * The exact same `clientMutationId` that was provided in the mutation input,\n   * unchanged and unused. May be used by a client to track mutations.\n   */\n  readonly clientMutationId?: Maybe<Scalars['String']>;\n  /** The `User` that was created by this mutation. */\n  readonly user?: Maybe<User>;\n  /** Our root query field type. Allows us to run any query from our mutation payload. */\n  readonly query?: Maybe<Query>;\n  /** An edge for our `User`. May be used by Relay 1. */\n  readonly userEdge?: Maybe<UsersEdge>;\n};\n\n\n/** The output of our create `User` mutation. */\nexport type CreateUserPayloadUserEdgeArgs = {\n  orderBy?: Maybe<ReadonlyArray<UsersOrderBy>>;\n};\n\n\n\n/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */\nexport type DatetimeFilter = {\n  /** Is null (if `true` is specified) or is not null (if `false` is specified). */\n  readonly isNull?: Maybe<Scalars['Boolean']>;\n  /** Equal to the specified value. */\n  readonly equalTo?: Maybe<Scalars['Datetime']>;\n  /** Not equal to the specified value. */\n  readonly notEqualTo?: Maybe<Scalars['Datetime']>;\n  /** Not equal to the specified value, treating null like an ordinary value. */\n  readonly distinctFrom?: Maybe<Scalars['Datetime']>;\n  /** Equal to the specified value, treating null like an ordinary value. */\n  readonly notDistinctFrom?: Maybe<Scalars['Datetime']>;\n  /** Included in the specified list. */\n  readonly in?: Maybe<ReadonlyArray<Scalars['Datetime']>>;\n  /** Not included in the specified list. */\n  readonly notIn?: Maybe<ReadonlyArray<Scalars['Datetime']>>;\n  /** Less than the specified value. */\n  readonly lessThan?: Maybe<Scalars['Datetime']>;\n  /** Less than or equal to the specified value. */\n  readonly lessThanOrEqualTo?: Maybe<Scalars['Datetime']>;\n  /** Greater than the specified value. */\n  readonly greaterThan?: Maybe<Scalars['Datetime']>;\n  /** Greater than or equal to the specified value. */\n  readonly greaterThanOrEqualTo?: Maybe<Scalars['Datetime']>;\n};\n\n/** All input for the `deleteFeedEventByNodeId` mutation. */\nexport type DeleteFeedEventByNodeIdInput = {\n  /**\n   * An arbitrary string value with no semantic meaning. Will be included in the\n   * payload verbatim. May be used to track mutations by the client.\n   */\n  readonly clientMutationId?: Maybe<Scalars['String']>;\n  /** The globally unique `ID` which will identify a single `FeedEvent` to be deleted. */\n  readonly nodeId: Scalars['ID'];\n};\n\n/** All input for the `deleteFeedEvent` mutation. */\nexport type DeleteFeedEventInput = {\n  /**\n   * An arbitrary string value with no semantic meaning. Will be included in the\n   * payload verbatim. May be used to track mutations by the client.\n   */\n  readonly clientMutationId?: Maybe<Scalars['String']>;\n  readonly timestamp: Scalars['Datetime'];\n};\n\n/** The output of our delete `FeedEvent` mutation. */\nexport type DeleteFeedEventPayload = {\n  /**\n   * The exact same `clientMutationId` that was provided in the mutation input,\n   * unchanged and unused. May be used by a client to track mutations.\n   */\n  readonly clientMutationId?: Maybe<Scalars['String']>;\n  /** The `FeedEvent` that was deleted by this mutation. */\n  readonly feedEvent?: Maybe<FeedEvent>;\n  readonly deletedFeedEventNodeId?: Maybe<Scalars['ID']>;\n  /** Our root query field type. Allows us to run any query from our mutation payload. */\n  readonly query?: Maybe<Query>;\n  /** Reads a single `Ride` that is related to this `FeedEvent`. */\n  readonly rideByRide?: Maybe<Ride>;\n  /** Reads a single `Guide` that is related to this `FeedEvent`. */\n  readonly guideByGuide?: Maybe<Guide>;\n  /** Reads a single `User` that is related to this `FeedEvent`. */\n  readonly userByUser?: Maybe<User>;\n  /** An edge for our `FeedEvent`. May be used by Relay 1. */\n  readonly feedEventEdge?: Maybe<FeedEventsEdge>;\n};\n\n\n/** The output of our delete `FeedEvent` mutation. */\nexport type DeleteFeedEventPayloadFeedEventEdgeArgs = {\n  orderBy?: Maybe<ReadonlyArray<FeedEventsOrderBy>>;\n};\n\nexport type DeleteGuideInput = {\n  readonly id: Scalars['String'];\n};\n\nexport type DeleteGuideResult = {\n  readonly success: Scalars['Boolean'];\n  readonly message?: Maybe<Scalars['String']>;\n};\n\nexport type FeedEvent = Node & {\n  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */\n  readonly nodeId: Scalars['ID'];\n  readonly timestamp: Scalars['Datetime'];\n  readonly type: FeedEventType;\n  readonly ride?: Maybe<Scalars['String']>;\n  readonly guide?: Maybe<Scalars['String']>;\n  readonly user?: Maybe<Scalars['String']>;\n  /** Reads a single `Ride` that is related to this `FeedEvent`. */\n  readonly rideByRide?: Maybe<Ride>;\n  /** Reads a single `Guide` that is related to this `FeedEvent`. */\n  readonly guideByGuide?: Maybe<Guide>;\n  /** Reads a single `User` that is related to this `FeedEvent`. */\n  readonly userByUser?: Maybe<User>;\n};\n\n/**\n * A condition to be used against `FeedEvent` object types. All fields are tested\n * for equality and combined with a logical ‘and.’\n */\nexport type FeedEventCondition = {\n  /** Checks for equality with the object’s `timestamp` field. */\n  readonly timestamp?: Maybe<Scalars['Datetime']>;\n  /** Checks for equality with the object’s `type` field. */\n  readonly type?: Maybe<FeedEventType>;\n  /** Checks for equality with the object’s `ride` field. */\n  readonly ride?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `guide` field. */\n  readonly guide?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `user` field. */\n  readonly user?: Maybe<Scalars['String']>;\n};\n\n/** A filter to be used against `FeedEvent` object types. All fields are combined with a logical ‘and.’ */\nexport type FeedEventFilter = {\n  /** Filter by the object’s `timestamp` field. */\n  readonly timestamp?: Maybe<DatetimeFilter>;\n  /** Filter by the object’s `type` field. */\n  readonly type?: Maybe<FeedEventTypeFilter>;\n  /** Filter by the object’s `ride` field. */\n  readonly ride?: Maybe<StringFilter>;\n  /** Filter by the object’s `guide` field. */\n  readonly guide?: Maybe<StringFilter>;\n  /** Filter by the object’s `user` field. */\n  readonly user?: Maybe<StringFilter>;\n  /** Checks for all expressions in this list. */\n  readonly and?: Maybe<ReadonlyArray<FeedEventFilter>>;\n  /** Checks for any expressions in this list. */\n  readonly or?: Maybe<ReadonlyArray<FeedEventFilter>>;\n  /** Negates the expression. */\n  readonly not?: Maybe<FeedEventFilter>;\n};\n\n/** An input for mutations affecting `FeedEvent` */\nexport type FeedEventInput = {\n  readonly timestamp: Scalars['Datetime'];\n  readonly type: FeedEventType;\n  readonly ride?: Maybe<Scalars['String']>;\n  readonly guide?: Maybe<Scalars['String']>;\n  readonly user?: Maybe<Scalars['String']>;\n};\n\n/** Represents an update to a `FeedEvent`. Fields that are set will be updated. */\nexport type FeedEventPatch = {\n  readonly timestamp?: Maybe<Scalars['Datetime']>;\n  readonly type?: Maybe<FeedEventType>;\n  readonly ride?: Maybe<Scalars['String']>;\n  readonly guide?: Maybe<Scalars['String']>;\n  readonly user?: Maybe<Scalars['String']>;\n};\n\n/** A connection to a list of `FeedEvent` values. */\nexport type FeedEventsConnection = {\n  /** A list of `FeedEvent` objects. */\n  readonly nodes: ReadonlyArray<Maybe<FeedEvent>>;\n  /** A list of edges which contains the `FeedEvent` and cursor to aid in pagination. */\n  readonly edges: ReadonlyArray<FeedEventsEdge>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The count of *all* `FeedEvent` you could get from the connection. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** A `FeedEvent` edge in the connection. */\nexport type FeedEventsEdge = {\n  /** A cursor for use in pagination. */\n  readonly cursor?: Maybe<Scalars['Cursor']>;\n  /** The `FeedEvent` at the end of the edge. */\n  readonly node?: Maybe<FeedEvent>;\n};\n\n/** Methods to use when ordering `FeedEvent`. */\nexport enum FeedEventsOrderBy {\n  Natural = 'NATURAL',\n  TimestampAsc = 'TIMESTAMP_ASC',\n  TimestampDesc = 'TIMESTAMP_DESC',\n  TypeAsc = 'TYPE_ASC',\n  TypeDesc = 'TYPE_DESC',\n  RideAsc = 'RIDE_ASC',\n  RideDesc = 'RIDE_DESC',\n  GuideAsc = 'GUIDE_ASC',\n  GuideDesc = 'GUIDE_DESC',\n  UserAsc = 'USER_ASC',\n  UserDesc = 'USER_DESC',\n  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',\n  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'\n}\n\nexport enum FeedEventType {\n  NewGuide = 'NEW_GUIDE',\n  NewFollows = 'NEW_FOLLOWS',\n  SelfCreated = 'SELF_CREATED'\n}\n\n/** A filter to be used against FeedEventType fields. All fields are combined with a logical ‘and.’ */\nexport type FeedEventTypeFilter = {\n  /** Is null (if `true` is specified) or is not null (if `false` is specified). */\n  readonly isNull?: Maybe<Scalars['Boolean']>;\n  /** Equal to the specified value. */\n  readonly equalTo?: Maybe<FeedEventType>;\n  /** Not equal to the specified value. */\n  readonly notEqualTo?: Maybe<FeedEventType>;\n  /** Not equal to the specified value, treating null like an ordinary value. */\n  readonly distinctFrom?: Maybe<FeedEventType>;\n  /** Equal to the specified value, treating null like an ordinary value. */\n  readonly notDistinctFrom?: Maybe<FeedEventType>;\n  /** Included in the specified list. */\n  readonly in?: Maybe<ReadonlyArray<FeedEventType>>;\n  /** Not included in the specified list. */\n  readonly notIn?: Maybe<ReadonlyArray<FeedEventType>>;\n  /** Less than the specified value. */\n  readonly lessThan?: Maybe<FeedEventType>;\n  /** Less than or equal to the specified value. */\n  readonly lessThanOrEqualTo?: Maybe<FeedEventType>;\n  /** Greater than the specified value. */\n  readonly greaterThan?: Maybe<FeedEventType>;\n  /** Greater than or equal to the specified value. */\n  readonly greaterThanOrEqualTo?: Maybe<FeedEventType>;\n};\n\n/** A filter to be used against Float fields. All fields are combined with a logical ‘and.’ */\nexport type FloatFilter = {\n  /** Is null (if `true` is specified) or is not null (if `false` is specified). */\n  readonly isNull?: Maybe<Scalars['Boolean']>;\n  /** Equal to the specified value. */\n  readonly equalTo?: Maybe<Scalars['Float']>;\n  /** Not equal to the specified value. */\n  readonly notEqualTo?: Maybe<Scalars['Float']>;\n  /** Not equal to the specified value, treating null like an ordinary value. */\n  readonly distinctFrom?: Maybe<Scalars['Float']>;\n  /** Equal to the specified value, treating null like an ordinary value. */\n  readonly notDistinctFrom?: Maybe<Scalars['Float']>;\n  /** Included in the specified list. */\n  readonly in?: Maybe<ReadonlyArray<Scalars['Float']>>;\n  /** Not included in the specified list. */\n  readonly notIn?: Maybe<ReadonlyArray<Scalars['Float']>>;\n  /** Less than the specified value. */\n  readonly lessThan?: Maybe<Scalars['Float']>;\n  /** Less than or equal to the specified value. */\n  readonly lessThanOrEqualTo?: Maybe<Scalars['Float']>;\n  /** Greater than the specified value. */\n  readonly greaterThan?: Maybe<Scalars['Float']>;\n  /** Greater than or equal to the specified value. */\n  readonly greaterThanOrEqualTo?: Maybe<Scalars['Float']>;\n};\n\nexport type Follow = {\n  readonly followed: Scalars['String'];\n  readonly follower: Scalars['String'];\n  readonly timestamp: Scalars['Datetime'];\n  /** Reads a single `User` that is related to this `Follow`. */\n  readonly userByFollowed?: Maybe<User>;\n  /** Reads a single `User` that is related to this `Follow`. */\n  readonly userByFollower?: Maybe<User>;\n};\n\n/** A condition to be used against `Follow` object types. All fields are tested for equality and combined with a logical ‘and.’ */\nexport type FollowCondition = {\n  /** Checks for equality with the object’s `followed` field. */\n  readonly followed?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `follower` field. */\n  readonly follower?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `timestamp` field. */\n  readonly timestamp?: Maybe<Scalars['Datetime']>;\n};\n\n/** A filter to be used against `Follow` object types. All fields are combined with a logical ‘and.’ */\nexport type FollowFilter = {\n  /** Filter by the object’s `followed` field. */\n  readonly followed?: Maybe<StringFilter>;\n  /** Filter by the object’s `follower` field. */\n  readonly follower?: Maybe<StringFilter>;\n  /** Filter by the object’s `timestamp` field. */\n  readonly timestamp?: Maybe<DatetimeFilter>;\n  /** Checks for all expressions in this list. */\n  readonly and?: Maybe<ReadonlyArray<FollowFilter>>;\n  /** Checks for any expressions in this list. */\n  readonly or?: Maybe<ReadonlyArray<FollowFilter>>;\n  /** Negates the expression. */\n  readonly not?: Maybe<FollowFilter>;\n};\n\nexport enum FollowingStatus {\n  Following = 'FOLLOWING',\n  IsSelf = 'IS_SELF',\n  NotFollowing = 'NOT_FOLLOWING',\n  Anonymous = 'ANONYMOUS'\n}\n\n/** A filter to be used against FollowingStatus fields. All fields are combined with a logical ‘and.’ */\nexport type FollowingStatusFilter = {\n  /** Is null (if `true` is specified) or is not null (if `false` is specified). */\n  readonly isNull?: Maybe<Scalars['Boolean']>;\n  /** Equal to the specified value. */\n  readonly equalTo?: Maybe<FollowingStatus>;\n  /** Not equal to the specified value. */\n  readonly notEqualTo?: Maybe<FollowingStatus>;\n  /** Not equal to the specified value, treating null like an ordinary value. */\n  readonly distinctFrom?: Maybe<FollowingStatus>;\n  /** Equal to the specified value, treating null like an ordinary value. */\n  readonly notDistinctFrom?: Maybe<FollowingStatus>;\n  /** Included in the specified list. */\n  readonly in?: Maybe<ReadonlyArray<FollowingStatus>>;\n  /** Not included in the specified list. */\n  readonly notIn?: Maybe<ReadonlyArray<FollowingStatus>>;\n  /** Less than the specified value. */\n  readonly lessThan?: Maybe<FollowingStatus>;\n  /** Less than or equal to the specified value. */\n  readonly lessThanOrEqualTo?: Maybe<FollowingStatus>;\n  /** Greater than the specified value. */\n  readonly greaterThan?: Maybe<FollowingStatus>;\n  /** Greater than or equal to the specified value. */\n  readonly greaterThanOrEqualTo?: Maybe<FollowingStatus>;\n};\n\n/** A connection to a list of `Follow` values. */\nexport type FollowsConnection = {\n  /** A list of `Follow` objects. */\n  readonly nodes: ReadonlyArray<Maybe<Follow>>;\n  /** A list of edges which contains the `Follow` and cursor to aid in pagination. */\n  readonly edges: ReadonlyArray<FollowsEdge>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The count of *all* `Follow` you could get from the connection. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** A `Follow` edge in the connection. */\nexport type FollowsEdge = {\n  /** A cursor for use in pagination. */\n  readonly cursor?: Maybe<Scalars['Cursor']>;\n  /** The `Follow` at the end of the edge. */\n  readonly node?: Maybe<Follow>;\n};\n\n/** Methods to use when ordering `Follow`. */\nexport enum FollowsOrderBy {\n  Natural = 'NATURAL',\n  FollowedAsc = 'FOLLOWED_ASC',\n  FollowedDesc = 'FOLLOWED_DESC',\n  FollowerAsc = 'FOLLOWER_ASC',\n  FollowerDesc = 'FOLLOWER_DESC',\n  TimestampAsc = 'TIMESTAMP_ASC',\n  TimestampDesc = 'TIMESTAMP_DESC'\n}\n\nexport type Geocode = {\n  readonly countryCode: Scalars['String'];\n  readonly latitude: Scalars['Float'];\n  readonly longitude: Scalars['Float'];\n  readonly label: Scalars['String'];\n};\n\nexport type GeocodeResponse = {\n  readonly success: Scalars['Boolean'];\n  readonly geocodes?: Maybe<ReadonlyArray<Maybe<Geocode>>>;\n};\n\nexport type Guide = Node & {\n  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */\n  readonly nodeId: Scalars['ID'];\n  readonly id: Scalars['String'];\n  readonly title: Scalars['String'];\n  readonly slug: Scalars['String'];\n  readonly owner: Scalars['String'];\n  readonly startDate?: Maybe<Scalars['String']>;\n  readonly isCircular: Scalars['Boolean'];\n  readonly transportType: TransportType;\n  readonly maxHoursPerRide: Scalars['Int'];\n  readonly created: Scalars['Datetime'];\n  readonly updated?: Maybe<Scalars['Datetime']>;\n  /** Reads a single `User` that is related to this `Guide`. */\n  readonly userByOwner?: Maybe<User>;\n  /** Reads and enables pagination through a set of `Spot`. */\n  readonly spotsByGuide: SpotsConnection;\n  /** Reads and enables pagination through a set of `Stage`. */\n  readonly stagesByGuide: StagesConnection;\n  /** Reads and enables pagination through a set of `Ride`. */\n  readonly ridesByGuide: RidesConnection;\n  /** Reads and enables pagination through a set of `Computation`. */\n  readonly computationsByGuide: ComputationsConnection;\n  /** Reads and enables pagination through a set of `FeedEvent`. */\n  readonly feedEventsByGuide: FeedEventsConnection;\n  readonly bounds?: Maybe<Bound>;\n  readonly countries?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;\n  readonly distanceMeters?: Maybe<Scalars['BigInt']>;\n  readonly durationSeconds?: Maybe<Scalars['BigInt']>;\n  readonly endDate?: Maybe<Scalars['String']>;\n  readonly isMine?: Maybe<Scalars['Boolean']>;\n};\n\n\nexport type GuideSpotsByGuideArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<SpotsOrderBy>>;\n  condition?: Maybe<SpotCondition>;\n  filter?: Maybe<SpotFilter>;\n};\n\n\nexport type GuideStagesByGuideArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<StagesOrderBy>>;\n  condition?: Maybe<StageCondition>;\n  filter?: Maybe<StageFilter>;\n};\n\n\nexport type GuideRidesByGuideArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<RidesOrderBy>>;\n  condition?: Maybe<RideCondition>;\n  filter?: Maybe<RideFilter>;\n};\n\n\nexport type GuideComputationsByGuideArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<ComputationsOrderBy>>;\n  condition?: Maybe<ComputationCondition>;\n  filter?: Maybe<ComputationFilter>;\n};\n\n\nexport type GuideFeedEventsByGuideArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<FeedEventsOrderBy>>;\n  condition?: Maybe<FeedEventCondition>;\n  filter?: Maybe<FeedEventFilter>;\n};\n\n/** A condition to be used against `Guide` object types. All fields are tested for equality and combined with a logical ‘and.’ */\nexport type GuideCondition = {\n  /** Checks for equality with the object’s `id` field. */\n  readonly id?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `title` field. */\n  readonly title?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `slug` field. */\n  readonly slug?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `owner` field. */\n  readonly owner?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `startDate` field. */\n  readonly startDate?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `isCircular` field. */\n  readonly isCircular?: Maybe<Scalars['Boolean']>;\n  /** Checks for equality with the object’s `transportType` field. */\n  readonly transportType?: Maybe<TransportType>;\n  /** Checks for equality with the object’s `maxHoursPerRide` field. */\n  readonly maxHoursPerRide?: Maybe<Scalars['Int']>;\n  /** Checks for equality with the object’s `created` field. */\n  readonly created?: Maybe<Scalars['Datetime']>;\n  /** Checks for equality with the object’s `updated` field. */\n  readonly updated?: Maybe<Scalars['Datetime']>;\n};\n\n/** A filter to be used against `Guide` object types. All fields are combined with a logical ‘and.’ */\nexport type GuideFilter = {\n  /** Filter by the object’s `id` field. */\n  readonly id?: Maybe<StringFilter>;\n  /** Filter by the object’s `title` field. */\n  readonly title?: Maybe<StringFilter>;\n  /** Filter by the object’s `slug` field. */\n  readonly slug?: Maybe<StringFilter>;\n  /** Filter by the object’s `owner` field. */\n  readonly owner?: Maybe<StringFilter>;\n  /** Filter by the object’s `startDate` field. */\n  readonly startDate?: Maybe<StringFilter>;\n  /** Filter by the object’s `isCircular` field. */\n  readonly isCircular?: Maybe<BooleanFilter>;\n  /** Filter by the object’s `transportType` field. */\n  readonly transportType?: Maybe<TransportTypeFilter>;\n  /** Filter by the object’s `maxHoursPerRide` field. */\n  readonly maxHoursPerRide?: Maybe<IntFilter>;\n  /** Filter by the object’s `created` field. */\n  readonly created?: Maybe<DatetimeFilter>;\n  /** Filter by the object’s `updated` field. */\n  readonly updated?: Maybe<DatetimeFilter>;\n  /** Filter by the object’s `countries` field. */\n  readonly countries?: Maybe<StringListFilter>;\n  /** Filter by the object’s `distanceMeters` field. */\n  readonly distanceMeters?: Maybe<BigIntFilter>;\n  /** Filter by the object’s `durationSeconds` field. */\n  readonly durationSeconds?: Maybe<BigIntFilter>;\n  /** Filter by the object’s `endDate` field. */\n  readonly endDate?: Maybe<StringFilter>;\n  /** Filter by the object’s `isMine` field. */\n  readonly isMine?: Maybe<BooleanFilter>;\n  /** Checks for all expressions in this list. */\n  readonly and?: Maybe<ReadonlyArray<GuideFilter>>;\n  /** Checks for any expressions in this list. */\n  readonly or?: Maybe<ReadonlyArray<GuideFilter>>;\n  /** Negates the expression. */\n  readonly not?: Maybe<GuideFilter>;\n};\n\n/** A connection to a list of `Guide` values. */\nexport type GuidesConnection = {\n  /** A list of `Guide` objects. */\n  readonly nodes: ReadonlyArray<Maybe<Guide>>;\n  /** A list of edges which contains the `Guide` and cursor to aid in pagination. */\n  readonly edges: ReadonlyArray<GuidesEdge>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The count of *all* `Guide` you could get from the connection. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** A `Guide` edge in the connection. */\nexport type GuidesEdge = {\n  /** A cursor for use in pagination. */\n  readonly cursor?: Maybe<Scalars['Cursor']>;\n  /** The `Guide` at the end of the edge. */\n  readonly node?: Maybe<Guide>;\n};\n\n/** Methods to use when ordering `Guide`. */\nexport enum GuidesOrderBy {\n  Natural = 'NATURAL',\n  IdAsc = 'ID_ASC',\n  IdDesc = 'ID_DESC',\n  TitleAsc = 'TITLE_ASC',\n  TitleDesc = 'TITLE_DESC',\n  SlugAsc = 'SLUG_ASC',\n  SlugDesc = 'SLUG_DESC',\n  OwnerAsc = 'OWNER_ASC',\n  OwnerDesc = 'OWNER_DESC',\n  StartDateAsc = 'START_DATE_ASC',\n  StartDateDesc = 'START_DATE_DESC',\n  IsCircularAsc = 'IS_CIRCULAR_ASC',\n  IsCircularDesc = 'IS_CIRCULAR_DESC',\n  TransportTypeAsc = 'TRANSPORT_TYPE_ASC',\n  TransportTypeDesc = 'TRANSPORT_TYPE_DESC',\n  MaxHoursPerRideAsc = 'MAX_HOURS_PER_RIDE_ASC',\n  MaxHoursPerRideDesc = 'MAX_HOURS_PER_RIDE_DESC',\n  CreatedAsc = 'CREATED_ASC',\n  CreatedDesc = 'CREATED_DESC',\n  UpdatedAsc = 'UPDATED_ASC',\n  UpdatedDesc = 'UPDATED_DESC',\n  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',\n  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'\n}\n\n/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */\nexport type IntFilter = {\n  /** Is null (if `true` is specified) or is not null (if `false` is specified). */\n  readonly isNull?: Maybe<Scalars['Boolean']>;\n  /** Equal to the specified value. */\n  readonly equalTo?: Maybe<Scalars['Int']>;\n  /** Not equal to the specified value. */\n  readonly notEqualTo?: Maybe<Scalars['Int']>;\n  /** Not equal to the specified value, treating null like an ordinary value. */\n  readonly distinctFrom?: Maybe<Scalars['Int']>;\n  /** Equal to the specified value, treating null like an ordinary value. */\n  readonly notDistinctFrom?: Maybe<Scalars['Int']>;\n  /** Included in the specified list. */\n  readonly in?: Maybe<ReadonlyArray<Scalars['Int']>>;\n  /** Not included in the specified list. */\n  readonly notIn?: Maybe<ReadonlyArray<Scalars['Int']>>;\n  /** Less than the specified value. */\n  readonly lessThan?: Maybe<Scalars['Int']>;\n  /** Less than or equal to the specified value. */\n  readonly lessThanOrEqualTo?: Maybe<Scalars['Int']>;\n  /** Greater than the specified value. */\n  readonly greaterThan?: Maybe<Scalars['Int']>;\n  /** Greater than or equal to the specified value. */\n  readonly greaterThanOrEqualTo?: Maybe<Scalars['Int']>;\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type Mutation = {\n  /** Creates a single `FeedEvent`. */\n  readonly createFeedEvent?: Maybe<CreateFeedEventPayload>;\n  /** Creates a single `User`. */\n  readonly createUser?: Maybe<CreateUserPayload>;\n  /** Updates a single `FeedEvent` using its globally unique id and a patch. */\n  readonly updateFeedEventByNodeId?: Maybe<UpdateFeedEventPayload>;\n  /** Updates a single `FeedEvent` using a unique key and a patch. */\n  readonly updateFeedEvent?: Maybe<UpdateFeedEventPayload>;\n  /** Deletes a single `FeedEvent` using its globally unique id. */\n  readonly deleteFeedEventByNodeId?: Maybe<DeleteFeedEventPayload>;\n  /** Deletes a single `FeedEvent` using a unique key. */\n  readonly deleteFeedEvent?: Maybe<DeleteFeedEventPayload>;\n  /** Creates a JWT token that will securely identify a person and give them certain permissions. This token expires in 2 days. */\n  readonly authenticate?: Maybe<AuthenticatePayload>;\n  /** Registers a single user */\n  readonly register?: Maybe<RegisterPayload>;\n  readonly createGuide: CreateGuideResult;\n  readonly updateGuide: UpdateGuideResult;\n  readonly deleteGuide: DeleteGuideResult;\n  readonly followUser: Result;\n  readonly unfollowUser: Result;\n  readonly addSpot: AddSpotResult;\n  readonly updateSpot: UpdateSpotResult;\n  readonly remvoeSpot: RemoveSpotResult;\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type MutationCreateFeedEventArgs = {\n  input: CreateFeedEventInput;\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type MutationCreateUserArgs = {\n  input: CreateUserInput;\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type MutationUpdateFeedEventByNodeIdArgs = {\n  input: UpdateFeedEventByNodeIdInput;\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type MutationUpdateFeedEventArgs = {\n  input: UpdateFeedEventInput;\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type MutationDeleteFeedEventByNodeIdArgs = {\n  input: DeleteFeedEventByNodeIdInput;\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type MutationDeleteFeedEventArgs = {\n  input: DeleteFeedEventInput;\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type MutationAuthenticateArgs = {\n  input: AuthenticateInput;\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type MutationRegisterArgs = {\n  input: RegisterInput;\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type MutationCreateGuideArgs = {\n  input?: Maybe<CreateGuideInput>;\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type MutationUpdateGuideArgs = {\n  input?: Maybe<UpdateGuidePatch>;\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type MutationDeleteGuideArgs = {\n  input?: Maybe<DeleteGuideInput>;\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type MutationFollowUserArgs = {\n  username: Scalars['String'];\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type MutationUnfollowUserArgs = {\n  username: Scalars['String'];\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type MutationAddSpotArgs = {\n  input: AddSpotInput;\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type MutationUpdateSpotArgs = {\n  input: UpdateSpotPatch;\n};\n\n\n/** The root mutation type which contains root level fields which mutate data. */\nexport type MutationRemvoeSpotArgs = {\n  input: RemoveSpotInput;\n};\n\n/** An object with a globally unique `ID`. */\nexport type Node = {\n  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */\n  readonly nodeId: Scalars['ID'];\n};\n\n/** Information about pagination in a connection. */\nexport type PageInfo = {\n  /** When paginating forwards, are there more items? */\n  readonly hasNextPage: Scalars['Boolean'];\n  /** When paginating backwards, are there more items? */\n  readonly hasPreviousPage: Scalars['Boolean'];\n  /** When paginating backwards, the cursor to continue. */\n  readonly startCursor?: Maybe<Scalars['Cursor']>;\n  /** When paginating forwards, the cursor to continue. */\n  readonly endCursor?: Maybe<Scalars['Cursor']>;\n};\n\n/** The root query type which gives access points into the data universe. */\nexport type Query = Node & {\n  /**\n   * Exposes the root query type nested one level down. This is helpful for Relay 1\n   * which can only query top level fields if they are in a particular form.\n   */\n  readonly query: Query;\n  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */\n  readonly nodeId: Scalars['ID'];\n  /** Fetches an object given its globally unique `ID`. */\n  readonly node?: Maybe<Node>;\n  /** Reads and enables pagination through a set of `Computation`. */\n  readonly computations?: Maybe<ComputationsConnection>;\n  /** Reads and enables pagination through a set of `FeedEvent`. */\n  readonly feedEvents?: Maybe<FeedEventsConnection>;\n  /** Reads and enables pagination through a set of `Follow`. */\n  readonly follows?: Maybe<FollowsConnection>;\n  /** Reads and enables pagination through a set of `Guide`. */\n  readonly guides?: Maybe<GuidesConnection>;\n  /** Reads and enables pagination through a set of `Ride`. */\n  readonly rides?: Maybe<RidesConnection>;\n  /** Reads and enables pagination through a set of `Spot`. */\n  readonly spots?: Maybe<SpotsConnection>;\n  /** Reads and enables pagination through a set of `Stage`. */\n  readonly stages?: Maybe<StagesConnection>;\n  /** Reads and enables pagination through a set of `Temperature`. */\n  readonly temperatures?: Maybe<TemperaturesConnection>;\n  /** Reads and enables pagination through a set of `User`. */\n  readonly users?: Maybe<UsersConnection>;\n  readonly computation?: Maybe<Computation>;\n  readonly feedEvent?: Maybe<FeedEvent>;\n  readonly guide?: Maybe<Guide>;\n  readonly ride?: Maybe<Ride>;\n  readonly spot?: Maybe<Spot>;\n  readonly stage?: Maybe<Stage>;\n  readonly temperature?: Maybe<Temperature>;\n  readonly user?: Maybe<User>;\n  readonly countries?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;\n  /** Reads and enables pagination through a set of `FeedEvent`. */\n  readonly feed: FeedEventsConnection;\n  readonly getCurrentUser?: Maybe<Scalars['JwtToken']>;\n  /** Reads a single `Computation` using its globally unique `ID`. */\n  readonly computationByNodeId?: Maybe<Computation>;\n  /** Reads a single `FeedEvent` using its globally unique `ID`. */\n  readonly feedEventByNodeId?: Maybe<FeedEvent>;\n  /** Reads a single `Guide` using its globally unique `ID`. */\n  readonly guideByNodeId?: Maybe<Guide>;\n  /** Reads a single `Ride` using its globally unique `ID`. */\n  readonly rideByNodeId?: Maybe<Ride>;\n  /** Reads a single `Spot` using its globally unique `ID`. */\n  readonly spotByNodeId?: Maybe<Spot>;\n  /** Reads a single `Stage` using its globally unique `ID`. */\n  readonly stageByNodeId?: Maybe<Stage>;\n  /** Reads a single `Temperature` using its globally unique `ID`. */\n  readonly temperatureByNodeId?: Maybe<Temperature>;\n  /** Reads a single `User` using its globally unique `ID`. */\n  readonly userByNodeId?: Maybe<User>;\n  readonly geocode: GeocodeResponse;\n  readonly appVersion: Scalars['String'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryNodeArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryComputationsArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<ComputationsOrderBy>>;\n  condition?: Maybe<ComputationCondition>;\n  filter?: Maybe<ComputationFilter>;\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryFeedEventsArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<FeedEventsOrderBy>>;\n  condition?: Maybe<FeedEventCondition>;\n  filter?: Maybe<FeedEventFilter>;\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryFollowsArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<FollowsOrderBy>>;\n  condition?: Maybe<FollowCondition>;\n  filter?: Maybe<FollowFilter>;\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryGuidesArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<GuidesOrderBy>>;\n  condition?: Maybe<GuideCondition>;\n  filter?: Maybe<GuideFilter>;\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryRidesArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<RidesOrderBy>>;\n  condition?: Maybe<RideCondition>;\n  filter?: Maybe<RideFilter>;\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QuerySpotsArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<SpotsOrderBy>>;\n  condition?: Maybe<SpotCondition>;\n  filter?: Maybe<SpotFilter>;\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryStagesArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<StagesOrderBy>>;\n  condition?: Maybe<StageCondition>;\n  filter?: Maybe<StageFilter>;\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryTemperaturesArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<TemperaturesOrderBy>>;\n  condition?: Maybe<TemperatureCondition>;\n  filter?: Maybe<TemperatureFilter>;\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryUsersArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<UsersOrderBy>>;\n  condition?: Maybe<UserCondition>;\n  filter?: Maybe<UserFilter>;\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryComputationArgs = {\n  id: Scalars['String'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryFeedEventArgs = {\n  timestamp: Scalars['Datetime'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryGuideArgs = {\n  id: Scalars['String'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryRideArgs = {\n  id: Scalars['String'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QuerySpotArgs = {\n  id: Scalars['String'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryStageArgs = {\n  id: Scalars['String'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryTemperatureArgs = {\n  id: Scalars['String'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryUserArgs = {\n  username: Scalars['String'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryFeedArgs = {\n  _username?: Maybe<Scalars['String']>;\n  perPage?: Maybe<Scalars['Int']>;\n  pageOffset?: Maybe<Scalars['Int']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  filter?: Maybe<FeedEventFilter>;\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryComputationByNodeIdArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryFeedEventByNodeIdArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryGuideByNodeIdArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryRideByNodeIdArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QuerySpotByNodeIdArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryStageByNodeIdArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryTemperatureByNodeIdArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryUserByNodeIdArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/** The root query type which gives access points into the data universe. */\nexport type QueryGeocodeArgs = {\n  query: Scalars['String'];\n};\n\n/** All input for the `register` mutation. */\nexport type RegisterInput = {\n  /**\n   * An arbitrary string value with no semantic meaning. Will be included in the\n   * payload verbatim. May be used to track mutations by the client.\n   */\n  readonly clientMutationId?: Maybe<Scalars['String']>;\n  readonly _username: Scalars['String'];\n  readonly _email: Scalars['String'];\n  readonly _password: Scalars['String'];\n};\n\n/** The output of our `register` mutation. */\nexport type RegisterPayload = {\n  /**\n   * The exact same `clientMutationId` that was provided in the mutation input,\n   * unchanged and unused. May be used by a client to track mutations.\n   */\n  readonly clientMutationId?: Maybe<Scalars['String']>;\n  readonly user?: Maybe<User>;\n  /** Our root query field type. Allows us to run any query from our mutation payload. */\n  readonly query?: Maybe<Query>;\n  /** An edge for our `User`. May be used by Relay 1. */\n  readonly userEdge?: Maybe<UsersEdge>;\n};\n\n\n/** The output of our `register` mutation. */\nexport type RegisterPayloadUserEdgeArgs = {\n  orderBy?: Maybe<ReadonlyArray<UsersOrderBy>>;\n};\n\nexport type RemoveSpotInput = {\n  readonly id: Scalars['String'];\n};\n\nexport type RemoveSpotResult = {\n  readonly success: Scalars['Boolean'];\n  readonly message?: Maybe<Scalars['String']>;\n};\n\nexport type Result = {\n  readonly success: Scalars['Boolean'];\n  readonly message?: Maybe<Scalars['String']>;\n};\n\nexport type Ride = Node & {\n  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */\n  readonly nodeId: Scalars['ID'];\n  readonly id: Scalars['String'];\n  readonly guide: Scalars['String'];\n  readonly owner: Scalars['String'];\n  readonly fromSpot: Scalars['String'];\n  readonly toSpot: Scalars['String'];\n  readonly pathUrl?: Maybe<Scalars['String']>;\n  readonly durationSeconds?: Maybe<Scalars['Int']>;\n  readonly distanceMeters?: Maybe<Scalars['Int']>;\n  readonly date?: Maybe<Scalars['String']>;\n  readonly stage: Scalars['String'];\n  readonly position?: Maybe<Scalars['String']>;\n  readonly status: RideStatus;\n  readonly created: Scalars['Datetime'];\n  readonly updated?: Maybe<Scalars['Datetime']>;\n  /** Reads a single `Guide` that is related to this `Ride`. */\n  readonly guideByGuide?: Maybe<Guide>;\n  /** Reads a single `User` that is related to this `Ride`. */\n  readonly userByOwner?: Maybe<User>;\n  /** Reads a single `Spot` that is related to this `Ride`. */\n  readonly spotByFromSpot?: Maybe<Spot>;\n  /** Reads a single `Spot` that is related to this `Ride`. */\n  readonly spotByToSpot?: Maybe<Spot>;\n  /** Reads a single `Stage` that is related to this `Ride`. */\n  readonly stageByStage?: Maybe<Stage>;\n  /** Reads and enables pagination through a set of `FeedEvent`. */\n  readonly feedEventsByRide: FeedEventsConnection;\n  readonly countries?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;\n  readonly hasBorder?: Maybe<Scalars['Boolean']>;\n  readonly isMine?: Maybe<Scalars['Boolean']>;\n  readonly name?: Maybe<Scalars['String']>;\n};\n\n\nexport type RideFeedEventsByRideArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<FeedEventsOrderBy>>;\n  condition?: Maybe<FeedEventCondition>;\n  filter?: Maybe<FeedEventFilter>;\n};\n\n/** A condition to be used against `Ride` object types. All fields are tested for equality and combined with a logical ‘and.’ */\nexport type RideCondition = {\n  /** Checks for equality with the object’s `id` field. */\n  readonly id?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `guide` field. */\n  readonly guide?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `owner` field. */\n  readonly owner?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `fromSpot` field. */\n  readonly fromSpot?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `toSpot` field. */\n  readonly toSpot?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `pathUrl` field. */\n  readonly pathUrl?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `durationSeconds` field. */\n  readonly durationSeconds?: Maybe<Scalars['Int']>;\n  /** Checks for equality with the object’s `distanceMeters` field. */\n  readonly distanceMeters?: Maybe<Scalars['Int']>;\n  /** Checks for equality with the object’s `date` field. */\n  readonly date?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `stage` field. */\n  readonly stage?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `position` field. */\n  readonly position?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `status` field. */\n  readonly status?: Maybe<RideStatus>;\n  /** Checks for equality with the object’s `created` field. */\n  readonly created?: Maybe<Scalars['Datetime']>;\n  /** Checks for equality with the object’s `updated` field. */\n  readonly updated?: Maybe<Scalars['Datetime']>;\n};\n\n/** A filter to be used against `Ride` object types. All fields are combined with a logical ‘and.’ */\nexport type RideFilter = {\n  /** Filter by the object’s `id` field. */\n  readonly id?: Maybe<StringFilter>;\n  /** Filter by the object’s `guide` field. */\n  readonly guide?: Maybe<StringFilter>;\n  /** Filter by the object’s `owner` field. */\n  readonly owner?: Maybe<StringFilter>;\n  /** Filter by the object’s `fromSpot` field. */\n  readonly fromSpot?: Maybe<StringFilter>;\n  /** Filter by the object’s `toSpot` field. */\n  readonly toSpot?: Maybe<StringFilter>;\n  /** Filter by the object’s `pathUrl` field. */\n  readonly pathUrl?: Maybe<StringFilter>;\n  /** Filter by the object’s `durationSeconds` field. */\n  readonly durationSeconds?: Maybe<IntFilter>;\n  /** Filter by the object’s `distanceMeters` field. */\n  readonly distanceMeters?: Maybe<IntFilter>;\n  /** Filter by the object’s `date` field. */\n  readonly date?: Maybe<StringFilter>;\n  /** Filter by the object’s `stage` field. */\n  readonly stage?: Maybe<StringFilter>;\n  /** Filter by the object’s `position` field. */\n  readonly position?: Maybe<StringFilter>;\n  /** Filter by the object’s `status` field. */\n  readonly status?: Maybe<RideStatusFilter>;\n  /** Filter by the object’s `created` field. */\n  readonly created?: Maybe<DatetimeFilter>;\n  /** Filter by the object’s `updated` field. */\n  readonly updated?: Maybe<DatetimeFilter>;\n  /** Filter by the object’s `countries` field. */\n  readonly countries?: Maybe<StringListFilter>;\n  /** Filter by the object’s `hasBorder` field. */\n  readonly hasBorder?: Maybe<BooleanFilter>;\n  /** Filter by the object’s `isMine` field. */\n  readonly isMine?: Maybe<BooleanFilter>;\n  /** Filter by the object’s `name` field. */\n  readonly name?: Maybe<StringFilter>;\n  /** Checks for all expressions in this list. */\n  readonly and?: Maybe<ReadonlyArray<RideFilter>>;\n  /** Checks for any expressions in this list. */\n  readonly or?: Maybe<ReadonlyArray<RideFilter>>;\n  /** Negates the expression. */\n  readonly not?: Maybe<RideFilter>;\n};\n\n/** A connection to a list of `Ride` values. */\nexport type RidesConnection = {\n  /** A list of `Ride` objects. */\n  readonly nodes: ReadonlyArray<Maybe<Ride>>;\n  /** A list of edges which contains the `Ride` and cursor to aid in pagination. */\n  readonly edges: ReadonlyArray<RidesEdge>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The count of *all* `Ride` you could get from the connection. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** A `Ride` edge in the connection. */\nexport type RidesEdge = {\n  /** A cursor for use in pagination. */\n  readonly cursor?: Maybe<Scalars['Cursor']>;\n  /** The `Ride` at the end of the edge. */\n  readonly node?: Maybe<Ride>;\n};\n\n/** Methods to use when ordering `Ride`. */\nexport enum RidesOrderBy {\n  Natural = 'NATURAL',\n  IdAsc = 'ID_ASC',\n  IdDesc = 'ID_DESC',\n  GuideAsc = 'GUIDE_ASC',\n  GuideDesc = 'GUIDE_DESC',\n  OwnerAsc = 'OWNER_ASC',\n  OwnerDesc = 'OWNER_DESC',\n  FromSpotAsc = 'FROM_SPOT_ASC',\n  FromSpotDesc = 'FROM_SPOT_DESC',\n  ToSpotAsc = 'TO_SPOT_ASC',\n  ToSpotDesc = 'TO_SPOT_DESC',\n  PathUrlAsc = 'PATH_URL_ASC',\n  PathUrlDesc = 'PATH_URL_DESC',\n  DurationSecondsAsc = 'DURATION_SECONDS_ASC',\n  DurationSecondsDesc = 'DURATION_SECONDS_DESC',\n  DistanceMetersAsc = 'DISTANCE_METERS_ASC',\n  DistanceMetersDesc = 'DISTANCE_METERS_DESC',\n  DateAsc = 'DATE_ASC',\n  DateDesc = 'DATE_DESC',\n  StageAsc = 'STAGE_ASC',\n  StageDesc = 'STAGE_DESC',\n  PositionAsc = 'POSITION_ASC',\n  PositionDesc = 'POSITION_DESC',\n  StatusAsc = 'STATUS_ASC',\n  StatusDesc = 'STATUS_DESC',\n  CreatedAsc = 'CREATED_ASC',\n  CreatedDesc = 'CREATED_DESC',\n  UpdatedAsc = 'UPDATED_ASC',\n  UpdatedDesc = 'UPDATED_DESC',\n  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',\n  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'\n}\n\nexport enum RideStatus {\n  Complete = 'COMPLETE',\n  Ready = 'READY',\n  Stale = 'STALE'\n}\n\n/** A filter to be used against RideStatus fields. All fields are combined with a logical ‘and.’ */\nexport type RideStatusFilter = {\n  /** Is null (if `true` is specified) or is not null (if `false` is specified). */\n  readonly isNull?: Maybe<Scalars['Boolean']>;\n  /** Equal to the specified value. */\n  readonly equalTo?: Maybe<RideStatus>;\n  /** Not equal to the specified value. */\n  readonly notEqualTo?: Maybe<RideStatus>;\n  /** Not equal to the specified value, treating null like an ordinary value. */\n  readonly distinctFrom?: Maybe<RideStatus>;\n  /** Equal to the specified value, treating null like an ordinary value. */\n  readonly notDistinctFrom?: Maybe<RideStatus>;\n  /** Included in the specified list. */\n  readonly in?: Maybe<ReadonlyArray<RideStatus>>;\n  /** Not included in the specified list. */\n  readonly notIn?: Maybe<ReadonlyArray<RideStatus>>;\n  /** Less than the specified value. */\n  readonly lessThan?: Maybe<RideStatus>;\n  /** Less than or equal to the specified value. */\n  readonly lessThanOrEqualTo?: Maybe<RideStatus>;\n  /** Greater than the specified value. */\n  readonly greaterThan?: Maybe<RideStatus>;\n  /** Greater than or equal to the specified value. */\n  readonly greaterThanOrEqualTo?: Maybe<RideStatus>;\n};\n\nexport type Spot = Node & {\n  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */\n  readonly nodeId: Scalars['ID'];\n  readonly id: Scalars['String'];\n  readonly label?: Maybe<Scalars['String']>;\n  readonly guide: Scalars['String'];\n  readonly owner: Scalars['String'];\n  readonly nights?: Maybe<Scalars['Int']>;\n  readonly locked: Scalars['Boolean'];\n  readonly lat: Scalars['Float'];\n  readonly long: Scalars['Float'];\n  readonly position?: Maybe<Scalars['String']>;\n  readonly location?: Maybe<Scalars['String']>;\n  readonly country?: Maybe<Scalars['String']>;\n  readonly date?: Maybe<Scalars['String']>;\n  readonly created: Scalars['Datetime'];\n  readonly updated?: Maybe<Scalars['Datetime']>;\n  readonly stage?: Maybe<Scalars['String']>;\n  /** Reads a single `Guide` that is related to this `Spot`. */\n  readonly guideByGuide?: Maybe<Guide>;\n  /** Reads a single `User` that is related to this `Spot`. */\n  readonly userByOwner?: Maybe<User>;\n  /** Reads a single `Stage` that is related to this `Spot`. */\n  readonly stageByStage?: Maybe<Stage>;\n  /** Reads and enables pagination through a set of `Stage`. */\n  readonly stagesByFromSpot: StagesConnection;\n  /** Reads and enables pagination through a set of `Stage`. */\n  readonly stagesByToSpot: StagesConnection;\n  /** Reads and enables pagination through a set of `Ride`. */\n  readonly ridesByFromSpot: RidesConnection;\n  /** Reads and enables pagination through a set of `Ride`. */\n  readonly ridesByToSpot: RidesConnection;\n  readonly isMine?: Maybe<Scalars['Boolean']>;\n  readonly name?: Maybe<Scalars['String']>;\n  readonly temperature?: Maybe<Scalars['Float']>;\n};\n\n\nexport type SpotStagesByFromSpotArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<StagesOrderBy>>;\n  condition?: Maybe<StageCondition>;\n  filter?: Maybe<StageFilter>;\n};\n\n\nexport type SpotStagesByToSpotArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<StagesOrderBy>>;\n  condition?: Maybe<StageCondition>;\n  filter?: Maybe<StageFilter>;\n};\n\n\nexport type SpotRidesByFromSpotArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<RidesOrderBy>>;\n  condition?: Maybe<RideCondition>;\n  filter?: Maybe<RideFilter>;\n};\n\n\nexport type SpotRidesByToSpotArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<RidesOrderBy>>;\n  condition?: Maybe<RideCondition>;\n  filter?: Maybe<RideFilter>;\n};\n\n/** A condition to be used against `Spot` object types. All fields are tested for equality and combined with a logical ‘and.’ */\nexport type SpotCondition = {\n  /** Checks for equality with the object’s `id` field. */\n  readonly id?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `label` field. */\n  readonly label?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `guide` field. */\n  readonly guide?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `owner` field. */\n  readonly owner?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `nights` field. */\n  readonly nights?: Maybe<Scalars['Int']>;\n  /** Checks for equality with the object’s `locked` field. */\n  readonly locked?: Maybe<Scalars['Boolean']>;\n  /** Checks for equality with the object’s `lat` field. */\n  readonly lat?: Maybe<Scalars['Float']>;\n  /** Checks for equality with the object’s `long` field. */\n  readonly long?: Maybe<Scalars['Float']>;\n  /** Checks for equality with the object’s `position` field. */\n  readonly position?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `location` field. */\n  readonly location?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `country` field. */\n  readonly country?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `date` field. */\n  readonly date?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `created` field. */\n  readonly created?: Maybe<Scalars['Datetime']>;\n  /** Checks for equality with the object’s `updated` field. */\n  readonly updated?: Maybe<Scalars['Datetime']>;\n  /** Checks for equality with the object’s `stage` field. */\n  readonly stage?: Maybe<Scalars['String']>;\n};\n\n/** A filter to be used against `Spot` object types. All fields are combined with a logical ‘and.’ */\nexport type SpotFilter = {\n  /** Filter by the object’s `id` field. */\n  readonly id?: Maybe<StringFilter>;\n  /** Filter by the object’s `label` field. */\n  readonly label?: Maybe<StringFilter>;\n  /** Filter by the object’s `guide` field. */\n  readonly guide?: Maybe<StringFilter>;\n  /** Filter by the object’s `owner` field. */\n  readonly owner?: Maybe<StringFilter>;\n  /** Filter by the object’s `nights` field. */\n  readonly nights?: Maybe<IntFilter>;\n  /** Filter by the object’s `locked` field. */\n  readonly locked?: Maybe<BooleanFilter>;\n  /** Filter by the object’s `lat` field. */\n  readonly lat?: Maybe<FloatFilter>;\n  /** Filter by the object’s `long` field. */\n  readonly long?: Maybe<FloatFilter>;\n  /** Filter by the object’s `position` field. */\n  readonly position?: Maybe<StringFilter>;\n  /** Filter by the object’s `location` field. */\n  readonly location?: Maybe<StringFilter>;\n  /** Filter by the object’s `country` field. */\n  readonly country?: Maybe<StringFilter>;\n  /** Filter by the object’s `date` field. */\n  readonly date?: Maybe<StringFilter>;\n  /** Filter by the object’s `created` field. */\n  readonly created?: Maybe<DatetimeFilter>;\n  /** Filter by the object’s `updated` field. */\n  readonly updated?: Maybe<DatetimeFilter>;\n  /** Filter by the object’s `stage` field. */\n  readonly stage?: Maybe<StringFilter>;\n  /** Filter by the object’s `isMine` field. */\n  readonly isMine?: Maybe<BooleanFilter>;\n  /** Filter by the object’s `name` field. */\n  readonly name?: Maybe<StringFilter>;\n  /** Filter by the object’s `temperature` field. */\n  readonly temperature?: Maybe<FloatFilter>;\n  /** Checks for all expressions in this list. */\n  readonly and?: Maybe<ReadonlyArray<SpotFilter>>;\n  /** Checks for any expressions in this list. */\n  readonly or?: Maybe<ReadonlyArray<SpotFilter>>;\n  /** Negates the expression. */\n  readonly not?: Maybe<SpotFilter>;\n};\n\n/** A connection to a list of `Spot` values. */\nexport type SpotsConnection = {\n  /** A list of `Spot` objects. */\n  readonly nodes: ReadonlyArray<Maybe<Spot>>;\n  /** A list of edges which contains the `Spot` and cursor to aid in pagination. */\n  readonly edges: ReadonlyArray<SpotsEdge>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The count of *all* `Spot` you could get from the connection. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** A `Spot` edge in the connection. */\nexport type SpotsEdge = {\n  /** A cursor for use in pagination. */\n  readonly cursor?: Maybe<Scalars['Cursor']>;\n  /** The `Spot` at the end of the edge. */\n  readonly node?: Maybe<Spot>;\n};\n\n/** Methods to use when ordering `Spot`. */\nexport enum SpotsOrderBy {\n  Natural = 'NATURAL',\n  IdAsc = 'ID_ASC',\n  IdDesc = 'ID_DESC',\n  LabelAsc = 'LABEL_ASC',\n  LabelDesc = 'LABEL_DESC',\n  GuideAsc = 'GUIDE_ASC',\n  GuideDesc = 'GUIDE_DESC',\n  OwnerAsc = 'OWNER_ASC',\n  OwnerDesc = 'OWNER_DESC',\n  NightsAsc = 'NIGHTS_ASC',\n  NightsDesc = 'NIGHTS_DESC',\n  LockedAsc = 'LOCKED_ASC',\n  LockedDesc = 'LOCKED_DESC',\n  LatAsc = 'LAT_ASC',\n  LatDesc = 'LAT_DESC',\n  LongAsc = 'LONG_ASC',\n  LongDesc = 'LONG_DESC',\n  PositionAsc = 'POSITION_ASC',\n  PositionDesc = 'POSITION_DESC',\n  LocationAsc = 'LOCATION_ASC',\n  LocationDesc = 'LOCATION_DESC',\n  CountryAsc = 'COUNTRY_ASC',\n  CountryDesc = 'COUNTRY_DESC',\n  DateAsc = 'DATE_ASC',\n  DateDesc = 'DATE_DESC',\n  CreatedAsc = 'CREATED_ASC',\n  CreatedDesc = 'CREATED_DESC',\n  UpdatedAsc = 'UPDATED_ASC',\n  UpdatedDesc = 'UPDATED_DESC',\n  StageAsc = 'STAGE_ASC',\n  StageDesc = 'STAGE_DESC',\n  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',\n  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'\n}\n\nexport type Stage = Node & {\n  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */\n  readonly nodeId: Scalars['ID'];\n  readonly id: Scalars['String'];\n  readonly guide: Scalars['String'];\n  readonly fromSpot: Scalars['String'];\n  readonly toSpot: Scalars['String'];\n  readonly created: Scalars['Datetime'];\n  readonly updated?: Maybe<Scalars['Datetime']>;\n  readonly status: StageStatus;\n  readonly position?: Maybe<Scalars['Int']>;\n  /** Reads a single `Guide` that is related to this `Stage`. */\n  readonly guideByGuide?: Maybe<Guide>;\n  /** Reads a single `Spot` that is related to this `Stage`. */\n  readonly spotByFromSpot?: Maybe<Spot>;\n  /** Reads a single `Spot` that is related to this `Stage`. */\n  readonly spotByToSpot?: Maybe<Spot>;\n  /** Reads and enables pagination through a set of `Spot`. */\n  readonly spotsByStage: SpotsConnection;\n  /** Reads and enables pagination through a set of `Ride`. */\n  readonly ridesByStage: RidesConnection;\n  /** Reads and enables pagination through a set of `Computation`. */\n  readonly computationsByStage: ComputationsConnection;\n  readonly name?: Maybe<Scalars['String']>;\n};\n\n\nexport type StageSpotsByStageArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<SpotsOrderBy>>;\n  condition?: Maybe<SpotCondition>;\n  filter?: Maybe<SpotFilter>;\n};\n\n\nexport type StageRidesByStageArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<RidesOrderBy>>;\n  condition?: Maybe<RideCondition>;\n  filter?: Maybe<RideFilter>;\n};\n\n\nexport type StageComputationsByStageArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<ComputationsOrderBy>>;\n  condition?: Maybe<ComputationCondition>;\n  filter?: Maybe<ComputationFilter>;\n};\n\n/** A condition to be used against `Stage` object types. All fields are tested for equality and combined with a logical ‘and.’ */\nexport type StageCondition = {\n  /** Checks for equality with the object’s `id` field. */\n  readonly id?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `guide` field. */\n  readonly guide?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `fromSpot` field. */\n  readonly fromSpot?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `toSpot` field. */\n  readonly toSpot?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `created` field. */\n  readonly created?: Maybe<Scalars['Datetime']>;\n  /** Checks for equality with the object’s `updated` field. */\n  readonly updated?: Maybe<Scalars['Datetime']>;\n  /** Checks for equality with the object’s `status` field. */\n  readonly status?: Maybe<StageStatus>;\n  /** Checks for equality with the object’s `position` field. */\n  readonly position?: Maybe<Scalars['Int']>;\n};\n\n/** A filter to be used against `Stage` object types. All fields are combined with a logical ‘and.’ */\nexport type StageFilter = {\n  /** Filter by the object’s `id` field. */\n  readonly id?: Maybe<StringFilter>;\n  /** Filter by the object’s `guide` field. */\n  readonly guide?: Maybe<StringFilter>;\n  /** Filter by the object’s `fromSpot` field. */\n  readonly fromSpot?: Maybe<StringFilter>;\n  /** Filter by the object’s `toSpot` field. */\n  readonly toSpot?: Maybe<StringFilter>;\n  /** Filter by the object’s `created` field. */\n  readonly created?: Maybe<DatetimeFilter>;\n  /** Filter by the object’s `updated` field. */\n  readonly updated?: Maybe<DatetimeFilter>;\n  /** Filter by the object’s `status` field. */\n  readonly status?: Maybe<StageStatusFilter>;\n  /** Filter by the object’s `position` field. */\n  readonly position?: Maybe<IntFilter>;\n  /** Filter by the object’s `name` field. */\n  readonly name?: Maybe<StringFilter>;\n  /** Checks for all expressions in this list. */\n  readonly and?: Maybe<ReadonlyArray<StageFilter>>;\n  /** Checks for any expressions in this list. */\n  readonly or?: Maybe<ReadonlyArray<StageFilter>>;\n  /** Negates the expression. */\n  readonly not?: Maybe<StageFilter>;\n};\n\n/** A connection to a list of `Stage` values. */\nexport type StagesConnection = {\n  /** A list of `Stage` objects. */\n  readonly nodes: ReadonlyArray<Maybe<Stage>>;\n  /** A list of edges which contains the `Stage` and cursor to aid in pagination. */\n  readonly edges: ReadonlyArray<StagesEdge>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The count of *all* `Stage` you could get from the connection. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** A `Stage` edge in the connection. */\nexport type StagesEdge = {\n  /** A cursor for use in pagination. */\n  readonly cursor?: Maybe<Scalars['Cursor']>;\n  /** The `Stage` at the end of the edge. */\n  readonly node?: Maybe<Stage>;\n};\n\n/** Methods to use when ordering `Stage`. */\nexport enum StagesOrderBy {\n  Natural = 'NATURAL',\n  IdAsc = 'ID_ASC',\n  IdDesc = 'ID_DESC',\n  GuideAsc = 'GUIDE_ASC',\n  GuideDesc = 'GUIDE_DESC',\n  FromSpotAsc = 'FROM_SPOT_ASC',\n  FromSpotDesc = 'FROM_SPOT_DESC',\n  ToSpotAsc = 'TO_SPOT_ASC',\n  ToSpotDesc = 'TO_SPOT_DESC',\n  CreatedAsc = 'CREATED_ASC',\n  CreatedDesc = 'CREATED_DESC',\n  UpdatedAsc = 'UPDATED_ASC',\n  UpdatedDesc = 'UPDATED_DESC',\n  StatusAsc = 'STATUS_ASC',\n  StatusDesc = 'STATUS_DESC',\n  PositionAsc = 'POSITION_ASC',\n  PositionDesc = 'POSITION_DESC',\n  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',\n  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'\n}\n\nexport enum StageStatus {\n  Complete = 'COMPLETE',\n  Ready = 'READY',\n  Computing = 'COMPUTING',\n  Stale = 'STALE'\n}\n\n/** A filter to be used against StageStatus fields. All fields are combined with a logical ‘and.’ */\nexport type StageStatusFilter = {\n  /** Is null (if `true` is specified) or is not null (if `false` is specified). */\n  readonly isNull?: Maybe<Scalars['Boolean']>;\n  /** Equal to the specified value. */\n  readonly equalTo?: Maybe<StageStatus>;\n  /** Not equal to the specified value. */\n  readonly notEqualTo?: Maybe<StageStatus>;\n  /** Not equal to the specified value, treating null like an ordinary value. */\n  readonly distinctFrom?: Maybe<StageStatus>;\n  /** Equal to the specified value, treating null like an ordinary value. */\n  readonly notDistinctFrom?: Maybe<StageStatus>;\n  /** Included in the specified list. */\n  readonly in?: Maybe<ReadonlyArray<StageStatus>>;\n  /** Not included in the specified list. */\n  readonly notIn?: Maybe<ReadonlyArray<StageStatus>>;\n  /** Less than the specified value. */\n  readonly lessThan?: Maybe<StageStatus>;\n  /** Less than or equal to the specified value. */\n  readonly lessThanOrEqualTo?: Maybe<StageStatus>;\n  /** Greater than the specified value. */\n  readonly greaterThan?: Maybe<StageStatus>;\n  /** Greater than or equal to the specified value. */\n  readonly greaterThanOrEqualTo?: Maybe<StageStatus>;\n};\n\n/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */\nexport type StringFilter = {\n  /** Is null (if `true` is specified) or is not null (if `false` is specified). */\n  readonly isNull?: Maybe<Scalars['Boolean']>;\n  /** Equal to the specified value. */\n  readonly equalTo?: Maybe<Scalars['String']>;\n  /** Not equal to the specified value. */\n  readonly notEqualTo?: Maybe<Scalars['String']>;\n  /** Not equal to the specified value, treating null like an ordinary value. */\n  readonly distinctFrom?: Maybe<Scalars['String']>;\n  /** Equal to the specified value, treating null like an ordinary value. */\n  readonly notDistinctFrom?: Maybe<Scalars['String']>;\n  /** Included in the specified list. */\n  readonly in?: Maybe<ReadonlyArray<Scalars['String']>>;\n  /** Not included in the specified list. */\n  readonly notIn?: Maybe<ReadonlyArray<Scalars['String']>>;\n  /** Less than the specified value. */\n  readonly lessThan?: Maybe<Scalars['String']>;\n  /** Less than or equal to the specified value. */\n  readonly lessThanOrEqualTo?: Maybe<Scalars['String']>;\n  /** Greater than the specified value. */\n  readonly greaterThan?: Maybe<Scalars['String']>;\n  /** Greater than or equal to the specified value. */\n  readonly greaterThanOrEqualTo?: Maybe<Scalars['String']>;\n  /** Contains the specified string (case-sensitive). */\n  readonly includes?: Maybe<Scalars['String']>;\n  /** Does not contain the specified string (case-sensitive). */\n  readonly notIncludes?: Maybe<Scalars['String']>;\n  /** Contains the specified string (case-insensitive). */\n  readonly includesInsensitive?: Maybe<Scalars['String']>;\n  /** Does not contain the specified string (case-insensitive). */\n  readonly notIncludesInsensitive?: Maybe<Scalars['String']>;\n  /** Starts with the specified string (case-sensitive). */\n  readonly startsWith?: Maybe<Scalars['String']>;\n  /** Does not start with the specified string (case-sensitive). */\n  readonly notStartsWith?: Maybe<Scalars['String']>;\n  /** Starts with the specified string (case-insensitive). */\n  readonly startsWithInsensitive?: Maybe<Scalars['String']>;\n  /** Does not start with the specified string (case-insensitive). */\n  readonly notStartsWithInsensitive?: Maybe<Scalars['String']>;\n  /** Ends with the specified string (case-sensitive). */\n  readonly endsWith?: Maybe<Scalars['String']>;\n  /** Does not end with the specified string (case-sensitive). */\n  readonly notEndsWith?: Maybe<Scalars['String']>;\n  /** Ends with the specified string (case-insensitive). */\n  readonly endsWithInsensitive?: Maybe<Scalars['String']>;\n  /** Does not end with the specified string (case-insensitive). */\n  readonly notEndsWithInsensitive?: Maybe<Scalars['String']>;\n  /**\n   * Matches the specified pattern (case-sensitive). An underscore (_) matches any\n   * single character; a percent sign (%) matches any sequence of zero or more characters.\n   */\n  readonly like?: Maybe<Scalars['String']>;\n  /**\n   * Does not match the specified pattern (case-sensitive). An underscore (_)\n   * matches any single character; a percent sign (%) matches any sequence of zero\n   * or more characters.\n   */\n  readonly notLike?: Maybe<Scalars['String']>;\n  /**\n   * Matches the specified pattern (case-insensitive). An underscore (_) matches\n   * any single character; a percent sign (%) matches any sequence of zero or more characters.\n   */\n  readonly likeInsensitive?: Maybe<Scalars['String']>;\n  /**\n   * Does not match the specified pattern (case-insensitive). An underscore (_)\n   * matches any single character; a percent sign (%) matches any sequence of zero\n   * or more characters.\n   */\n  readonly notLikeInsensitive?: Maybe<Scalars['String']>;\n  /** Matches the specified pattern using the SQL standard's definition of a regular expression. */\n  readonly similarTo?: Maybe<Scalars['String']>;\n  /** Does not match the specified pattern using the SQL standard's definition of a regular expression. */\n  readonly notSimilarTo?: Maybe<Scalars['String']>;\n};\n\n/** A filter to be used against String List fields. All fields are combined with a logical ‘and.’ */\nexport type StringListFilter = {\n  /** Is null (if `true` is specified) or is not null (if `false` is specified). */\n  readonly isNull?: Maybe<Scalars['Boolean']>;\n  /** Equal to the specified value. */\n  readonly equalTo?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;\n  /** Not equal to the specified value. */\n  readonly notEqualTo?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;\n  /** Not equal to the specified value, treating null like an ordinary value. */\n  readonly distinctFrom?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;\n  /** Equal to the specified value, treating null like an ordinary value. */\n  readonly notDistinctFrom?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;\n  /** Less than the specified value. */\n  readonly lessThan?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;\n  /** Less than or equal to the specified value. */\n  readonly lessThanOrEqualTo?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;\n  /** Greater than the specified value. */\n  readonly greaterThan?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;\n  /** Greater than or equal to the specified value. */\n  readonly greaterThanOrEqualTo?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;\n  /** Contains the specified list of values. */\n  readonly contains?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;\n  /** Contained by the specified list of values. */\n  readonly containedBy?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;\n  /** Overlaps the specified list of values. */\n  readonly overlaps?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;\n  /** Any array item is equal to the specified value. */\n  readonly anyEqualTo?: Maybe<Scalars['String']>;\n  /** Any array item is not equal to the specified value. */\n  readonly anyNotEqualTo?: Maybe<Scalars['String']>;\n  /** Any array item is less than the specified value. */\n  readonly anyLessThan?: Maybe<Scalars['String']>;\n  /** Any array item is less than or equal to the specified value. */\n  readonly anyLessThanOrEqualTo?: Maybe<Scalars['String']>;\n  /** Any array item is greater than the specified value. */\n  readonly anyGreaterThan?: Maybe<Scalars['String']>;\n  /** Any array item is greater than or equal to the specified value. */\n  readonly anyGreaterThanOrEqualTo?: Maybe<Scalars['String']>;\n};\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type Subscription = {\n  /**\n   * Exposes the root query type nested one level down. This is helpful for Relay 1\n   * which can only query top level fields if they are in a particular form. (live)\n   */\n  readonly query: Query;\n  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. (live) */\n  readonly nodeId: Scalars['ID'];\n  /** Fetches an object given its globally unique `ID`. (live) */\n  readonly node?: Maybe<Node>;\n  /** Reads and enables pagination through a set of `Computation`. (live) */\n  readonly computations?: Maybe<ComputationsConnection>;\n  /** Reads and enables pagination through a set of `FeedEvent`. (live) */\n  readonly feedEvents?: Maybe<FeedEventsConnection>;\n  /** Reads and enables pagination through a set of `Follow`. (live) */\n  readonly follows?: Maybe<FollowsConnection>;\n  /** Reads and enables pagination through a set of `Guide`. (live) */\n  readonly guides?: Maybe<GuidesConnection>;\n  /** Reads and enables pagination through a set of `Ride`. (live) */\n  readonly rides?: Maybe<RidesConnection>;\n  /** Reads and enables pagination through a set of `Spot`. (live) */\n  readonly spots?: Maybe<SpotsConnection>;\n  /** Reads and enables pagination through a set of `Stage`. (live) */\n  readonly stages?: Maybe<StagesConnection>;\n  /** Reads and enables pagination through a set of `Temperature`. (live) */\n  readonly temperatures?: Maybe<TemperaturesConnection>;\n  /** Reads and enables pagination through a set of `User`. (live) */\n  readonly users?: Maybe<UsersConnection>;\n  /**  (live) */\n  readonly computation?: Maybe<Computation>;\n  /**  (live) */\n  readonly feedEvent?: Maybe<FeedEvent>;\n  /**  (live) */\n  readonly guide?: Maybe<Guide>;\n  /**  (live) */\n  readonly ride?: Maybe<Ride>;\n  /**  (live) */\n  readonly spot?: Maybe<Spot>;\n  /**  (live) */\n  readonly stage?: Maybe<Stage>;\n  /**  (live) */\n  readonly temperature?: Maybe<Temperature>;\n  /**  (live) */\n  readonly user?: Maybe<User>;\n  /**  (live) */\n  readonly countries?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;\n  /** Reads and enables pagination through a set of `FeedEvent`. (live) */\n  readonly feed: FeedEventsConnection;\n  /**  (live) */\n  readonly getCurrentUser?: Maybe<Scalars['JwtToken']>;\n  /** Reads a single `Computation` using its globally unique `ID`. (live) */\n  readonly computationByNodeId?: Maybe<Computation>;\n  /** Reads a single `FeedEvent` using its globally unique `ID`. (live) */\n  readonly feedEventByNodeId?: Maybe<FeedEvent>;\n  /** Reads a single `Guide` using its globally unique `ID`. (live) */\n  readonly guideByNodeId?: Maybe<Guide>;\n  /** Reads a single `Ride` using its globally unique `ID`. (live) */\n  readonly rideByNodeId?: Maybe<Ride>;\n  /** Reads a single `Spot` using its globally unique `ID`. (live) */\n  readonly spotByNodeId?: Maybe<Spot>;\n  /** Reads a single `Stage` using its globally unique `ID`. (live) */\n  readonly stageByNodeId?: Maybe<Stage>;\n  /** Reads a single `Temperature` using its globally unique `ID`. (live) */\n  readonly temperatureByNodeId?: Maybe<Temperature>;\n  /** Reads a single `User` using its globally unique `ID`. (live) */\n  readonly userByNodeId?: Maybe<User>;\n  /**  (live) */\n  readonly geocode: GeocodeResponse;\n  /**  (live) */\n  readonly appVersion: Scalars['String'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionNodeArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionComputationsArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<ComputationsOrderBy>>;\n  condition?: Maybe<ComputationCondition>;\n  filter?: Maybe<ComputationFilter>;\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionFeedEventsArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<FeedEventsOrderBy>>;\n  condition?: Maybe<FeedEventCondition>;\n  filter?: Maybe<FeedEventFilter>;\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionFollowsArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<FollowsOrderBy>>;\n  condition?: Maybe<FollowCondition>;\n  filter?: Maybe<FollowFilter>;\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionGuidesArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<GuidesOrderBy>>;\n  condition?: Maybe<GuideCondition>;\n  filter?: Maybe<GuideFilter>;\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionRidesArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<RidesOrderBy>>;\n  condition?: Maybe<RideCondition>;\n  filter?: Maybe<RideFilter>;\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionSpotsArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<SpotsOrderBy>>;\n  condition?: Maybe<SpotCondition>;\n  filter?: Maybe<SpotFilter>;\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionStagesArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<StagesOrderBy>>;\n  condition?: Maybe<StageCondition>;\n  filter?: Maybe<StageFilter>;\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionTemperaturesArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<TemperaturesOrderBy>>;\n  condition?: Maybe<TemperatureCondition>;\n  filter?: Maybe<TemperatureFilter>;\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionUsersArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<UsersOrderBy>>;\n  condition?: Maybe<UserCondition>;\n  filter?: Maybe<UserFilter>;\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionComputationArgs = {\n  id: Scalars['String'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionFeedEventArgs = {\n  timestamp: Scalars['Datetime'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionGuideArgs = {\n  id: Scalars['String'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionRideArgs = {\n  id: Scalars['String'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionSpotArgs = {\n  id: Scalars['String'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionStageArgs = {\n  id: Scalars['String'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionTemperatureArgs = {\n  id: Scalars['String'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionUserArgs = {\n  username: Scalars['String'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionFeedArgs = {\n  _username?: Maybe<Scalars['String']>;\n  perPage?: Maybe<Scalars['Int']>;\n  pageOffset?: Maybe<Scalars['Int']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  filter?: Maybe<FeedEventFilter>;\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionComputationByNodeIdArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionFeedEventByNodeIdArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionGuideByNodeIdArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionRideByNodeIdArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionSpotByNodeIdArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionStageByNodeIdArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionTemperatureByNodeIdArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionUserByNodeIdArgs = {\n  nodeId: Scalars['ID'];\n};\n\n\n/**\n * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n * \n * #### Live Queries\n * \n * Live query fields are differentiated by containing `(live)` at the end of their\n * description, they are added for each field in the `Query` type. When you\n * subscribe to a live query field, the selection set will be evaluated and sent to\n * the client, and then most things\\* that would cause the output of the selection\n * set to change will trigger the selection set to be re-evaluated and the results\n * to be re-sent to the client.\n * \n * _(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n * \n * Live queries can be very expensive, so try and keep them small and focussed.\n * \n * #### Events\n * \n * Event fields will run their selection set when, and only when, the specified\n * server-side event occurs. This makes them a lot more efficient than Live\n * Queries, but it is still recommended that you keep payloads fairly small.\n */\nexport type SubscriptionGeocodeArgs = {\n  query: Scalars['String'];\n};\n\nexport type Temperature = Node & {\n  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */\n  readonly nodeId: Scalars['ID'];\n  readonly id: Scalars['String'];\n  readonly country: Scalars['String'];\n  readonly month: Scalars['Int'];\n  readonly temperature: Scalars['Float'];\n  readonly created: Scalars['Datetime'];\n  readonly updated?: Maybe<Scalars['Datetime']>;\n};\n\n/**\n * A condition to be used against `Temperature` object types. All fields are tested\n * for equality and combined with a logical ‘and.’\n */\nexport type TemperatureCondition = {\n  /** Checks for equality with the object’s `id` field. */\n  readonly id?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `country` field. */\n  readonly country?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `month` field. */\n  readonly month?: Maybe<Scalars['Int']>;\n  /** Checks for equality with the object’s `temperature` field. */\n  readonly temperature?: Maybe<Scalars['Float']>;\n  /** Checks for equality with the object’s `created` field. */\n  readonly created?: Maybe<Scalars['Datetime']>;\n  /** Checks for equality with the object’s `updated` field. */\n  readonly updated?: Maybe<Scalars['Datetime']>;\n};\n\n/** A filter to be used against `Temperature` object types. All fields are combined with a logical ‘and.’ */\nexport type TemperatureFilter = {\n  /** Filter by the object’s `id` field. */\n  readonly id?: Maybe<StringFilter>;\n  /** Filter by the object’s `country` field. */\n  readonly country?: Maybe<StringFilter>;\n  /** Filter by the object’s `month` field. */\n  readonly month?: Maybe<IntFilter>;\n  /** Filter by the object’s `temperature` field. */\n  readonly temperature?: Maybe<FloatFilter>;\n  /** Filter by the object’s `created` field. */\n  readonly created?: Maybe<DatetimeFilter>;\n  /** Filter by the object’s `updated` field. */\n  readonly updated?: Maybe<DatetimeFilter>;\n  /** Checks for all expressions in this list. */\n  readonly and?: Maybe<ReadonlyArray<TemperatureFilter>>;\n  /** Checks for any expressions in this list. */\n  readonly or?: Maybe<ReadonlyArray<TemperatureFilter>>;\n  /** Negates the expression. */\n  readonly not?: Maybe<TemperatureFilter>;\n};\n\n/** A connection to a list of `Temperature` values. */\nexport type TemperaturesConnection = {\n  /** A list of `Temperature` objects. */\n  readonly nodes: ReadonlyArray<Maybe<Temperature>>;\n  /** A list of edges which contains the `Temperature` and cursor to aid in pagination. */\n  readonly edges: ReadonlyArray<TemperaturesEdge>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The count of *all* `Temperature` you could get from the connection. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** A `Temperature` edge in the connection. */\nexport type TemperaturesEdge = {\n  /** A cursor for use in pagination. */\n  readonly cursor?: Maybe<Scalars['Cursor']>;\n  /** The `Temperature` at the end of the edge. */\n  readonly node?: Maybe<Temperature>;\n};\n\n/** Methods to use when ordering `Temperature`. */\nexport enum TemperaturesOrderBy {\n  Natural = 'NATURAL',\n  IdAsc = 'ID_ASC',\n  IdDesc = 'ID_DESC',\n  CountryAsc = 'COUNTRY_ASC',\n  CountryDesc = 'COUNTRY_DESC',\n  MonthAsc = 'MONTH_ASC',\n  MonthDesc = 'MONTH_DESC',\n  TemperatureAsc = 'TEMPERATURE_ASC',\n  TemperatureDesc = 'TEMPERATURE_DESC',\n  CreatedAsc = 'CREATED_ASC',\n  CreatedDesc = 'CREATED_DESC',\n  UpdatedAsc = 'UPDATED_ASC',\n  UpdatedDesc = 'UPDATED_DESC',\n  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',\n  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'\n}\n\nexport enum TransportType {\n  Motorcycle = 'MOTORCYCLE',\n  Bicycle = 'BICYCLE',\n  Car = 'CAR'\n}\n\n/** A filter to be used against TransportType fields. All fields are combined with a logical ‘and.’ */\nexport type TransportTypeFilter = {\n  /** Is null (if `true` is specified) or is not null (if `false` is specified). */\n  readonly isNull?: Maybe<Scalars['Boolean']>;\n  /** Equal to the specified value. */\n  readonly equalTo?: Maybe<TransportType>;\n  /** Not equal to the specified value. */\n  readonly notEqualTo?: Maybe<TransportType>;\n  /** Not equal to the specified value, treating null like an ordinary value. */\n  readonly distinctFrom?: Maybe<TransportType>;\n  /** Equal to the specified value, treating null like an ordinary value. */\n  readonly notDistinctFrom?: Maybe<TransportType>;\n  /** Included in the specified list. */\n  readonly in?: Maybe<ReadonlyArray<TransportType>>;\n  /** Not included in the specified list. */\n  readonly notIn?: Maybe<ReadonlyArray<TransportType>>;\n  /** Less than the specified value. */\n  readonly lessThan?: Maybe<TransportType>;\n  /** Less than or equal to the specified value. */\n  readonly lessThanOrEqualTo?: Maybe<TransportType>;\n  /** Greater than the specified value. */\n  readonly greaterThan?: Maybe<TransportType>;\n  /** Greater than or equal to the specified value. */\n  readonly greaterThanOrEqualTo?: Maybe<TransportType>;\n};\n\n/** All input for the `updateFeedEventByNodeId` mutation. */\nexport type UpdateFeedEventByNodeIdInput = {\n  /**\n   * An arbitrary string value with no semantic meaning. Will be included in the\n   * payload verbatim. May be used to track mutations by the client.\n   */\n  readonly clientMutationId?: Maybe<Scalars['String']>;\n  /** The globally unique `ID` which will identify a single `FeedEvent` to be updated. */\n  readonly nodeId: Scalars['ID'];\n  /** An object where the defined keys will be set on the `FeedEvent` being updated. */\n  readonly patch: FeedEventPatch;\n};\n\n/** All input for the `updateFeedEvent` mutation. */\nexport type UpdateFeedEventInput = {\n  /**\n   * An arbitrary string value with no semantic meaning. Will be included in the\n   * payload verbatim. May be used to track mutations by the client.\n   */\n  readonly clientMutationId?: Maybe<Scalars['String']>;\n  /** An object where the defined keys will be set on the `FeedEvent` being updated. */\n  readonly patch: FeedEventPatch;\n  readonly timestamp: Scalars['Datetime'];\n};\n\n/** The output of our update `FeedEvent` mutation. */\nexport type UpdateFeedEventPayload = {\n  /**\n   * The exact same `clientMutationId` that was provided in the mutation input,\n   * unchanged and unused. May be used by a client to track mutations.\n   */\n  readonly clientMutationId?: Maybe<Scalars['String']>;\n  /** The `FeedEvent` that was updated by this mutation. */\n  readonly feedEvent?: Maybe<FeedEvent>;\n  /** Our root query field type. Allows us to run any query from our mutation payload. */\n  readonly query?: Maybe<Query>;\n  /** Reads a single `Ride` that is related to this `FeedEvent`. */\n  readonly rideByRide?: Maybe<Ride>;\n  /** Reads a single `Guide` that is related to this `FeedEvent`. */\n  readonly guideByGuide?: Maybe<Guide>;\n  /** Reads a single `User` that is related to this `FeedEvent`. */\n  readonly userByUser?: Maybe<User>;\n  /** An edge for our `FeedEvent`. May be used by Relay 1. */\n  readonly feedEventEdge?: Maybe<FeedEventsEdge>;\n};\n\n\n/** The output of our update `FeedEvent` mutation. */\nexport type UpdateFeedEventPayloadFeedEventEdgeArgs = {\n  orderBy?: Maybe<ReadonlyArray<FeedEventsOrderBy>>;\n};\n\nexport type UpdateGuidePatch = {\n  readonly id: Scalars['String'];\n  readonly title?: Maybe<Scalars['String']>;\n  readonly startDate?: Maybe<Scalars['String']>;\n  readonly isCircular?: Maybe<Scalars['Boolean']>;\n  readonly maxHoursPerRide?: Maybe<Scalars['Int']>;\n  readonly type?: Maybe<TransportType>;\n};\n\nexport type UpdateGuideResult = {\n  readonly success: Scalars['Boolean'];\n  readonly message?: Maybe<Scalars['String']>;\n  readonly id?: Maybe<Scalars['String']>;\n  readonly triggeredDates?: Maybe<Scalars['Boolean']>;\n  readonly triggeredComputations?: Maybe<Scalars['Boolean']>;\n};\n\nexport type UpdateSpotLocationPatch = {\n  readonly lat: Scalars['Float'];\n  readonly long: Scalars['Float'];\n  readonly location?: Maybe<Scalars['String']>;\n  readonly country?: Maybe<Scalars['String']>;\n};\n\nexport type UpdateSpotPatch = {\n  readonly id: Scalars['String'];\n  readonly label?: Maybe<Scalars['String']>;\n  readonly nights?: Maybe<Scalars['Int']>;\n  readonly location?: Maybe<UpdateSpotLocationPatch>;\n};\n\nexport type UpdateSpotResult = {\n  readonly success: Scalars['Boolean'];\n  readonly message?: Maybe<Scalars['String']>;\n  readonly id?: Maybe<Scalars['String']>;\n  readonly triggeredComputations?: Maybe<Scalars['Boolean']>;\n  readonly ammendedDates?: Maybe<Scalars['Boolean']>;\n};\n\nexport type User = Node & {\n  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */\n  readonly nodeId: Scalars['ID'];\n  readonly username: Scalars['String'];\n  readonly email: Scalars['String'];\n  readonly passwordHash: Scalars['String'];\n  readonly colour?: Maybe<Colour>;\n  readonly created: Scalars['Datetime'];\n  readonly updated?: Maybe<Scalars['Datetime']>;\n  /** Reads and enables pagination through a set of `Guide`. */\n  readonly guidesByOwner: GuidesConnection;\n  /** Reads and enables pagination through a set of `Spot`. */\n  readonly spotsByOwner: SpotsConnection;\n  /** Reads and enables pagination through a set of `Ride`. */\n  readonly ridesByOwner: RidesConnection;\n  /** Reads and enables pagination through a set of `Follow`. */\n  readonly followsByFollowed: FollowsConnection;\n  /** Reads and enables pagination through a set of `Follow`. */\n  readonly followsByFollower: FollowsConnection;\n  /** Reads and enables pagination through a set of `FeedEvent`. */\n  readonly feedEventsByUser: FeedEventsConnection;\n  readonly countries?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;\n  readonly distanceMeters?: Maybe<Scalars['BigInt']>;\n  readonly durationSeconds?: Maybe<Scalars['BigInt']>;\n  readonly followingStatus?: Maybe<FollowingStatus>;\n};\n\n\nexport type UserGuidesByOwnerArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<GuidesOrderBy>>;\n  condition?: Maybe<GuideCondition>;\n  filter?: Maybe<GuideFilter>;\n};\n\n\nexport type UserSpotsByOwnerArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<SpotsOrderBy>>;\n  condition?: Maybe<SpotCondition>;\n  filter?: Maybe<SpotFilter>;\n};\n\n\nexport type UserRidesByOwnerArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<RidesOrderBy>>;\n  condition?: Maybe<RideCondition>;\n  filter?: Maybe<RideFilter>;\n};\n\n\nexport type UserFollowsByFollowedArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<FollowsOrderBy>>;\n  condition?: Maybe<FollowCondition>;\n  filter?: Maybe<FollowFilter>;\n};\n\n\nexport type UserFollowsByFollowerArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<FollowsOrderBy>>;\n  condition?: Maybe<FollowCondition>;\n  filter?: Maybe<FollowFilter>;\n};\n\n\nexport type UserFeedEventsByUserArgs = {\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  offset?: Maybe<Scalars['Int']>;\n  before?: Maybe<Scalars['Cursor']>;\n  after?: Maybe<Scalars['Cursor']>;\n  orderBy?: Maybe<ReadonlyArray<FeedEventsOrderBy>>;\n  condition?: Maybe<FeedEventCondition>;\n  filter?: Maybe<FeedEventFilter>;\n};\n\n/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */\nexport type UserCondition = {\n  /** Checks for equality with the object’s `username` field. */\n  readonly username?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `email` field. */\n  readonly email?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `passwordHash` field. */\n  readonly passwordHash?: Maybe<Scalars['String']>;\n  /** Checks for equality with the object’s `colour` field. */\n  readonly colour?: Maybe<Colour>;\n  /** Checks for equality with the object’s `created` field. */\n  readonly created?: Maybe<Scalars['Datetime']>;\n  /** Checks for equality with the object’s `updated` field. */\n  readonly updated?: Maybe<Scalars['Datetime']>;\n};\n\n/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */\nexport type UserFilter = {\n  /** Filter by the object’s `username` field. */\n  readonly username?: Maybe<StringFilter>;\n  /** Filter by the object’s `email` field. */\n  readonly email?: Maybe<StringFilter>;\n  /** Filter by the object’s `passwordHash` field. */\n  readonly passwordHash?: Maybe<StringFilter>;\n  /** Filter by the object’s `colour` field. */\n  readonly colour?: Maybe<ColourFilter>;\n  /** Filter by the object’s `created` field. */\n  readonly created?: Maybe<DatetimeFilter>;\n  /** Filter by the object’s `updated` field. */\n  readonly updated?: Maybe<DatetimeFilter>;\n  /** Filter by the object’s `countries` field. */\n  readonly countries?: Maybe<StringListFilter>;\n  /** Filter by the object’s `distanceMeters` field. */\n  readonly distanceMeters?: Maybe<BigIntFilter>;\n  /** Filter by the object’s `durationSeconds` field. */\n  readonly durationSeconds?: Maybe<BigIntFilter>;\n  /** Filter by the object’s `followingStatus` field. */\n  readonly followingStatus?: Maybe<FollowingStatusFilter>;\n  /** Checks for all expressions in this list. */\n  readonly and?: Maybe<ReadonlyArray<UserFilter>>;\n  /** Checks for any expressions in this list. */\n  readonly or?: Maybe<ReadonlyArray<UserFilter>>;\n  /** Negates the expression. */\n  readonly not?: Maybe<UserFilter>;\n};\n\n/** An input for mutations affecting `User` */\nexport type UserInput = {\n  readonly username: Scalars['String'];\n  readonly email: Scalars['String'];\n  readonly passwordHash: Scalars['String'];\n  readonly colour?: Maybe<Colour>;\n  readonly created: Scalars['Datetime'];\n  readonly updated?: Maybe<Scalars['Datetime']>;\n};\n\n/** A connection to a list of `User` values. */\nexport type UsersConnection = {\n  /** A list of `User` objects. */\n  readonly nodes: ReadonlyArray<Maybe<User>>;\n  /** A list of edges which contains the `User` and cursor to aid in pagination. */\n  readonly edges: ReadonlyArray<UsersEdge>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The count of *all* `User` you could get from the connection. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** A `User` edge in the connection. */\nexport type UsersEdge = {\n  /** A cursor for use in pagination. */\n  readonly cursor?: Maybe<Scalars['Cursor']>;\n  /** The `User` at the end of the edge. */\n  readonly node?: Maybe<User>;\n};\n\n/** Methods to use when ordering `User`. */\nexport enum UsersOrderBy {\n  Natural = 'NATURAL',\n  UsernameAsc = 'USERNAME_ASC',\n  UsernameDesc = 'USERNAME_DESC',\n  EmailAsc = 'EMAIL_ASC',\n  EmailDesc = 'EMAIL_DESC',\n  PasswordHashAsc = 'PASSWORD_HASH_ASC',\n  PasswordHashDesc = 'PASSWORD_HASH_DESC',\n  ColourAsc = 'COLOUR_ASC',\n  ColourDesc = 'COLOUR_DESC',\n  CreatedAsc = 'CREATED_ASC',\n  CreatedDesc = 'CREATED_DESC',\n  UpdatedAsc = 'UPDATED_ASC',\n  UpdatedDesc = 'UPDATED_DESC',\n  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',\n  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'\n}\n\n\n\nexport type ResolverTypeWrapper<T> = Promise<T> | T;\n\n\nexport type StitchingResolver<TResult, TParent, TContext, TArgs> = {\n  fragment: string;\n  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\n\nexport type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n  | ResolverFn<TResult, TParent, TContext, TArgs>\n  | StitchingResolver<TResult, TParent, TContext, TArgs>;\n\nexport type ResolverFn<TResult, TParent, TContext, TArgs> = (\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => Promise<TResult> | TResult;\n\nexport type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;\n\nexport type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\n\nexport interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {\n  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;\n  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;\n}\n\nexport interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {\n  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;\n  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;\n}\n\nexport type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =\n  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>\n  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;\n\nexport type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =\n  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)\n  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;\n\nexport type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (\n  parent: TParent,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => Maybe<TTypes> | Promise<Maybe<TTypes>>;\n\nexport type isTypeOfResolverFn<T = {}> = (obj: T, info: GraphQLResolveInfo) => boolean | Promise<boolean>;\n\nexport type NextResolverFn<T> = () => Promise<T>;\n\nexport type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (\n  next: NextResolverFn<TResult>,\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\n\n/** Mapping between all available schema types and the resolvers types */\nexport type ResolversTypes = {\n  Query: ResolverTypeWrapper<{}>,\n  Node: ResolversTypes['Query'] | ResolversTypes['Computation'] | ResolversTypes['Stage'] | ResolversTypes['Guide'] | ResolversTypes['User'] | ResolversTypes['Spot'] | ResolversTypes['Ride'] | ResolversTypes['FeedEvent'] | ResolversTypes['Temperature'],\n  ID: ResolverTypeWrapper<Scalars['ID']>,\n  Int: ResolverTypeWrapper<Scalars['Int']>,\n  Cursor: ResolverTypeWrapper<Scalars['Cursor']>,\n  ComputationsOrderBy: ComputationsOrderBy,\n  ComputationCondition: ComputationCondition,\n  String: ResolverTypeWrapper<Scalars['String']>,\n  Datetime: ResolverTypeWrapper<Scalars['Datetime']>,\n  ComputationStatus: ComputationStatus,\n  ComputationFilter: ComputationFilter,\n  StringFilter: StringFilter,\n  Boolean: ResolverTypeWrapper<Scalars['Boolean']>,\n  DatetimeFilter: DatetimeFilter,\n  IntFilter: IntFilter,\n  ComputationStatusFilter: ComputationStatusFilter,\n  ComputationsConnection: ResolverTypeWrapper<ComputationsConnection>,\n  Computation: ResolverTypeWrapper<Computation>,\n  Stage: ResolverTypeWrapper<Stage>,\n  StageStatus: StageStatus,\n  Guide: ResolverTypeWrapper<Guide>,\n  TransportType: TransportType,\n  User: ResolverTypeWrapper<User>,\n  Colour: Colour,\n  GuidesOrderBy: GuidesOrderBy,\n  GuideCondition: GuideCondition,\n  GuideFilter: GuideFilter,\n  BooleanFilter: BooleanFilter,\n  TransportTypeFilter: TransportTypeFilter,\n  StringListFilter: StringListFilter,\n  BigIntFilter: BigIntFilter,\n  BigInt: ResolverTypeWrapper<Scalars['BigInt']>,\n  GuidesConnection: ResolverTypeWrapper<GuidesConnection>,\n  GuidesEdge: ResolverTypeWrapper<GuidesEdge>,\n  PageInfo: ResolverTypeWrapper<PageInfo>,\n  SpotsOrderBy: SpotsOrderBy,\n  SpotCondition: SpotCondition,\n  Float: ResolverTypeWrapper<Scalars['Float']>,\n  SpotFilter: SpotFilter,\n  FloatFilter: FloatFilter,\n  SpotsConnection: ResolverTypeWrapper<SpotsConnection>,\n  Spot: ResolverTypeWrapper<Spot>,\n  StagesOrderBy: StagesOrderBy,\n  StageCondition: StageCondition,\n  StageFilter: StageFilter,\n  StageStatusFilter: StageStatusFilter,\n  StagesConnection: ResolverTypeWrapper<StagesConnection>,\n  StagesEdge: ResolverTypeWrapper<StagesEdge>,\n  RidesOrderBy: RidesOrderBy,\n  RideCondition: RideCondition,\n  RideStatus: RideStatus,\n  RideFilter: RideFilter,\n  RideStatusFilter: RideStatusFilter,\n  RidesConnection: ResolverTypeWrapper<RidesConnection>,\n  Ride: ResolverTypeWrapper<Ride>,\n  FeedEventsOrderBy: FeedEventsOrderBy,\n  FeedEventCondition: FeedEventCondition,\n  FeedEventType: FeedEventType,\n  FeedEventFilter: FeedEventFilter,\n  FeedEventTypeFilter: FeedEventTypeFilter,\n  FeedEventsConnection: ResolverTypeWrapper<FeedEventsConnection>,\n  FeedEvent: ResolverTypeWrapper<FeedEvent>,\n  FeedEventsEdge: ResolverTypeWrapper<FeedEventsEdge>,\n  RidesEdge: ResolverTypeWrapper<RidesEdge>,\n  SpotsEdge: ResolverTypeWrapper<SpotsEdge>,\n  FollowsOrderBy: FollowsOrderBy,\n  FollowCondition: FollowCondition,\n  FollowFilter: FollowFilter,\n  FollowsConnection: ResolverTypeWrapper<FollowsConnection>,\n  Follow: ResolverTypeWrapper<Follow>,\n  FollowsEdge: ResolverTypeWrapper<FollowsEdge>,\n  FollowingStatus: FollowingStatus,\n  Bound: ResolverTypeWrapper<Bound>,\n  ComputationsEdge: ResolverTypeWrapper<ComputationsEdge>,\n  TemperaturesOrderBy: TemperaturesOrderBy,\n  TemperatureCondition: TemperatureCondition,\n  TemperatureFilter: TemperatureFilter,\n  TemperaturesConnection: ResolverTypeWrapper<TemperaturesConnection>,\n  Temperature: ResolverTypeWrapper<Temperature>,\n  TemperaturesEdge: ResolverTypeWrapper<TemperaturesEdge>,\n  UsersOrderBy: UsersOrderBy,\n  UserCondition: UserCondition,\n  UserFilter: UserFilter,\n  ColourFilter: ColourFilter,\n  FollowingStatusFilter: FollowingStatusFilter,\n  UsersConnection: ResolverTypeWrapper<UsersConnection>,\n  UsersEdge: ResolverTypeWrapper<UsersEdge>,\n  JwtToken: ResolverTypeWrapper<Scalars['JwtToken']>,\n  GeocodeResponse: ResolverTypeWrapper<GeocodeResponse>,\n  Geocode: ResolverTypeWrapper<Geocode>,\n  Mutation: ResolverTypeWrapper<{}>,\n  CreateFeedEventInput: CreateFeedEventInput,\n  FeedEventInput: FeedEventInput,\n  CreateFeedEventPayload: ResolverTypeWrapper<CreateFeedEventPayload>,\n  CreateUserInput: CreateUserInput,\n  UserInput: UserInput,\n  CreateUserPayload: ResolverTypeWrapper<CreateUserPayload>,\n  UpdateFeedEventByNodeIdInput: UpdateFeedEventByNodeIdInput,\n  FeedEventPatch: FeedEventPatch,\n  UpdateFeedEventPayload: ResolverTypeWrapper<UpdateFeedEventPayload>,\n  UpdateFeedEventInput: UpdateFeedEventInput,\n  DeleteFeedEventByNodeIdInput: DeleteFeedEventByNodeIdInput,\n  DeleteFeedEventPayload: ResolverTypeWrapper<DeleteFeedEventPayload>,\n  DeleteFeedEventInput: DeleteFeedEventInput,\n  AuthenticateInput: AuthenticateInput,\n  AuthenticatePayload: ResolverTypeWrapper<AuthenticatePayload>,\n  RegisterInput: RegisterInput,\n  RegisterPayload: ResolverTypeWrapper<RegisterPayload>,\n  CreateGuideInput: CreateGuideInput,\n  CreateGuideResult: ResolverTypeWrapper<CreateGuideResult>,\n  UpdateGuidePatch: UpdateGuidePatch,\n  UpdateGuideResult: ResolverTypeWrapper<UpdateGuideResult>,\n  DeleteGuideInput: DeleteGuideInput,\n  DeleteGuideResult: ResolverTypeWrapper<DeleteGuideResult>,\n  Result: ResolverTypeWrapper<Result>,\n  AddSpotInput: AddSpotInput,\n  AddSpotResult: ResolverTypeWrapper<AddSpotResult>,\n  UpdateSpotPatch: UpdateSpotPatch,\n  UpdateSpotLocationPatch: UpdateSpotLocationPatch,\n  UpdateSpotResult: ResolverTypeWrapper<UpdateSpotResult>,\n  RemoveSpotInput: RemoveSpotInput,\n  RemoveSpotResult: ResolverTypeWrapper<RemoveSpotResult>,\n  Subscription: ResolverTypeWrapper<{}>,\n};\n\n/** Mapping between all available schema types and the resolvers parents */\nexport type ResolversParentTypes = {\n  Query: {},\n  Node: ResolversParentTypes['Query'] | ResolversParentTypes['Computation'] | ResolversParentTypes['Stage'] | ResolversParentTypes['Guide'] | ResolversParentTypes['User'] | ResolversParentTypes['Spot'] | ResolversParentTypes['Ride'] | ResolversParentTypes['FeedEvent'] | ResolversParentTypes['Temperature'],\n  ID: Scalars['ID'],\n  Int: Scalars['Int'],\n  Cursor: Scalars['Cursor'],\n  ComputationsOrderBy: ComputationsOrderBy,\n  ComputationCondition: ComputationCondition,\n  String: Scalars['String'],\n  Datetime: Scalars['Datetime'],\n  ComputationStatus: ComputationStatus,\n  ComputationFilter: ComputationFilter,\n  StringFilter: StringFilter,\n  Boolean: Scalars['Boolean'],\n  DatetimeFilter: DatetimeFilter,\n  IntFilter: IntFilter,\n  ComputationStatusFilter: ComputationStatusFilter,\n  ComputationsConnection: ComputationsConnection,\n  Computation: Computation,\n  Stage: Stage,\n  StageStatus: StageStatus,\n  Guide: Guide,\n  TransportType: TransportType,\n  User: User,\n  Colour: Colour,\n  GuidesOrderBy: GuidesOrderBy,\n  GuideCondition: GuideCondition,\n  GuideFilter: GuideFilter,\n  BooleanFilter: BooleanFilter,\n  TransportTypeFilter: TransportTypeFilter,\n  StringListFilter: StringListFilter,\n  BigIntFilter: BigIntFilter,\n  BigInt: Scalars['BigInt'],\n  GuidesConnection: GuidesConnection,\n  GuidesEdge: GuidesEdge,\n  PageInfo: PageInfo,\n  SpotsOrderBy: SpotsOrderBy,\n  SpotCondition: SpotCondition,\n  Float: Scalars['Float'],\n  SpotFilter: SpotFilter,\n  FloatFilter: FloatFilter,\n  SpotsConnection: SpotsConnection,\n  Spot: Spot,\n  StagesOrderBy: StagesOrderBy,\n  StageCondition: StageCondition,\n  StageFilter: StageFilter,\n  StageStatusFilter: StageStatusFilter,\n  StagesConnection: StagesConnection,\n  StagesEdge: StagesEdge,\n  RidesOrderBy: RidesOrderBy,\n  RideCondition: RideCondition,\n  RideStatus: RideStatus,\n  RideFilter: RideFilter,\n  RideStatusFilter: RideStatusFilter,\n  RidesConnection: RidesConnection,\n  Ride: Ride,\n  FeedEventsOrderBy: FeedEventsOrderBy,\n  FeedEventCondition: FeedEventCondition,\n  FeedEventType: FeedEventType,\n  FeedEventFilter: FeedEventFilter,\n  FeedEventTypeFilter: FeedEventTypeFilter,\n  FeedEventsConnection: FeedEventsConnection,\n  FeedEvent: FeedEvent,\n  FeedEventsEdge: FeedEventsEdge,\n  RidesEdge: RidesEdge,\n  SpotsEdge: SpotsEdge,\n  FollowsOrderBy: FollowsOrderBy,\n  FollowCondition: FollowCondition,\n  FollowFilter: FollowFilter,\n  FollowsConnection: FollowsConnection,\n  Follow: Follow,\n  FollowsEdge: FollowsEdge,\n  FollowingStatus: FollowingStatus,\n  Bound: Bound,\n  ComputationsEdge: ComputationsEdge,\n  TemperaturesOrderBy: TemperaturesOrderBy,\n  TemperatureCondition: TemperatureCondition,\n  TemperatureFilter: TemperatureFilter,\n  TemperaturesConnection: TemperaturesConnection,\n  Temperature: Temperature,\n  TemperaturesEdge: TemperaturesEdge,\n  UsersOrderBy: UsersOrderBy,\n  UserCondition: UserCondition,\n  UserFilter: UserFilter,\n  ColourFilter: ColourFilter,\n  FollowingStatusFilter: FollowingStatusFilter,\n  UsersConnection: UsersConnection,\n  UsersEdge: UsersEdge,\n  JwtToken: Scalars['JwtToken'],\n  GeocodeResponse: GeocodeResponse,\n  Geocode: Geocode,\n  Mutation: {},\n  CreateFeedEventInput: CreateFeedEventInput,\n  FeedEventInput: FeedEventInput,\n  CreateFeedEventPayload: CreateFeedEventPayload,\n  CreateUserInput: CreateUserInput,\n  UserInput: UserInput,\n  CreateUserPayload: CreateUserPayload,\n  UpdateFeedEventByNodeIdInput: UpdateFeedEventByNodeIdInput,\n  FeedEventPatch: FeedEventPatch,\n  UpdateFeedEventPayload: UpdateFeedEventPayload,\n  UpdateFeedEventInput: UpdateFeedEventInput,\n  DeleteFeedEventByNodeIdInput: DeleteFeedEventByNodeIdInput,\n  DeleteFeedEventPayload: DeleteFeedEventPayload,\n  DeleteFeedEventInput: DeleteFeedEventInput,\n  AuthenticateInput: AuthenticateInput,\n  AuthenticatePayload: AuthenticatePayload,\n  RegisterInput: RegisterInput,\n  RegisterPayload: RegisterPayload,\n  CreateGuideInput: CreateGuideInput,\n  CreateGuideResult: CreateGuideResult,\n  UpdateGuidePatch: UpdateGuidePatch,\n  UpdateGuideResult: UpdateGuideResult,\n  DeleteGuideInput: DeleteGuideInput,\n  DeleteGuideResult: DeleteGuideResult,\n  Result: Result,\n  AddSpotInput: AddSpotInput,\n  AddSpotResult: AddSpotResult,\n  UpdateSpotPatch: UpdateSpotPatch,\n  UpdateSpotLocationPatch: UpdateSpotLocationPatch,\n  UpdateSpotResult: UpdateSpotResult,\n  RemoveSpotInput: RemoveSpotInput,\n  RemoveSpotResult: RemoveSpotResult,\n  Subscription: {},\n};\n\nexport type AddSpotResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddSpotResult'] = ResolversParentTypes['AddSpotResult']> = {\n  success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>,\n  messaage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type AuthenticatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['AuthenticatePayload'] = ResolversParentTypes['AuthenticatePayload']> = {\n  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  jwtToken?: Resolver<Maybe<ResolversTypes['JwtToken']>, ParentType, ContextType>,\n  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {\n  name: 'BigInt'\n}\n\nexport type BoundResolvers<ContextType = any, ParentType extends ResolversParentTypes['Bound'] = ResolversParentTypes['Bound']> = {\n  north?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>,\n  east?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>,\n  south?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>,\n  west?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type ComputationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Computation'] = ResolversParentTypes['Computation']> = {\n  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>,\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  ended?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>,\n  duration?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>,\n  status?: Resolver<ResolversTypes['ComputationStatus'], ParentType, ContextType>,\n  stage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  guide?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  created?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>,\n  started?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>,\n  stageByStage?: Resolver<Maybe<ResolversTypes['Stage']>, ParentType, ContextType>,\n  guideByGuide?: Resolver<Maybe<ResolversTypes['Guide']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type ComputationsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ComputationsConnection'] = ResolversParentTypes['ComputationsConnection']> = {\n  nodes?: Resolver<ReadonlyArray<Maybe<ResolversTypes['Computation']>>, ParentType, ContextType>,\n  edges?: Resolver<ReadonlyArray<ResolversTypes['ComputationsEdge']>, ParentType, ContextType>,\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>,\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type ComputationsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ComputationsEdge'] = ResolversParentTypes['ComputationsEdge']> = {\n  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>,\n  node?: Resolver<Maybe<ResolversTypes['Computation']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type CreateFeedEventPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateFeedEventPayload'] = ResolversParentTypes['CreateFeedEventPayload']> = {\n  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  feedEvent?: Resolver<Maybe<ResolversTypes['FeedEvent']>, ParentType, ContextType>,\n  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>,\n  rideByRide?: Resolver<Maybe<ResolversTypes['Ride']>, ParentType, ContextType>,\n  guideByGuide?: Resolver<Maybe<ResolversTypes['Guide']>, ParentType, ContextType>,\n  userByUser?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>,\n  feedEventEdge?: Resolver<Maybe<ResolversTypes['FeedEventsEdge']>, ParentType, ContextType, RequireFields<CreateFeedEventPayloadFeedEventEdgeArgs, 'orderBy'>>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type CreateGuideResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateGuideResult'] = ResolversParentTypes['CreateGuideResult']> = {\n  success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>,\n  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  guideId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type CreateUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateUserPayload'] = ResolversParentTypes['CreateUserPayload']> = {\n  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>,\n  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>,\n  userEdge?: Resolver<Maybe<ResolversTypes['UsersEdge']>, ParentType, ContextType, RequireFields<CreateUserPayloadUserEdgeArgs, 'orderBy'>>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport interface CursorScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Cursor'], any> {\n  name: 'Cursor'\n}\n\nexport interface DatetimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Datetime'], any> {\n  name: 'Datetime'\n}\n\nexport type DeleteFeedEventPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteFeedEventPayload'] = ResolversParentTypes['DeleteFeedEventPayload']> = {\n  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  feedEvent?: Resolver<Maybe<ResolversTypes['FeedEvent']>, ParentType, ContextType>,\n  deletedFeedEventNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>,\n  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>,\n  rideByRide?: Resolver<Maybe<ResolversTypes['Ride']>, ParentType, ContextType>,\n  guideByGuide?: Resolver<Maybe<ResolversTypes['Guide']>, ParentType, ContextType>,\n  userByUser?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>,\n  feedEventEdge?: Resolver<Maybe<ResolversTypes['FeedEventsEdge']>, ParentType, ContextType, RequireFields<DeleteFeedEventPayloadFeedEventEdgeArgs, 'orderBy'>>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type DeleteGuideResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteGuideResult'] = ResolversParentTypes['DeleteGuideResult']> = {\n  success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>,\n  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type FeedEventResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedEvent'] = ResolversParentTypes['FeedEvent']> = {\n  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>,\n  timestamp?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>,\n  type?: Resolver<ResolversTypes['FeedEventType'], ParentType, ContextType>,\n  ride?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  guide?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  user?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  rideByRide?: Resolver<Maybe<ResolversTypes['Ride']>, ParentType, ContextType>,\n  guideByGuide?: Resolver<Maybe<ResolversTypes['Guide']>, ParentType, ContextType>,\n  userByUser?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type FeedEventsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedEventsConnection'] = ResolversParentTypes['FeedEventsConnection']> = {\n  nodes?: Resolver<ReadonlyArray<Maybe<ResolversTypes['FeedEvent']>>, ParentType, ContextType>,\n  edges?: Resolver<ReadonlyArray<ResolversTypes['FeedEventsEdge']>, ParentType, ContextType>,\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>,\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type FeedEventsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedEventsEdge'] = ResolversParentTypes['FeedEventsEdge']> = {\n  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>,\n  node?: Resolver<Maybe<ResolversTypes['FeedEvent']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type FollowResolvers<ContextType = any, ParentType extends ResolversParentTypes['Follow'] = ResolversParentTypes['Follow']> = {\n  followed?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  follower?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  timestamp?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>,\n  userByFollowed?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>,\n  userByFollower?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type FollowsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FollowsConnection'] = ResolversParentTypes['FollowsConnection']> = {\n  nodes?: Resolver<ReadonlyArray<Maybe<ResolversTypes['Follow']>>, ParentType, ContextType>,\n  edges?: Resolver<ReadonlyArray<ResolversTypes['FollowsEdge']>, ParentType, ContextType>,\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>,\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type FollowsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FollowsEdge'] = ResolversParentTypes['FollowsEdge']> = {\n  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>,\n  node?: Resolver<Maybe<ResolversTypes['Follow']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type GeocodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Geocode'] = ResolversParentTypes['Geocode']> = {\n  countryCode?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  latitude?: Resolver<ResolversTypes['Float'], ParentType, ContextType>,\n  longitude?: Resolver<ResolversTypes['Float'], ParentType, ContextType>,\n  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type GeocodeResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['GeocodeResponse'] = ResolversParentTypes['GeocodeResponse']> = {\n  success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>,\n  geocodes?: Resolver<Maybe<ReadonlyArray<Maybe<ResolversTypes['Geocode']>>>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type GuideResolvers<ContextType = any, ParentType extends ResolversParentTypes['Guide'] = ResolversParentTypes['Guide']> = {\n  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>,\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  owner?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  startDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  isCircular?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>,\n  transportType?: Resolver<ResolversTypes['TransportType'], ParentType, ContextType>,\n  maxHoursPerRide?: Resolver<ResolversTypes['Int'], ParentType, ContextType>,\n  created?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>,\n  updated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>,\n  userByOwner?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>,\n  spotsByGuide?: Resolver<ResolversTypes['SpotsConnection'], ParentType, ContextType, RequireFields<GuideSpotsByGuideArgs, 'orderBy'>>,\n  stagesByGuide?: Resolver<ResolversTypes['StagesConnection'], ParentType, ContextType, RequireFields<GuideStagesByGuideArgs, 'orderBy'>>,\n  ridesByGuide?: Resolver<ResolversTypes['RidesConnection'], ParentType, ContextType, RequireFields<GuideRidesByGuideArgs, 'orderBy'>>,\n  computationsByGuide?: Resolver<ResolversTypes['ComputationsConnection'], ParentType, ContextType, RequireFields<GuideComputationsByGuideArgs, 'orderBy'>>,\n  feedEventsByGuide?: Resolver<ResolversTypes['FeedEventsConnection'], ParentType, ContextType, RequireFields<GuideFeedEventsByGuideArgs, 'orderBy'>>,\n  bounds?: Resolver<Maybe<ResolversTypes['Bound']>, ParentType, ContextType>,\n  countries?: Resolver<Maybe<ReadonlyArray<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>,\n  distanceMeters?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>,\n  durationSeconds?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>,\n  endDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  isMine?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type GuidesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuidesConnection'] = ResolversParentTypes['GuidesConnection']> = {\n  nodes?: Resolver<ReadonlyArray<Maybe<ResolversTypes['Guide']>>, ParentType, ContextType>,\n  edges?: Resolver<ReadonlyArray<ResolversTypes['GuidesEdge']>, ParentType, ContextType>,\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>,\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type GuidesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuidesEdge'] = ResolversParentTypes['GuidesEdge']> = {\n  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>,\n  node?: Resolver<Maybe<ResolversTypes['Guide']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport interface JwtTokenScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JwtToken'], any> {\n  name: 'JwtToken'\n}\n\nexport type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {\n  createFeedEvent?: Resolver<Maybe<ResolversTypes['CreateFeedEventPayload']>, ParentType, ContextType, RequireFields<MutationCreateFeedEventArgs, 'input'>>,\n  createUser?: Resolver<Maybe<ResolversTypes['CreateUserPayload']>, ParentType, ContextType, RequireFields<MutationCreateUserArgs, 'input'>>,\n  updateFeedEventByNodeId?: Resolver<Maybe<ResolversTypes['UpdateFeedEventPayload']>, ParentType, ContextType, RequireFields<MutationUpdateFeedEventByNodeIdArgs, 'input'>>,\n  updateFeedEvent?: Resolver<Maybe<ResolversTypes['UpdateFeedEventPayload']>, ParentType, ContextType, RequireFields<MutationUpdateFeedEventArgs, 'input'>>,\n  deleteFeedEventByNodeId?: Resolver<Maybe<ResolversTypes['DeleteFeedEventPayload']>, ParentType, ContextType, RequireFields<MutationDeleteFeedEventByNodeIdArgs, 'input'>>,\n  deleteFeedEvent?: Resolver<Maybe<ResolversTypes['DeleteFeedEventPayload']>, ParentType, ContextType, RequireFields<MutationDeleteFeedEventArgs, 'input'>>,\n  authenticate?: Resolver<Maybe<ResolversTypes['AuthenticatePayload']>, ParentType, ContextType, RequireFields<MutationAuthenticateArgs, 'input'>>,\n  register?: Resolver<Maybe<ResolversTypes['RegisterPayload']>, ParentType, ContextType, RequireFields<MutationRegisterArgs, 'input'>>,\n  createGuide?: Resolver<ResolversTypes['CreateGuideResult'], ParentType, ContextType, RequireFields<MutationCreateGuideArgs, never>>,\n  updateGuide?: Resolver<ResolversTypes['UpdateGuideResult'], ParentType, ContextType, RequireFields<MutationUpdateGuideArgs, never>>,\n  deleteGuide?: Resolver<ResolversTypes['DeleteGuideResult'], ParentType, ContextType, RequireFields<MutationDeleteGuideArgs, never>>,\n  followUser?: Resolver<ResolversTypes['Result'], ParentType, ContextType, RequireFields<MutationFollowUserArgs, 'username'>>,\n  unfollowUser?: Resolver<ResolversTypes['Result'], ParentType, ContextType, RequireFields<MutationUnfollowUserArgs, 'username'>>,\n  addSpot?: Resolver<ResolversTypes['AddSpotResult'], ParentType, ContextType, RequireFields<MutationAddSpotArgs, 'input'>>,\n  updateSpot?: Resolver<ResolversTypes['UpdateSpotResult'], ParentType, ContextType, RequireFields<MutationUpdateSpotArgs, 'input'>>,\n  remvoeSpot?: Resolver<ResolversTypes['RemoveSpotResult'], ParentType, ContextType, RequireFields<MutationRemvoeSpotArgs, 'input'>>,\n};\n\nexport type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n  __resolveType: TypeResolveFn<'Query' | 'Computation' | 'Stage' | 'Guide' | 'User' | 'Spot' | 'Ride' | 'FeedEvent' | 'Temperature', ParentType, ContextType>,\n  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>,\n};\n\nexport type PageInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = {\n  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>,\n  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>,\n  startCursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>,\n  endCursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n  query?: Resolver<ResolversTypes['Query'], ParentType, ContextType>,\n  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>,\n  node?: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType, RequireFields<QueryNodeArgs, 'nodeId'>>,\n  computations?: Resolver<Maybe<ResolversTypes['ComputationsConnection']>, ParentType, ContextType, RequireFields<QueryComputationsArgs, 'orderBy'>>,\n  feedEvents?: Resolver<Maybe<ResolversTypes['FeedEventsConnection']>, ParentType, ContextType, RequireFields<QueryFeedEventsArgs, 'orderBy'>>,\n  follows?: Resolver<Maybe<ResolversTypes['FollowsConnection']>, ParentType, ContextType, RequireFields<QueryFollowsArgs, 'orderBy'>>,\n  guides?: Resolver<Maybe<ResolversTypes['GuidesConnection']>, ParentType, ContextType, RequireFields<QueryGuidesArgs, 'orderBy'>>,\n  rides?: Resolver<Maybe<ResolversTypes['RidesConnection']>, ParentType, ContextType, RequireFields<QueryRidesArgs, 'orderBy'>>,\n  spots?: Resolver<Maybe<ResolversTypes['SpotsConnection']>, ParentType, ContextType, RequireFields<QuerySpotsArgs, 'orderBy'>>,\n  stages?: Resolver<Maybe<ResolversTypes['StagesConnection']>, ParentType, ContextType, RequireFields<QueryStagesArgs, 'orderBy'>>,\n  temperatures?: Resolver<Maybe<ResolversTypes['TemperaturesConnection']>, ParentType, ContextType, RequireFields<QueryTemperaturesArgs, 'orderBy'>>,\n  users?: Resolver<Maybe<ResolversTypes['UsersConnection']>, ParentType, ContextType, RequireFields<QueryUsersArgs, 'orderBy'>>,\n  computation?: Resolver<Maybe<ResolversTypes['Computation']>, ParentType, ContextType, RequireFields<QueryComputationArgs, 'id'>>,\n  feedEvent?: Resolver<Maybe<ResolversTypes['FeedEvent']>, ParentType, ContextType, RequireFields<QueryFeedEventArgs, 'timestamp'>>,\n  guide?: Resolver<Maybe<ResolversTypes['Guide']>, ParentType, ContextType, RequireFields<QueryGuideArgs, 'id'>>,\n  ride?: Resolver<Maybe<ResolversTypes['Ride']>, ParentType, ContextType, RequireFields<QueryRideArgs, 'id'>>,\n  spot?: Resolver<Maybe<ResolversTypes['Spot']>, ParentType, ContextType, RequireFields<QuerySpotArgs, 'id'>>,\n  stage?: Resolver<Maybe<ResolversTypes['Stage']>, ParentType, ContextType, RequireFields<QueryStageArgs, 'id'>>,\n  temperature?: Resolver<Maybe<ResolversTypes['Temperature']>, ParentType, ContextType, RequireFields<QueryTemperatureArgs, 'id'>>,\n  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<QueryUserArgs, 'username'>>,\n  countries?: Resolver<Maybe<ReadonlyArray<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>,\n  feed?: Resolver<ResolversTypes['FeedEventsConnection'], ParentType, ContextType, RequireFields<QueryFeedArgs, never>>,\n  getCurrentUser?: Resolver<Maybe<ResolversTypes['JwtToken']>, ParentType, ContextType>,\n  computationByNodeId?: Resolver<Maybe<ResolversTypes['Computation']>, ParentType, ContextType, RequireFields<QueryComputationByNodeIdArgs, 'nodeId'>>,\n  feedEventByNodeId?: Resolver<Maybe<ResolversTypes['FeedEvent']>, ParentType, ContextType, RequireFields<QueryFeedEventByNodeIdArgs, 'nodeId'>>,\n  guideByNodeId?: Resolver<Maybe<ResolversTypes['Guide']>, ParentType, ContextType, RequireFields<QueryGuideByNodeIdArgs, 'nodeId'>>,\n  rideByNodeId?: Resolver<Maybe<ResolversTypes['Ride']>, ParentType, ContextType, RequireFields<QueryRideByNodeIdArgs, 'nodeId'>>,\n  spotByNodeId?: Resolver<Maybe<ResolversTypes['Spot']>, ParentType, ContextType, RequireFields<QuerySpotByNodeIdArgs, 'nodeId'>>,\n  stageByNodeId?: Resolver<Maybe<ResolversTypes['Stage']>, ParentType, ContextType, RequireFields<QueryStageByNodeIdArgs, 'nodeId'>>,\n  temperatureByNodeId?: Resolver<Maybe<ResolversTypes['Temperature']>, ParentType, ContextType, RequireFields<QueryTemperatureByNodeIdArgs, 'nodeId'>>,\n  userByNodeId?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<QueryUserByNodeIdArgs, 'nodeId'>>,\n  geocode?: Resolver<ResolversTypes['GeocodeResponse'], ParentType, ContextType, RequireFields<QueryGeocodeArgs, 'query'>>,\n  appVersion?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n};\n\nexport type RegisterPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['RegisterPayload'] = ResolversParentTypes['RegisterPayload']> = {\n  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>,\n  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>,\n  userEdge?: Resolver<Maybe<ResolversTypes['UsersEdge']>, ParentType, ContextType, RequireFields<RegisterPayloadUserEdgeArgs, 'orderBy'>>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type RemoveSpotResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['RemoveSpotResult'] = ResolversParentTypes['RemoveSpotResult']> = {\n  success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>,\n  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type ResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['Result'] = ResolversParentTypes['Result']> = {\n  success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>,\n  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type RideResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ride'] = ResolversParentTypes['Ride']> = {\n  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>,\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  guide?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  owner?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  fromSpot?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  toSpot?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  pathUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  durationSeconds?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>,\n  distanceMeters?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>,\n  date?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  stage?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  position?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  status?: Resolver<ResolversTypes['RideStatus'], ParentType, ContextType>,\n  created?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>,\n  updated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>,\n  guideByGuide?: Resolver<Maybe<ResolversTypes['Guide']>, ParentType, ContextType>,\n  userByOwner?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>,\n  spotByFromSpot?: Resolver<Maybe<ResolversTypes['Spot']>, ParentType, ContextType>,\n  spotByToSpot?: Resolver<Maybe<ResolversTypes['Spot']>, ParentType, ContextType>,\n  stageByStage?: Resolver<Maybe<ResolversTypes['Stage']>, ParentType, ContextType>,\n  feedEventsByRide?: Resolver<ResolversTypes['FeedEventsConnection'], ParentType, ContextType, RequireFields<RideFeedEventsByRideArgs, 'orderBy'>>,\n  countries?: Resolver<Maybe<ReadonlyArray<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>,\n  hasBorder?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>,\n  isMine?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>,\n  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type RidesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RidesConnection'] = ResolversParentTypes['RidesConnection']> = {\n  nodes?: Resolver<ReadonlyArray<Maybe<ResolversTypes['Ride']>>, ParentType, ContextType>,\n  edges?: Resolver<ReadonlyArray<ResolversTypes['RidesEdge']>, ParentType, ContextType>,\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>,\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type RidesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RidesEdge'] = ResolversParentTypes['RidesEdge']> = {\n  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>,\n  node?: Resolver<Maybe<ResolversTypes['Ride']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type SpotResolvers<ContextType = any, ParentType extends ResolversParentTypes['Spot'] = ResolversParentTypes['Spot']> = {\n  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>,\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  guide?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  owner?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  nights?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>,\n  locked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>,\n  lat?: Resolver<ResolversTypes['Float'], ParentType, ContextType>,\n  long?: Resolver<ResolversTypes['Float'], ParentType, ContextType>,\n  position?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  date?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  created?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>,\n  updated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>,\n  stage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  guideByGuide?: Resolver<Maybe<ResolversTypes['Guide']>, ParentType, ContextType>,\n  userByOwner?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>,\n  stageByStage?: Resolver<Maybe<ResolversTypes['Stage']>, ParentType, ContextType>,\n  stagesByFromSpot?: Resolver<ResolversTypes['StagesConnection'], ParentType, ContextType, RequireFields<SpotStagesByFromSpotArgs, 'orderBy'>>,\n  stagesByToSpot?: Resolver<ResolversTypes['StagesConnection'], ParentType, ContextType, RequireFields<SpotStagesByToSpotArgs, 'orderBy'>>,\n  ridesByFromSpot?: Resolver<ResolversTypes['RidesConnection'], ParentType, ContextType, RequireFields<SpotRidesByFromSpotArgs, 'orderBy'>>,\n  ridesByToSpot?: Resolver<ResolversTypes['RidesConnection'], ParentType, ContextType, RequireFields<SpotRidesByToSpotArgs, 'orderBy'>>,\n  isMine?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>,\n  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  temperature?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type SpotsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SpotsConnection'] = ResolversParentTypes['SpotsConnection']> = {\n  nodes?: Resolver<ReadonlyArray<Maybe<ResolversTypes['Spot']>>, ParentType, ContextType>,\n  edges?: Resolver<ReadonlyArray<ResolversTypes['SpotsEdge']>, ParentType, ContextType>,\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>,\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type SpotsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SpotsEdge'] = ResolversParentTypes['SpotsEdge']> = {\n  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>,\n  node?: Resolver<Maybe<ResolversTypes['Spot']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type StageResolvers<ContextType = any, ParentType extends ResolversParentTypes['Stage'] = ResolversParentTypes['Stage']> = {\n  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>,\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  guide?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  fromSpot?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  toSpot?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  created?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>,\n  updated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>,\n  status?: Resolver<ResolversTypes['StageStatus'], ParentType, ContextType>,\n  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>,\n  guideByGuide?: Resolver<Maybe<ResolversTypes['Guide']>, ParentType, ContextType>,\n  spotByFromSpot?: Resolver<Maybe<ResolversTypes['Spot']>, ParentType, ContextType>,\n  spotByToSpot?: Resolver<Maybe<ResolversTypes['Spot']>, ParentType, ContextType>,\n  spotsByStage?: Resolver<ResolversTypes['SpotsConnection'], ParentType, ContextType, RequireFields<StageSpotsByStageArgs, 'orderBy'>>,\n  ridesByStage?: Resolver<ResolversTypes['RidesConnection'], ParentType, ContextType, RequireFields<StageRidesByStageArgs, 'orderBy'>>,\n  computationsByStage?: Resolver<ResolversTypes['ComputationsConnection'], ParentType, ContextType, RequireFields<StageComputationsByStageArgs, 'orderBy'>>,\n  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type StagesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StagesConnection'] = ResolversParentTypes['StagesConnection']> = {\n  nodes?: Resolver<ReadonlyArray<Maybe<ResolversTypes['Stage']>>, ParentType, ContextType>,\n  edges?: Resolver<ReadonlyArray<ResolversTypes['StagesEdge']>, ParentType, ContextType>,\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>,\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type StagesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StagesEdge'] = ResolversParentTypes['StagesEdge']> = {\n  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>,\n  node?: Resolver<Maybe<ResolversTypes['Stage']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n  query?: SubscriptionResolver<ResolversTypes['Query'], \"query\", ParentType, ContextType>,\n  nodeId?: SubscriptionResolver<ResolversTypes['ID'], \"nodeId\", ParentType, ContextType>,\n  node?: SubscriptionResolver<Maybe<ResolversTypes['Node']>, \"node\", ParentType, ContextType, RequireFields<SubscriptionNodeArgs, 'nodeId'>>,\n  computations?: SubscriptionResolver<Maybe<ResolversTypes['ComputationsConnection']>, \"computations\", ParentType, ContextType, RequireFields<SubscriptionComputationsArgs, 'orderBy'>>,\n  feedEvents?: SubscriptionResolver<Maybe<ResolversTypes['FeedEventsConnection']>, \"feedEvents\", ParentType, ContextType, RequireFields<SubscriptionFeedEventsArgs, 'orderBy'>>,\n  follows?: SubscriptionResolver<Maybe<ResolversTypes['FollowsConnection']>, \"follows\", ParentType, ContextType, RequireFields<SubscriptionFollowsArgs, 'orderBy'>>,\n  guides?: SubscriptionResolver<Maybe<ResolversTypes['GuidesConnection']>, \"guides\", ParentType, ContextType, RequireFields<SubscriptionGuidesArgs, 'orderBy'>>,\n  rides?: SubscriptionResolver<Maybe<ResolversTypes['RidesConnection']>, \"rides\", ParentType, ContextType, RequireFields<SubscriptionRidesArgs, 'orderBy'>>,\n  spots?: SubscriptionResolver<Maybe<ResolversTypes['SpotsConnection']>, \"spots\", ParentType, ContextType, RequireFields<SubscriptionSpotsArgs, 'orderBy'>>,\n  stages?: SubscriptionResolver<Maybe<ResolversTypes['StagesConnection']>, \"stages\", ParentType, ContextType, RequireFields<SubscriptionStagesArgs, 'orderBy'>>,\n  temperatures?: SubscriptionResolver<Maybe<ResolversTypes['TemperaturesConnection']>, \"temperatures\", ParentType, ContextType, RequireFields<SubscriptionTemperaturesArgs, 'orderBy'>>,\n  users?: SubscriptionResolver<Maybe<ResolversTypes['UsersConnection']>, \"users\", ParentType, ContextType, RequireFields<SubscriptionUsersArgs, 'orderBy'>>,\n  computation?: SubscriptionResolver<Maybe<ResolversTypes['Computation']>, \"computation\", ParentType, ContextType, RequireFields<SubscriptionComputationArgs, 'id'>>,\n  feedEvent?: SubscriptionResolver<Maybe<ResolversTypes['FeedEvent']>, \"feedEvent\", ParentType, ContextType, RequireFields<SubscriptionFeedEventArgs, 'timestamp'>>,\n  guide?: SubscriptionResolver<Maybe<ResolversTypes['Guide']>, \"guide\", ParentType, ContextType, RequireFields<SubscriptionGuideArgs, 'id'>>,\n  ride?: SubscriptionResolver<Maybe<ResolversTypes['Ride']>, \"ride\", ParentType, ContextType, RequireFields<SubscriptionRideArgs, 'id'>>,\n  spot?: SubscriptionResolver<Maybe<ResolversTypes['Spot']>, \"spot\", ParentType, ContextType, RequireFields<SubscriptionSpotArgs, 'id'>>,\n  stage?: SubscriptionResolver<Maybe<ResolversTypes['Stage']>, \"stage\", ParentType, ContextType, RequireFields<SubscriptionStageArgs, 'id'>>,\n  temperature?: SubscriptionResolver<Maybe<ResolversTypes['Temperature']>, \"temperature\", ParentType, ContextType, RequireFields<SubscriptionTemperatureArgs, 'id'>>,\n  user?: SubscriptionResolver<Maybe<ResolversTypes['User']>, \"user\", ParentType, ContextType, RequireFields<SubscriptionUserArgs, 'username'>>,\n  countries?: SubscriptionResolver<Maybe<ReadonlyArray<Maybe<ResolversTypes['String']>>>, \"countries\", ParentType, ContextType>,\n  feed?: SubscriptionResolver<ResolversTypes['FeedEventsConnection'], \"feed\", ParentType, ContextType, RequireFields<SubscriptionFeedArgs, never>>,\n  getCurrentUser?: SubscriptionResolver<Maybe<ResolversTypes['JwtToken']>, \"getCurrentUser\", ParentType, ContextType>,\n  computationByNodeId?: SubscriptionResolver<Maybe<ResolversTypes['Computation']>, \"computationByNodeId\", ParentType, ContextType, RequireFields<SubscriptionComputationByNodeIdArgs, 'nodeId'>>,\n  feedEventByNodeId?: SubscriptionResolver<Maybe<ResolversTypes['FeedEvent']>, \"feedEventByNodeId\", ParentType, ContextType, RequireFields<SubscriptionFeedEventByNodeIdArgs, 'nodeId'>>,\n  guideByNodeId?: SubscriptionResolver<Maybe<ResolversTypes['Guide']>, \"guideByNodeId\", ParentType, ContextType, RequireFields<SubscriptionGuideByNodeIdArgs, 'nodeId'>>,\n  rideByNodeId?: SubscriptionResolver<Maybe<ResolversTypes['Ride']>, \"rideByNodeId\", ParentType, ContextType, RequireFields<SubscriptionRideByNodeIdArgs, 'nodeId'>>,\n  spotByNodeId?: SubscriptionResolver<Maybe<ResolversTypes['Spot']>, \"spotByNodeId\", ParentType, ContextType, RequireFields<SubscriptionSpotByNodeIdArgs, 'nodeId'>>,\n  stageByNodeId?: SubscriptionResolver<Maybe<ResolversTypes['Stage']>, \"stageByNodeId\", ParentType, ContextType, RequireFields<SubscriptionStageByNodeIdArgs, 'nodeId'>>,\n  temperatureByNodeId?: SubscriptionResolver<Maybe<ResolversTypes['Temperature']>, \"temperatureByNodeId\", ParentType, ContextType, RequireFields<SubscriptionTemperatureByNodeIdArgs, 'nodeId'>>,\n  userByNodeId?: SubscriptionResolver<Maybe<ResolversTypes['User']>, \"userByNodeId\", ParentType, ContextType, RequireFields<SubscriptionUserByNodeIdArgs, 'nodeId'>>,\n  geocode?: SubscriptionResolver<ResolversTypes['GeocodeResponse'], \"geocode\", ParentType, ContextType, RequireFields<SubscriptionGeocodeArgs, 'query'>>,\n  appVersion?: SubscriptionResolver<ResolversTypes['String'], \"appVersion\", ParentType, ContextType>,\n};\n\nexport type TemperatureResolvers<ContextType = any, ParentType extends ResolversParentTypes['Temperature'] = ResolversParentTypes['Temperature']> = {\n  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>,\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  country?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  month?: Resolver<ResolversTypes['Int'], ParentType, ContextType>,\n  temperature?: Resolver<ResolversTypes['Float'], ParentType, ContextType>,\n  created?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>,\n  updated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type TemperaturesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemperaturesConnection'] = ResolversParentTypes['TemperaturesConnection']> = {\n  nodes?: Resolver<ReadonlyArray<Maybe<ResolversTypes['Temperature']>>, ParentType, ContextType>,\n  edges?: Resolver<ReadonlyArray<ResolversTypes['TemperaturesEdge']>, ParentType, ContextType>,\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>,\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type TemperaturesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemperaturesEdge'] = ResolversParentTypes['TemperaturesEdge']> = {\n  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>,\n  node?: Resolver<Maybe<ResolversTypes['Temperature']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type UpdateFeedEventPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateFeedEventPayload'] = ResolversParentTypes['UpdateFeedEventPayload']> = {\n  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  feedEvent?: Resolver<Maybe<ResolversTypes['FeedEvent']>, ParentType, ContextType>,\n  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>,\n  rideByRide?: Resolver<Maybe<ResolversTypes['Ride']>, ParentType, ContextType>,\n  guideByGuide?: Resolver<Maybe<ResolversTypes['Guide']>, ParentType, ContextType>,\n  userByUser?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>,\n  feedEventEdge?: Resolver<Maybe<ResolversTypes['FeedEventsEdge']>, ParentType, ContextType, RequireFields<UpdateFeedEventPayloadFeedEventEdgeArgs, 'orderBy'>>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type UpdateGuideResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateGuideResult'] = ResolversParentTypes['UpdateGuideResult']> = {\n  success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>,\n  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  triggeredDates?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>,\n  triggeredComputations?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type UpdateSpotResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateSpotResult'] = ResolversParentTypes['UpdateSpotResult']> = {\n  success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>,\n  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,\n  triggeredComputations?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>,\n  ammendedDates?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\n  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>,\n  username?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  passwordHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>,\n  colour?: Resolver<Maybe<ResolversTypes['Colour']>, ParentType, ContextType>,\n  created?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>,\n  updated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>,\n  guidesByOwner?: Resolver<ResolversTypes['GuidesConnection'], ParentType, ContextType, RequireFields<UserGuidesByOwnerArgs, 'orderBy'>>,\n  spotsByOwner?: Resolver<ResolversTypes['SpotsConnection'], ParentType, ContextType, RequireFields<UserSpotsByOwnerArgs, 'orderBy'>>,\n  ridesByOwner?: Resolver<ResolversTypes['RidesConnection'], ParentType, ContextType, RequireFields<UserRidesByOwnerArgs, 'orderBy'>>,\n  followsByFollowed?: Resolver<ResolversTypes['FollowsConnection'], ParentType, ContextType, RequireFields<UserFollowsByFollowedArgs, 'orderBy'>>,\n  followsByFollower?: Resolver<ResolversTypes['FollowsConnection'], ParentType, ContextType, RequireFields<UserFollowsByFollowerArgs, 'orderBy'>>,\n  feedEventsByUser?: Resolver<ResolversTypes['FeedEventsConnection'], ParentType, ContextType, RequireFields<UserFeedEventsByUserArgs, 'orderBy'>>,\n  countries?: Resolver<Maybe<ReadonlyArray<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>,\n  distanceMeters?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>,\n  durationSeconds?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>,\n  followingStatus?: Resolver<Maybe<ResolversTypes['FollowingStatus']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type UsersConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UsersConnection'] = ResolversParentTypes['UsersConnection']> = {\n  nodes?: Resolver<ReadonlyArray<Maybe<ResolversTypes['User']>>, ParentType, ContextType>,\n  edges?: Resolver<ReadonlyArray<ResolversTypes['UsersEdge']>, ParentType, ContextType>,\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>,\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type UsersEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UsersEdge'] = ResolversParentTypes['UsersEdge']> = {\n  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>,\n  node?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>,\n  __isTypeOf?: isTypeOfResolverFn<ParentType>,\n};\n\nexport type Resolvers<ContextType = any> = {\n  AddSpotResult?: AddSpotResultResolvers<ContextType>,\n  AuthenticatePayload?: AuthenticatePayloadResolvers<ContextType>,\n  BigInt?: GraphQLScalarType,\n  Bound?: BoundResolvers<ContextType>,\n  Computation?: ComputationResolvers<ContextType>,\n  ComputationsConnection?: ComputationsConnectionResolvers<ContextType>,\n  ComputationsEdge?: ComputationsEdgeResolvers<ContextType>,\n  CreateFeedEventPayload?: CreateFeedEventPayloadResolvers<ContextType>,\n  CreateGuideResult?: CreateGuideResultResolvers<ContextType>,\n  CreateUserPayload?: CreateUserPayloadResolvers<ContextType>,\n  Cursor?: GraphQLScalarType,\n  Datetime?: GraphQLScalarType,\n  DeleteFeedEventPayload?: DeleteFeedEventPayloadResolvers<ContextType>,\n  DeleteGuideResult?: DeleteGuideResultResolvers<ContextType>,\n  FeedEvent?: FeedEventResolvers<ContextType>,\n  FeedEventsConnection?: FeedEventsConnectionResolvers<ContextType>,\n  FeedEventsEdge?: FeedEventsEdgeResolvers<ContextType>,\n  Follow?: FollowResolvers<ContextType>,\n  FollowsConnection?: FollowsConnectionResolvers<ContextType>,\n  FollowsEdge?: FollowsEdgeResolvers<ContextType>,\n  Geocode?: GeocodeResolvers<ContextType>,\n  GeocodeResponse?: GeocodeResponseResolvers<ContextType>,\n  Guide?: GuideResolvers<ContextType>,\n  GuidesConnection?: GuidesConnectionResolvers<ContextType>,\n  GuidesEdge?: GuidesEdgeResolvers<ContextType>,\n  JwtToken?: GraphQLScalarType,\n  Mutation?: MutationResolvers<ContextType>,\n  Node?: NodeResolvers,\n  PageInfo?: PageInfoResolvers<ContextType>,\n  Query?: QueryResolvers<ContextType>,\n  RegisterPayload?: RegisterPayloadResolvers<ContextType>,\n  RemoveSpotResult?: RemoveSpotResultResolvers<ContextType>,\n  Result?: ResultResolvers<ContextType>,\n  Ride?: RideResolvers<ContextType>,\n  RidesConnection?: RidesConnectionResolvers<ContextType>,\n  RidesEdge?: RidesEdgeResolvers<ContextType>,\n  Spot?: SpotResolvers<ContextType>,\n  SpotsConnection?: SpotsConnectionResolvers<ContextType>,\n  SpotsEdge?: SpotsEdgeResolvers<ContextType>,\n  Stage?: StageResolvers<ContextType>,\n  StagesConnection?: StagesConnectionResolvers<ContextType>,\n  StagesEdge?: StagesEdgeResolvers<ContextType>,\n  Subscription?: SubscriptionResolvers<ContextType>,\n  Temperature?: TemperatureResolvers<ContextType>,\n  TemperaturesConnection?: TemperaturesConnectionResolvers<ContextType>,\n  TemperaturesEdge?: TemperaturesEdgeResolvers<ContextType>,\n  UpdateFeedEventPayload?: UpdateFeedEventPayloadResolvers<ContextType>,\n  UpdateGuideResult?: UpdateGuideResultResolvers<ContextType>,\n  UpdateSpotResult?: UpdateSpotResultResolvers<ContextType>,\n  User?: UserResolvers<ContextType>,\n  UsersConnection?: UsersConnectionResolvers<ContextType>,\n  UsersEdge?: UsersEdgeResolvers<ContextType>,\n};\n\n\n/**\n * @deprecated\n * Use \"Resolvers\" root object instead. If you wish to get \"IResolvers\", add \"typesPrefix: I\" to your config.\n */\nexport type IResolvers<ContextType = any> = Resolvers<ContextType>;\n\nexport type LoginMutationVariables = {\n  email: Scalars['String'];\n  password: Scalars['String'];\n};\n\n\nexport type LoginMutation = { readonly authenticate?: Maybe<Pick<AuthenticatePayload, 'jwtToken'>> };\n\nexport type SignUpMutationVariables = {\n  username: Scalars['String'];\n  email: Scalars['String'];\n  password: Scalars['String'];\n};\n\n\nexport type SignUpMutation = { readonly register?: Maybe<{ readonly user?: Maybe<Pick<User, 'username'>> }> };\n\nexport type GetUsernameQueryVariables = {\n  email: Scalars['String'];\n};\n\n\nexport type GetUsernameQuery = { readonly users?: Maybe<{ readonly nodes: ReadonlyArray<Maybe<Pick<User, 'username' | 'colour'>>> }> };\n\n\nexport const LoginDocument = gql`\n    mutation Login($email: String!, $password: String!) {\n  authenticate(input: {email: $email, password: $password}) {\n    jwtToken\n  }\n}\n    `;\nexport type LoginMutationFn = ApolloReactCommon.MutationFunction<LoginMutation, LoginMutationVariables>;\nexport type LoginComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<LoginMutation, LoginMutationVariables>, 'mutation'>;\n\n    export const LoginComponent = (props: LoginComponentProps) => (\n      <ApolloReactComponents.Mutation<LoginMutation, LoginMutationVariables> mutation={LoginDocument} {...props} />\n    );\n    \n\n/**\n * __useLoginMutation__\n *\n * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useLoginMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [loginMutation, { data, loading, error }] = useLoginMutation({\n *   variables: {\n *      email: // value for 'email'\n *      password: // value for 'password'\n *   },\n * });\n */\nexport function useLoginMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<LoginMutation, LoginMutationVariables>) {\n        return ApolloReactHooks.useMutation<LoginMutation, LoginMutationVariables>(LoginDocument, baseOptions);\n      }\nexport type LoginMutationHookResult = ReturnType<typeof useLoginMutation>;\nexport type LoginMutationResult = ApolloReactCommon.MutationResult<LoginMutation>;\nexport type LoginMutationOptions = ApolloReactCommon.BaseMutationOptions<LoginMutation, LoginMutationVariables>;\nexport const SignUpDocument = gql`\n    mutation SignUp($username: String!, $email: String!, $password: String!) {\n  register(input: {_email: $email, _username: $username, _password: $password}) {\n    user {\n      username\n    }\n  }\n}\n    `;\nexport type SignUpMutationFn = ApolloReactCommon.MutationFunction<SignUpMutation, SignUpMutationVariables>;\nexport type SignUpComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<SignUpMutation, SignUpMutationVariables>, 'mutation'>;\n\n    export const SignUpComponent = (props: SignUpComponentProps) => (\n      <ApolloReactComponents.Mutation<SignUpMutation, SignUpMutationVariables> mutation={SignUpDocument} {...props} />\n    );\n    \n\n/**\n * __useSignUpMutation__\n *\n * To run a mutation, you first call `useSignUpMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useSignUpMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [signUpMutation, { data, loading, error }] = useSignUpMutation({\n *   variables: {\n *      username: // value for 'username'\n *      email: // value for 'email'\n *      password: // value for 'password'\n *   },\n * });\n */\nexport function useSignUpMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<SignUpMutation, SignUpMutationVariables>) {\n        return ApolloReactHooks.useMutation<SignUpMutation, SignUpMutationVariables>(SignUpDocument, baseOptions);\n      }\nexport type SignUpMutationHookResult = ReturnType<typeof useSignUpMutation>;\nexport type SignUpMutationResult = ApolloReactCommon.MutationResult<SignUpMutation>;\nexport type SignUpMutationOptions = ApolloReactCommon.BaseMutationOptions<SignUpMutation, SignUpMutationVariables>;\nexport const GetUsernameDocument = gql`\n    query GetUsername($email: String!) {\n  users(condition: {email: $email}) {\n    nodes {\n      username\n      colour\n    }\n  }\n}\n    `;\nexport type GetUsernameComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<GetUsernameQuery, GetUsernameQueryVariables>, 'query'> & ({ variables: GetUsernameQueryVariables; skip?: boolean; } | { skip: boolean; });\n\n    export const GetUsernameComponent = (props: GetUsernameComponentProps) => (\n      <ApolloReactComponents.Query<GetUsernameQuery, GetUsernameQueryVariables> query={GetUsernameDocument} {...props} />\n    );\n    \n\n/**\n * __useGetUsernameQuery__\n *\n * To run a query within a React component, call `useGetUsernameQuery` and pass it any options that fit your needs.\n * When your component renders, `useGetUsernameQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useGetUsernameQuery({\n *   variables: {\n *      email: // value for 'email'\n *   },\n * });\n */\nexport function useGetUsernameQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<GetUsernameQuery, GetUsernameQueryVariables>) {\n        return ApolloReactHooks.useQuery<GetUsernameQuery, GetUsernameQueryVariables>(GetUsernameDocument, baseOptions);\n      }\nexport function useGetUsernameLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GetUsernameQuery, GetUsernameQueryVariables>) {\n          return ApolloReactHooks.useLazyQuery<GetUsernameQuery, GetUsernameQueryVariables>(GetUsernameDocument, baseOptions);\n        }\nexport type GetUsernameQueryHookResult = ReturnType<typeof useGetUsernameQuery>;\nexport type GetUsernameLazyQueryHookResult = ReturnType<typeof useGetUsernameLazyQuery>;\nexport type GetUsernameQueryResult = ApolloReactCommon.QueryResult<GetUsernameQuery, GetUsernameQueryVariables>;"]},"metadata":{},"sourceType":"module"}