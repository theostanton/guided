{"ast":null,"code":"var _class, _descriptor, _temp;\n\nfunction _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }\n\nfunction _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }\n\nimport { action, computed, observable } from 'mobx';\nimport client, { USER_KEY } from 'api/client';\nimport * as storage from 'utils/storage';\nimport { GetUsernameDocument, LoginDocument, SignUpDocument } from 'api/generated';\nimport { Store } from 'stores/Store';\nlet AuthStore = (_class = (_temp = class AuthStore extends Store {\n  static init() {\n    const exists = storage.exists(USER_KEY);\n\n    if (exists) {\n      const user = storage.getObject(USER_KEY);\n      console.log('this.user', this.user);\n    }\n  }\n\n  constructor(user) {\n    super();\n\n    _initializerDefineProperty(this, \"user\", _descriptor, this);\n\n    this.user = user;\n  }\n\n  hydrate(initialData) {}\n\n  get isLoggedIn() {\n    return this.user !== undefined;\n  }\n\n  setUser(user) {\n    if (user) {\n      cookies.set(USER_KEY, JSON.stringify(user, null, 4));\n    } else {\n      cookies.destroy(USER_KEY);\n    }\n\n    this.user = user;\n  }\n\n  async login(email, password) {\n    var _result$data$authenti;\n\n    const variables = {\n      email,\n      password\n    };\n    const result = await client.mutate({\n      mutation: LoginDocument,\n      variables\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      // logError('LoginMutation error');\n      result.errors.forEach(error => {// logError(error.message);\n      });\n      return {\n        success: false,\n        message: result.errors.map(error => {\n          return error.message;\n        }).join('\\n')\n      };\n    }\n\n    if (!((_result$data$authenti = result.data.authenticate) === null || _result$data$authenti === void 0 ? void 0 : _result$data$authenti.jwtToken)) {\n      return {\n        success: false,\n        message: 'Failed to login'\n      };\n    }\n\n    const bearerToken = result.data.authenticate.jwtToken;\n    this.setUser({\n      email,\n      bearerToken\n    });\n    const usernameResult = await client.query({\n      query: GetUsernameDocument,\n      variables: {\n        email\n      }\n    });\n\n    if (usernameResult.errors && usernameResult.errors.length > 0) {\n      // logError('GetUsername error');\n      usernameResult.errors.forEach(error => {// logError(error.message);\n      });\n      this.setUser(undefined);\n      return {\n        success: false,\n        message: result.errors.map(error => {\n          return error.message;\n        }).join('\\n')\n      };\n    }\n\n    const {\n      colour,\n      username\n    } = usernameResult.data.users.nodes[0];\n    this.setUser({\n      username,\n      email,\n      bearerToken\n    });\n    return {\n      success: true\n    };\n  }\n\n  async signUp(username, email, password) {\n    const variables = {\n      username,\n      email,\n      password\n    };\n    const result = await client.mutate({\n      mutation: SignUpDocument,\n      variables\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      return {\n        success: false,\n        message: result.errors.map(error => {\n          return error.message;\n        }).join('\\n')\n      };\n    }\n\n    return this.login(email, password);\n  }\n\n  logOut() {\n    this.setUser(undefined);\n    console.log('logOUt this.user=', this.user);\n  }\n\n}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"user\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _applyDecoratedDescriptor(_class.prototype, \"isLoggedIn\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"isLoggedIn\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"setUser\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"setUser\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"logOut\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"logOut\"), _class.prototype)), _class);\nexport { AuthStore as default };\nconst authStore = new AuthStore();\nexport { authStore };","map":{"version":3,"sources":["/Users/theo/Code/guided/frontend/site/src/stores/AuthStore/index.ts"],"names":["action","computed","observable","client","USER_KEY","storage","GetUsernameDocument","LoginDocument","SignUpDocument","Store","AuthStore","init","exists","user","getObject","console","log","constructor","hydrate","initialData","isLoggedIn","undefined","setUser","cookies","set","JSON","stringify","destroy","login","email","password","variables","result","mutate","mutation","errors","length","forEach","error","success","message","map","join","data","authenticate","jwtToken","bearerToken","usernameResult","query","colour","username","users","nodes","signUp","logOut","authStore"],"mappings":"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","sourcesContent":["import {action, computed, observable, runInAction} from 'mobx';\nimport client, {USER_KEY} from 'api/client';\nimport * as storage from 'utils/storage';\nimport {\n  GetUsernameDocument,\n  GetUsernameQuery,\n  GetUsernameQueryVariables,\n  LoginDocument,\n  LoginMutation,\n  LoginMutationVariables,\n  SignUpDocument,\n  SignUpMutation,\n  SignUpMutationVariables,\n} from 'api/generated';\nimport {Store} from 'stores/Store';\n\nexport type User = {\n  bearerToken: string;\n  username?: string;\n  email: string;\n};\n\nexport default class AuthStore extends Store<User> {\n  static init(): Promise<AuthStore> {\n    const exists = storage.exists(USER_KEY);\n    if (exists) {\n      const user = storage.getObject<User>(USER_KEY);\n      console.log('this.user', this.user);\n    }\n  }\n\n  @observable\n  user: User | undefined;\n\n  constructor(user: User | undefined) {\n    super();\n    this.user = user;\n  }\n\n  hydrate(initialData: User | undefined) {}\n\n  @computed\n  get isLoggedIn(): boolean {\n    return this.user !== undefined;\n  }\n\n  @action\n  setUser(user: User | undefined) {\n    if (user) {\n      cookies.set(USER_KEY, JSON.stringify(user, null, 4));\n    } else {\n      cookies.destroy(USER_KEY);\n    }\n    this.user = user;\n  }\n\n  async login(\n    email: string,\n    password: string,\n  ): Promise<{\n    success: boolean;\n    message?: string;\n  }> {\n    const variables: LoginMutationVariables = {\n      email,\n      password,\n    };\n    const result = await client.mutate<LoginMutation>({\n      mutation: LoginDocument,\n      variables,\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      // logError('LoginMutation error');\n      result.errors.forEach((error) => {\n        // logError(error.message);\n      });\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    if (!result.data.authenticate?.jwtToken) {\n      return {\n        success: false,\n        message: 'Failed to login',\n      };\n    }\n\n    const bearerToken = result.data!.authenticate!.jwtToken;\n\n    this.setUser({\n      email,\n      bearerToken,\n    });\n\n    const usernameResult = await client.query<GetUsernameQuery>({\n      query: GetUsernameDocument,\n      variables: {\n        email,\n      } as GetUsernameQueryVariables,\n    });\n\n    if (usernameResult.errors && usernameResult.errors.length > 0) {\n      // logError('GetUsername error');\n      usernameResult.errors.forEach((error) => {\n        // logError(error.message);\n      });\n\n      this.setUser(undefined);\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    const {colour, username} = usernameResult.data!.users!.nodes[0]!;\n\n    this.setUser({\n      username,\n      email,\n      bearerToken,\n    });\n\n    return {\n      success: true,\n    };\n  }\n\n  async signUp(\n    username: string,\n    email: string,\n    password: string,\n  ): Promise<{success: boolean; message?: string}> {\n    const variables: SignUpMutationVariables = {\n      username,\n      email,\n      password,\n    };\n    const result = await client.mutate<SignUpMutation>({\n      mutation: SignUpDocument,\n      variables,\n    });\n\n    if (result.errors && result.errors.length > 0) {\n      return {\n        success: false,\n        message: result.errors\n          .map((error) => {\n            return error.message;\n          })\n          .join('\\n'),\n      };\n    }\n\n    return this.login(email, password);\n  }\n\n  @action\n  logOut() {\n    this.setUser(undefined);\n    console.log('logOUt this.user=', this.user);\n  }\n}\n\nconst authStore = new AuthStore();\n\nexport {authStore};\n"]},"metadata":{},"sourceType":"module"}